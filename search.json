[{"title":"算法学习_最近的请求次数","url":"/2021/10/01/2021-10-01-算法学习_最近的请求次数/","content":"\n# 最近的请求次数\n\n## 题目\n[lettcode-933题](https://leetcode-cn.com/problems/number-of-recent-calls/) \n难度：简单![1633055736251](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1633055736251.png)\n\n\n## 解题思路\n从题目上来看，一时半会看不出来是什么意思。\n\n其实所输入的数字t就是一个毫秒数，根据这个数来判断3000毫秒之前的数，如果小于3000毫秒之前的就删除小于的那个。\n\n所以当我们输入3002时，3000-3000=2，而1小于2，所以1就会被删除。\n\n所以说这个题是一个先进先出的方式，所以我们可以使用队列来实现。\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass RecentCounter {\n\n    //构造一个队列，LinkedList的队列\n    Queue<Integer> queue;\n    public RecentCounter() {\n        queue=new LinkedList<>();\n    }\n\n    public int ping(int t) {\n        //将输入的数值入队\n        queue.add(t);\n        //判断栈顶元素是否小于t-3000\n        //如果小于t-3000，将其出队\n        while (queue.peek()<t-3000){\n            queue.poll();\n        }\n        //返回队列的长度\n        return queue.size();\n    }\n}\n```","tags":["算法"]},{"title":"Redis使用注解实现二级缓存","url":"/2021/09/29/2021-09-29-Redis使用注解实现二级缓存/","content":"\n# Redis使用注解实现二级缓存\n\n## 1、介绍\n\n上一篇文章中，我们实现二级缓存的方式是通过java代码判断Redis是否存在缓存，然后决定从何处取数据，但是这种方法在我们有大量的需要用到缓存的地方的时候，会产生大量的冗余代码，而且有大量的判断语句，让我们的代码不能够专注于业务上面，这样子是不太好的。\n\n所以在Spring的3.1版本之后就引入了对注解的支持，我们可以通过在类上、方法上标记注解来实现二级缓存的存取\n\n其三个注解分别为：`Cacheable` ，`CacheEvict`，`CachePut`\n\n下面我会将三个注解分别展开进行简单解释\n\n## 2、Cacheable注解\n\n- @Cacheable可以标记在一个方法上，也可以标记在一个类上。\n- 对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。\n- Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果。\n- 至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。\n- 需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。\n- @Cacheable可以指定三个属性，value、key和condition。\n\n### 2.1、value属性\n\nvalue属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。\n如下例子所示：\n```java\n@RequestMapping(\"selectForAll\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper::AllStudent\")\npublic List<Student> selectStudentForAll() {\n    List<Student> studentList = studentService.selectStudentForAll();\n    return studentList;\n}\n```\n\n### 2.2、key属性\n\n- key属性是用来指定Spring缓存方法的返回结果时对应的key的。\n- 该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。\n- 定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n此时，如果我查询了一个sId为1800710318的学生\n那么上面的方法中最后缓存的键为：`MYBATIS:com.chen.mysqlredisdemo.StudentMapper::1800710318`\n\n### 2.3、condition属性\n\n- condition属性可以用于指定缓存发生的条件。\n- 有的时候我们可能并不希望缓存一个方法所有的返回结果，这时候通过condition属性可以实现这一功能。\n- condition属性默认为空，表示将缓存所有的调用情形。\n- 其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\",condition = \"#sId>1800710301\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n上面的例子就表示当查询的sId大于1800710318的时候才会执行缓存的操作\n\n## 3、CachePut注解\n\n- 在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。\n- @CachePut也可以声明一个方法支持缓存功能。\n- 与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。\n- @CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。\n\n简而言之就是CachePut只会往缓存中写数据，不会从缓存中拿数据\n\n## 4、CacheEvict注解\n\n- @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。\n- @CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。\n- 其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。\n- 与前面不同的不同的是有了两个多出来的属性：`allEntries`和`beforeInvocation`\n\n### 4.1、allEntries属性\n- allEntries是boolean类型，表示是否需要清除缓存中的所有元素。\n- 默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。\n- 有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。\n\n### 4.2、beforeInvocation属性\n\n- 清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。\n- 使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。\n\n## 5、Caching注解\n\n@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。\n其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。\n\n其例子如下\n```java\n @Caching(cacheable = @Cacheable(\"users\"), evict = { @CacheEvict(\"cache2\"), @CacheEvict(value = \"cache3\", allEntries = true) })\npublic User find(Integer id) {\n\treturnnull;\n}\n```\n上面的例子通过一个Caching注解，实现了三种注解同事的配置，相当于一个大集合\n\n\n## 6、总结\n\nSpringBoot中大量使用了注解、替代了原有的配置文件。\n大大减少了冗余代码，方便地实现了注解中所设置好的功能。\n使得我们的代码简洁易懂。\n除了官方默认的注解，同时我们还可以自定义很多注解，极大方便了我们的使用。","tags":["java"]},{"title":"Redis入门使用","url":"/2021/09/29/2021-09-29-Redis的入门使用/","content":"\n# Redis入门使用\n\n## 1、Redis简介\n1. 简介\nRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\n    - Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n    - Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n    - Redis支持数据的备份，即master-slave模式的数据备份。\n\n2. 优势\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n## 2、Redis安装\n### 2.1、window安装\n下载地址：https://github.com/tporadowski/redis/releases。\n** 根据自己电脑是32位或者64位的下载相对应得版本，就可以进行安装使用 **\n解压文件夹之后进入文件夹得目录下打开cmd\n输入以下命令，就可以运行redis\n`redis-server.exe redis.windows.conf`\n重新打开一个cmd，输入以下命令就可以进行数据库操作\n`redis-cli.exe -h 127.0.0.1 -p 6379`\n\n### 2.2、Linux安装\n下载地址：http://redis.io/download 下载最新稳定版本。\n在linux中对压缩包进行解压之后\n进入解压后的文件夹\n进行make操作\n```shell\n# wget http://download.redis.io/releases/redis-6.0.8.tar.gz\n# tar xzf redis-6.0.8.tar.gz\n# cd redis-6.0.8\n# make\n```\nmake之后，src目录下面就会出现一个`redis-server`的文件，可以用来启动Redis，如下\n```shell\n# cd src\n# ./redis-server\n```\n除此之外，Redis还给我们提供了一个配置文件，可以修改Redis的配置文件，并运行，如下\n```shell\n# cd src\n# ./redis-server ../redis.conf\n```\n### 2.3、Ubuntu apt 命令安装\nUbuntu系统不像其他的linux系统，它可以通过命令来在线安装\n在 Ubuntu 系统安装 Redis 可以使用以下命令:\n```shell\n# sudo apt update\n# sudo apt install redis-server\n```\n然后可以启动\n```shell\n# redis-server\n```\n\n## 3、Redis的数据类型\n### 3.1、String类型\n\n字符串类型，是一种我们平常最常见到的一种数据类型之一\n我们使用set和get存取数据时，一般就是String的类型，如下\n```shell\nredis 127.0.0.1:6379> SET name \"陈益财\"\nOK\nredis 127.0.0.1:6379> GET name\n\"陈益财\"\n```\n其中，name就是key，\"陈益财\"就是所对应的值\n\n### 3.2、Hash类型\n\nRedis hash 是一个键值(key=>value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象\n例子如下：\n```shell\nredis 127.0.0.1:6379> HMSET names name1 \"chenyicai\" name1 \"George\"\n\"OK\"\nredis 127.0.0.1:6379> HGET names name1\n\"Hello\"\nredis 127.0.0.1:6379> HGET names name1\n\"World\"\n```\n\n### 3.3、List类型\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n例子如下：\n```shell\nredis 127.0.0.1:6379> lpush chen redis\n(integer) 1\nredis 127.0.0.1:6379> lpush chen mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush chen rabbitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange chen 0 10\n1) \"rabbitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n其中lpush表示存数据，而lrange表示取数据\n\n### 3.4、set类型\n\nRedis 的 Set 是 string 类型的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n例子如下：\n```shell\nredis 127.0.0.1:6379> sadd chen redis\n(integer) 1\nredis 127.0.0.1:6379> sadd chen mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers chen\n\n1) \"redis\"\n2) \"rabbitmq\"\n3) \"mongodb\"\n```\n其中sadd表示添加数据，smembers表示取出数据\n**注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略**\n\n### 3.5、zset类型\n\nRedis zset 和 set 一样也是string类型元素的集合,**且不允许重复的成员**。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n例子·如下：\n```shell\nredis 127.0.0.1:6379> zadd chen 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE chen 0 1000\n1) \"mongodb\"\n2) \"rabbitmq\"\n3) \"redis\"\n```\n其中zadd表示存数据，ZRANGEBYSCORE表示取数据\n且虽然存了两次相同的字符，但是也是只会保留一个\n\n## 4、在java中使用Redis\n\n使用Redis更多的情况是在java环境下面使用，所以需要掌握如何在java中对Redis进行操作\nRedis官方给我们提供了很方便的工具来进行Redis的操作：Jedis\n\n首先你需要下载驱动包 [下载 jedis.jar](https://mvnrepository.com/artifact/redis.clients/jedis)，确保下载最新驱动包。\n\n### 4.1、连接到Redis\n配置完成之后我们就可以连接到Redis了。\n例子如下：\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        // 如果 Redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth(\"123456\"); \n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \"+jedis.ping());\n    }\n}\n```\n如果是可以连接成功的，就会返回一个PONG表示回应\n\n### 4.2、String类型的存储\n\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisStringJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //设置 redis 字符串数据\n        jedis.set(\"name\", \"chenyicai\");\n        // 获取存储的数据并输出\n        System.out.println(\"redis 存储的字符串为: \"+ jedis.get(\"name\"));\n    }\n}\n```\n成功之后控制台就会显示name所对应的值：chenyicai\n\n### 4.3、List类型的存储\n\n```java\nimport java.util.List;\nimport redis.clients.jedis.Jedis;\n \npublic class RedisListJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //存储数据到列表中\n        jedis.lpush(\"site-list\", \"Baidu\");\n        jedis.lpush(\"site-list\", \"Google\");\n        jedis.lpush(\"site-list\", \"Taobao\");\n        // 获取存储的数据并输出\n        List<String> list = jedis.lrange(\"site-list\", 0 ,2);\n        for(int i=0; i<list.size(); i++) {\n            System.out.println(\"列表项为: \"+list.get(i));\n        }\n    }\n}\n```\n成功之后控制台就会返回信息\n```\n列表项为: Taobao\n列表项为: Google\n列表项为: Baidu\n```\n\n## 5、在SpringBoot中使用Redis\n\n一般在SpringBoot中使用Redis时我们会用来做Mysql数据库的二级缓存，这样子在我们获取数据的时候就不需要每次都到数据库进行查询，如果缓存中有数据就可以直接从缓存中拿，大大提高了查询的效率。\n\n1. 首先我们需要在maven中引入我们所需要的依赖\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n2. 然后在yml配置文件中，配置Redis的相关配置文件\n```java\nspring:\n  redis:\n    database: 0\n    host: localhost\n    port: 6379\n    password:\n    timeout: 500\n    pool:\n      max-active: 8\n      max-idle: 8\n      min-idle: 0\n      max-wait: -1\n```\n3. 我们还需要一个Config类来处理数据的序列化，否则双方可能会出现乱码的情况\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    private RedisConnectionFactory redisConnectionFactory;\n\n    public RedisConfig(RedisConnectionFactory redisConnectionFactory) {\n        this.redisConnectionFactory = redisConnectionFactory;\n    }\n\n    /**\n     * redisTemplate 序列化使用的jdkSerializeable, 存储二进制字节码, 所以自定义序列化类\n     *\n     * @return\n     */\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate() {\n        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        // 使用Jackson2JsonRedisSerialize 替换默认序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n\n        // 设置value的序列化规则和 key的序列化规则\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n\n}\n```\n\n4. 创建一个cache的实现类用于将查出来的数据添加到缓存中，并设置一些缓存的配置,里面包括了一些有关增删改的配置方法。\n```java\npublic class MybatisRedisCache implements Cache {\n    private Object key;\n    private String id;\n\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private RedisTemplate<Object, Object> redisTemplate;\n\n    private final String COMMON_CACHE_KEY = \"MYBATIS:\";\n\n    /**\n     * 默认缓存对象的缓存时间为 1 分钟\n     **/\n    private static final long EXPRIRE_TIME_IN_MINUT = 30;\n\n    public MybatisRedisCache(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"缓存对象id是不能为空的\");\n        }\n        this.id = id;\n    }\n\n    private RedisTemplate<Object, Object> getRedisTemplate() {\n        if (redisTemplate == null) {\n            redisTemplate = ApplicationContextHolder.getBean(\"redisTemplate\");\n        }\n        return redisTemplate;\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public void putObject(Object key, Object value) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            //使用redisTemplate得到值操作对象\n            ValueOperations operation = redisTemplate.opsForValue();\n            //使用值操作对象operation设置缓存对象\n            operation.set(getKey(key), value, EXPRIRE_TIME_IN_MINUT, TimeUnit.MINUTES);\n//            System.out.println(\"缓存对象保存成功\");\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象保存失败\" + t);\n        }\n    }\n\n    public Object getKey() {\n        return key;\n    }\n\n    public void setKey(Object key) {\n        this.key = key;\n    }\n\n    @Override\n    public Object getObject(Object key) {\n        try {\n            setKey(key);\n            RedisTemplate redisTemplate = getRedisTemplate();\n            ValueOperations operations = redisTemplate.opsForValue();\n            Object result = operations.get(getKey(key));\n//            System.out.println(\"获取缓存对象成功\");\n            return result;\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象获取失败\" + t);\n            return null;\n        }\n    }\n\n    @Override\n    public Object removeObject(Object key) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            redisTemplate.delete(getKey(key));\n//            System.out.println(\"删除缓存对象成功！\"+key);\n        } catch (Throwable t) {\n            System.err.println(\"删除缓存对象失败！\" + t);\n        }\n        return null;\n    }\n\n    @Override\n    public void clear() {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            Set<String> keys = redisTemplate.keys(getKeys());\n            redisTemplate.delete(keys);\n            System.out.println(\"出现新增、修改、删除操作，清空对应Mapper缓存======>\" + keys.size());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 按照一定规则标识key\n     */\n    private String getKey(Object key) {\n        String k=COMMON_CACHE_KEY + this.id + \":\" + DigestUtils.md5DigestAsHex(String.valueOf(key).getBytes());\n        return k;\n    }\n\n    /**\n     * 所有key\n     */\n    private String getKeys() {\n        return COMMON_CACHE_KEY + this.id + \":*\";\n    }\n\n    @Override\n    public int getSize() {\n        Long size = getRedisTemplate().boundHashOps(getId()).size();\n        return size == null ? 0 : size.intValue();\n    }\n\n    @Override\n    public ReadWriteLock getReadWriteLock() {\n        return readWriteLock;\n    }\n}\n```\n\n5. 然后我们在数据库查询的`mapper.xml`上添加上以下的配置，表示开启了数据库的二级缓存\n```xml\n<cache type=\"com.chen.mysqlredisdemo.cache.MybatisRedisCache\"></cache>\n```\n\n6. 然后在Controller文件中注入刚才写好的方法\n```java\n@Autowired\nStringRedisTemplate stringRedisTemplate;\n@Autowired\nRedisTemplate redisTemplate;\n```\n\n7. 最后在方法中判断Redis中是否有缓存，如果有就从Redis中取数据，否则就到数据库进行查找\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n    public Student selectStudentForOne(@PathVariable int sId){\n        String key = \"MYBATIS:\" + \"com.chen.mysqlredisdemo.StudentMapper:\"+sId;\n        ValueOperations<String, Student> operations = redisTemplate.opsForValue();\n        boolean hasKey = redisTemplate.hasKey(key);\n        if (hasKey) {\n            System.out.println(\"缓存输出\");\n            Student student = operations.get(key);\n            return student;\n        }else {\n            Student student = studentService.selectStudentForOne(sId);\n            operations.set(key, student);//把数据放入缓存\n            return student;\n        }\n    }\n```","tags":["java"]},{"title":"算法学习_设计有序流","url":"/2021/09/26/2021-09-26-算法学习_设计有序流/","content":"\n# 设计有序流\n\n## 题目\n[lettcode-1656题](https://leetcode-cn.com/problems/design-an-ordered-stream/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/09/3e508439a8f7dbe3.png)\n\n\n## 解题思路\n既然是一个有序流，那么我们就可以将其存储到一个数组中，然后通过数组下标对所在的值进行访问。所以我们首先创建一个长度为n+1的数组，将value的值存在其中。\n将下标指针的值设置为1，然后在执行时进行循环加1\n\n接下来就是循环读取的过程：\n当我们在数组中插入一个数据的时候，就判断一个数组下标是否小于n，以及当前下标处的value值是否不为空，如果不为空我们就进入循环，将其存到一个新的集合中，并将其输出。\n如果为空的时候就不执行方法，继续往数组中添加value\n直到下标不小于n为止\n\n## 具体代码\n```java\nclass OrderedStream {\n\n    private String[] arr;\n    private int n;\n    private int ptr;\n\n    // 构造函数\n    public OrderedStream(int n) {\n    \t//因为数组的下标n从0开始，所以数组的长度为n+1\n        this.arr=new String[n+1];\n        this.n=n;\n        this.ptr=1;\n    }\n\n    public List<String> insert(int idKey, String value) {\n        //将value存到数组中\n        arr[idKey]=value;\n\n        //创建一个新的数组\n        List<String> res=new ArrayList<>();\n        //循环读取arr数组，将其中的值写到res数组中\n        //当arr[]为null时，不进入循环\n        while (ptr<=n&&arr[ptr]!=null){\n            res.add(arr[ptr]);\n            ptr++;\n        }\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"算法学习_设计停车系统","url":"/2021/09/26/2021-09-26-算法学习_设计停车系统/","content":"\n# 设计停车系统\n\n## 题目\n[lettcode-1603题](https://leetcode-cn.com/problems/design-parking-system/) \n难度：简单![]( https://s3.bmp.ovh/imgs/2021/09/a5c6d4d87d542ba7.png )\n\n\n## 解题思路\n每种车都有每种车所对应的一个车位，而且不能停到其他车的车位上面去，所以说我们需要三个变量将每种车的车位数量存起来。\n然后在有新车进来时，判断车辆的类型，然后查找相应的停车位，如果有车位就返回一个true，相当于停车成功，然后该类型的车位减去一个，如果车位为0，则不允许停车，返回false\n\n## 具体代码\n```java\nclass ParkingSystem {\n\n    int big;\n    int medium;\n    int small;\n    // 构造函数\n    public ParkingSystem(int big, int medium, int small) {\n        this.big=big;\n        this.medium=medium;\n        this.small=small;\n    }\n\n    public boolean addCar(int carType) {\n        if (carType==1){\n            if (this.big>0){\n                this.big--;\n                return true;\n            }\n        }else if (carType==2){\n            if (this.medium>0){\n                this.medium--;\n                return true;\n            }\n        }else if (carType==3){\n            if (this.small>0){\n                this.small--;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```","tags":["算法"]},{"title":"java栈","url":"/2021/09/25/2021-09-25-java栈/","content":"\n# java栈\n\n栈是一个先进后出的数据结构，想要自己实现一个栈，要求这个栈具有push()，pop()——返回栈顶并出栈，peek()——返回栈顶不出栈，isEmpty()等方法。\n\n## 1.1、手动实现一个栈的多种方式\n1. 采用数组来实现栈\n```java\nimport java.util.Arrays;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/25 19:59\n * @since 1.0\n */\nclass Stack1<T> {\n\n    // 实现栈的数组\n    private Object[] stack;\n    // 数组大小\n    private int size;\n\n    Stack1(){\n        stack=new Object[10];\n    }\n\n    // 判断数组是否为空\n    public boolean isEmpty(){\n        if (size==0){\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    // 返回栈顶元素\n     public T peek(){\n        T t=null;\n        if (size>0){\n            t= (T) stack[size-1];\n        }\n        return t;\n     }\n\n     // 返回栈顶并出栈\n     public T pop(){\n        T t=peek();\n        if(size>0){\n            stack[size-1]=null;\n            size--;\n        }\n        return t;\n     }\n\n     // 扩容\n    public void expandCapacity(int size){\n        int len=stack.length;\n        if (size>len){\n            size=size*3/2+1;\n            stack= Arrays.copyOf(stack,size);\n        }\n    }\n\n    public void push(T t){\n        expandCapacity(size+1);\n        stack[size]=t;\n        size++;\n    }\n}\n\npublic class ArrayStack {\n    public static void main(String[] args) {\n        Stack1<String> stringStack1=new Stack1<>();\n        System.out.println(stringStack1.peek());\n        System.out.println(stringStack1.isEmpty());\n        stringStack1.push(\"java\");\n        stringStack1.push(\"chenyc2021@qq.com\");\n        stringStack1.push(\"gogogo\");\n        System.out.println(stringStack1.pop());\n        System.out.println(stringStack1.isEmpty());\n        System.out.println(stringStack1.peek());\n    }\n}\n```\n\n2. 采用链表来实现\n```java\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 0:49\n * @since 1.0\n */\nclass Stack2<T> {\n    // 定义一个链表\n    class Node<T> {\n        private T t;\n        private Node next;\n    }\n\n    private Node<T> head;\n\n    // 构造函数\n    Stack2() {\n        head = null;\n    }\n\n    // 入栈\n    public void push(T t) {\n        if (t == null) {\n            throw new NullPointerException(\"参数不能为空\");\n        }\n        if (head == null) {\n            head = new Node<T>();\n            head.t = t;\n            head.next = null;\n        } else {\n            Node<T> temp = head;\n            head = new Node<T>();\n            head.t = t;\n            head.next = temp;\n        }\n    }\n\n    // 出栈\n    public T pop() {\n        T t = head.t;\n        head = head.next;\n        return t;\n    }\n\n    // 栈顶元素\n    public T peek() {\n        T t = head.t;\n        return t;\n    }\n\n    //判断栈是否为空\n    public boolean isEmpty() {\n        if (head == null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\npublic class LinkStack {\n    public static void main(String[] args) {\n        Stack2 stack = new Stack2();\n        System.out.println(stack.isEmpty());\n        stack.push(\"Java\");\n        stack.push(\"is\");\n        stack.push(\"beautiful\");\n        System.out.println(stack.peek());\n        System.out.println(stack.peek());\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n    }\n}\n```\n\n3. 采用LinkedList实现栈\n```java\n import java.util.LinkedList;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 9:39\n * @since 1.0\n */\n\nclass Stack3<T>{\n    // 构建一个linkedLIst集合\n    private LinkedList<T> ll=new LinkedList<>();\n\n    // 判断栈是否为空\n    public boolean isEmpty(){\n        return ll.isEmpty();\n    }\n\n    // 入栈\n    public void push(T t){\n        ll.addFirst(t);\n    }\n\n    //出栈\n    public T pop(){\n        return ll.removeFirst();\n    }\n\n    // 栈顶元素\n    public T peek(){\n        T t=null;\n        if (!ll.isEmpty()){\n            t=ll.getFirst();\n        }\n        return t;\n    }\n\n}\npublic class LinkedStack {\n    public static void main(String[] args) {\n        Stack3<String> stringStack3=new Stack3<>();\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n        stringStack3.push(\"java\");\n        stringStack3.push(\"is\");\n        stringStack3.push(\"beautiful\");\n        System.out.println(stringStack3.peek());\n        System.out.println(stringStack3.pop());\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n    }\n}\n```\n\n## 1.2、栈的应用\n\n在java中，栈是一种很重要的数据结构，如以下的很多场景都应用到了栈\n- 符号匹配\n- 中缀表达式变为后缀表达式\n- 计算后缀表达式\n- 实现函数的嵌套调用\n- HTML和XML中的标签匹配\n- 网页浏览器中以访问界面的历史记录\n\n例如：\n\n1. 符号匹配\n在编写程序的过程中，我们经常会遇到诸如圆括号“()”与花括号“{}”，这些符号都必须是左右匹配的，这就是我们所说的符合匹配类型，当然符合不仅需要个数相等，而且需要先左后右的依次出现，否则就不符合匹配规则，如“)(”，明显是错误的匹配，而“()”才是正确的匹配。有时候符合如括号还会嵌套出现，如“9-(5+(5+1))”,而嵌套的匹配原则是一个右括号与其前面最近的一个括号匹配，事实上编译器帮我检查语法错误是也是执行一样的匹配原理，而这一系列操作都需要借助栈来完成，接下来我们使用栈来实现括号”()”是否匹配的检测。\n判断原则如下（str=”((5-3)*8-2)”）：\n\na.设置str是一个表达式字符串，从左到右依次对字符串str中的每个字符char进行语法检测，如果char是，左括号则入栈，如果char是右括号则出栈(有一对匹配就可以去匹配一个左括号，因此可以出栈)，若此时出栈的字符char为左括号，则说明这一对括号匹配正常，如果此时栈为空或者出栈字符不为左括号，则表示缺少与char匹配的左括号，即目前不完整。\n\nb.重复执行a操作，直到str检测结束，如果此时栈为空，则全部括号匹配，如果栈中还有左括号，是说明缺少右括号。\n\n实现代码如下：\n```java\npublic class CheckExpression {\n\n  public static String isValid(String expstr)\n  {\n      //创建栈\n      LinkedStack<String> stack = new LinkedStack<>();\n\n      int i=0;\n      while(i<expstr.length())\n      {\n          char ch=expstr.charAt(i);\n          i++;\n          switch(ch)\n          {\n              case '(': stack.push(ch+\"\");//左括号直接入栈\n                  break;\n              case ')': if (stack.isEmpty() || !stack.pop().equals(\"(\")) //遇见右括号左括号直接出栈\n                  return \"(\";\n          }\n      }\n      //最后检测是否为空,为空则检测通过\n      if(stack.isEmpty())\n          return \"check pass!\";\n      else\n          return \"check exception!\";\n  }\n\n  public static void main(String args[])\n  {\n      String expstr=\"((5-3)*8-2)\";\n      System.out.println(expstr+\"  \"+isValid(expstr));\n  }\n}\n```\n","tags":["数据结构"]},{"title":"准备阅读小米十年纪念《一往无前》","url":"/2021/08/27/2021-08-27-准备阅读小米十年纪念《一往无前》 - 副本 - 副本/","content":"\n# 准备阅读小米十年纪念《一往无前》\n\n作为一个不太资深的老米粉，自从小米发布新书《一往无前》以来一直想阅读一下，感受一下大厂发展的心路历程，但是一直都没有提上日程，而今天决定正式开始阅读此书，但是可能耗时会较长，现在这里做一个标记，阅读完毕务必完成一篇读后感。\n\n---\n\n2021.09.21 因为一直都在面试，所以阅读计划得往后推迟一点了。"},{"title":"对SpringIOC的理解","url":"/2021/08/26/2021-08-26-对SpringIOC的理解/","content":"\n# 对SpringIOC的理解\n\n## 1、何为IOC\n​\tIOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好IOC呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来分析一下\n\n### 1.1 谁控制谁，控制什么\n\n​\t传统Java程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）\n\n### 1.2 为何是反转，哪些方面反转了\n\n​\t有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n### 1.3 图例说明\n\n传统程序设计下图，都是主动去创建相关对象然后再组合起来：\t\n\n![]( https://s3.bmp.ovh/imgs/2021/08/38929d2b7cf05cd7.jpg )\n\n当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示：\n\n![]( https://s3.bmp.ovh/imgs/2021/08/c7705f5db3bbd643.png )\n\n## 2、IOC能做什么\n\n​\tIOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n　　其实IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC/DI思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。\n　　IOC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n## 3、IOC和DI\n\n​\tDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来分析一下：\n\n- 谁依赖于谁：当然是应用程序依赖于IOC容器；\n- 为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；\n- 谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；\n- 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\tIOC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。\n\t\n## 4、对IOC和DI的理解\n\n### 4.1、IoC(控制反转)\n　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。\n　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\n\n### 4.2、DI(依赖注入)\n　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。\n　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。\n　　\n　　\n## 5、原文地址\nhttps://www.iteye.com/blog/jinnianshilongnian-1413846","tags":["学习总结","java"]},{"title":"最近一段时间的学习总结","url":"/2021/08/20/2021-08-20-最近一段时间的学习总结/","content":"\n# 最近一段时间的学习总结\n\n## 项目部分\n\n1. 完成了学生宿舍系统的答辩\n2. 成功将学生宿舍为系统部署到了服务器上\n3. 准备进行学生宿舍系统的小程序的设计，但是实在是没有时间\n4. 完成了国医堂小程序的开发(React+Taro+Taro UI)\n5. 完成了小程序API的开发(Vue+SpringBoot+MyBatis-Plus)\n6. 国医堂小程序后台开发完毕(VUE+SpringBoot+MyBatis-Plus+Element-UI)\n7. 准备进行中医药门户或者桂林医学院报修系统开发环境的搭建\n\n## 框架部分\n\n1. 学习了SpringSecurity，并完成了Session以及Token两种情况下的应用Demo\n2. MyBatis-Plus逆向工程(代码生成器)\n3. Shiro的基本使用\n4. 入门Activiti(工作流)\n5. 准备学些RabbitMQ、\n6. MyBatis-Plus逆向工程3.5.0版本之之前是setting模式，之后是building模式\n7. 入门了React以及Vue两个有名的前端框架的使用\n8. ElementUI，LayUI，Bootstrap等UI的使用\n\n## 基础知识\n\n1. 复习了下AOP思想，并准备使用到日志中\n2. HashMap和HashTable的区别\n\n## 服务器\n\n1. 手动将web项目部署到阿里云服务器上\n2. 复习了Linux的指令\n\n## 备注\n\n看到同学面试京东所回答的问题，以及其他同学所总结的知识点，感觉自己和别人相比有很大的进步空间","tags":["学习总结"]},{"title":"shiro安全框架","url":"/2021/08/01/2021-08-01-shiro安全框架/","content":"\n# shiro安全框架\n\n## 1、简述\nshiro是apache公司所出品的开源安全框架\n其可以用于：\n1. 处理身份认证\n2. 授权\n3. 企业会话管理和加密\n\n相对于Spring security来说更加简单，使用也更加灵活\n\n在使用shiro的时候可以不依赖于任何容器，既可以在javaSE下使用，同样可以在JavaEE下使用\n\n## 2、架构\n\n1. 使用用户的登录信息构建令牌\n```java\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n```\ntoken可以理解为一个用户令牌，等于的过程可以理解为shiro检验用户令牌是否具有合法的身份以及相关的权限\n2. 执行登录\n\n```java\nSecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager\nSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象\nsubject.login(token); // 执行登录\n```\nshiro中最核心的部分就是securityManger，它主要负责安全认证和授权。当我们在使用这个框架的时候，shiro已经将一切的操作封装成一个盒子了，我们在使用的时候可以把它当成一个黑盒来进行使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject，翻译过来就是项目的意思，他是一个需要通过shiro保护的一个抽象概念。\n通过1令牌和项目的登录关系，保证了我们的安全。\n\n3. 判断用户\n\n这一步中的内容shiro无法帮我们进行实现，我们只有通过最原始的手段来实现登录用户的判断，就是查询数据库。\n\n例如：\n```java\nif (!token.getUsername().equals(name)) {\n  //shiro底层会抛出一个异常\n    return null;\n}\n//判断密码\nreturn new SimpleAuthenticationInfo(\"\", password, \"\");\n```\n第一个if语句中首先会判断数据库中查到的name于输入的用户名2是否一致，如果不一致，则会抛出一个异常\n然后SimpleAuthenticationInfo中可以用于判断密码的正确性，同样是从数据库查出来的数据做对比。\n\n## 3、实现Realm\n\n1. 创建一个Realm\n\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息，但是Realm并不止局限于数据的存取，其中还有很多认证授权校验相关的代码  \n我们可以自定义一个MyRealm，用于我们的项目之中，但是前提是这个类必须继承于AuthorizingRealm父类，然后实现两个方法  \nAuthorizationInfo doGetAuthorizationInfo以及AuthenticationInfo doGetAuthenticationInfo  \nAuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。\n\n我们也可以简单看作：  \n**doGetAuthenticationInfo()** 方法：用来验证当前登录的用户，获取认证信息。  \n**doGetAuthorizationInfo()** 方法：为当前登录成功的用户授予权限和分配角色。\n\n2. 从数据库查询数据\n\n在数据库中查询登陆人信息的时候，仅仅需要查询用户的id，这时还未涉及到密码，也就是说即使用户输入的密码不正确，照样可以查询出该用户。\n然后，将该用户的相关信息封装到authcInfo中并返回给Shiro接下来就该Shiro上场了，将封装的用户信息与用户的输入信息（用户名、密码）进行对比、校验（注意，这里对密码也要进行校验）。校验通过则允许用户登录，否则跳转到指定页面。\n\n## 4、Shiro配置\n\n1. 在ShiroConfig中配置Realm\n\n```java\n@Bean(name=\"MyRealm\")\n  public MyRealm myRealm() {\n    return new MyRealm();\n  }\n```\n2. 配置安全管理器SecurityManager\n\n```java\n@Bean(name=\"securityManager\")\n  public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"MyRealm\") MyRealm myRealm) {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    //关联Realm\n    securityManager.setRealm(myRealm);\n    return securityManager;\n  }\n```\n当我们配置安全管理器的时候，需要将前面的Realm添加进来，这样子才可以访问到Realm\n\n3. 配置Shiro过滤器\n\nshiro中自带好了配置的过滤器，我们在使用之前需要将其进行导入\n\n```java\nShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n//设置安全管理器\nshiroFilterFactoryBean.setSecurityManager(securityManager);\n//添加Shiro内置过滤器\n/*\nShiro内置过滤器，可以实现权限相关的拦截器\n常用的有：\nanon：无需认证就能访问\nauthc：必须认证才能访问\nuser：必须拥有 “记住我” 功能才能使用\nperms：拥有对某个资源的权限才能访问\nrole： 拥有对某个角色权限才能访问\n*/\nLinkedHashMap<String, String> filterMap = new LinkedHashMap<String,String>();\n//这里我们要将不进行拦截的放在前面\nfilterMap.put(\"/login\", \"anon\");\nfilterMap.put(\"/*\", \"authc\");\n\n//最后设置验证失败的时候所跳转的界面\nshiroFilterFactoryBean.setLoginUrl(\"/toLogin\");\n```\n此时当我们未登陆的时候，点击被拦截的模块，就会跳到我们所指定的网页，而没有拦截的网页则可以正常显示。","tags":["shiro"]},{"title":"过滤器(Filter)在Web中的应用","url":"/2021/07/01/2021-07-01-过滤器(Filter)在Web中的应用/","content":"\n# Java Web之过滤器(Filter)\n\n## 过滤器(Filter)\n\n过滤器，从字面意思上理解，就是用于过滤作用的工具。\n在Java web中，过滤器的作用是对Web资源进行拦截，经过处理之后，再交给下一步进行处理；而下一步可以是一个新的过滤器，也可以是一个service\n\n"},{"title":"算法学习_罗马数字转整数","url":"/2021/06/28/2021-06-28-算法学习_罗马数字转整数/","content":"\n# 罗马数字转整数\n\n## 题目\n[lettcode-13题](https://leetcode-cn.com/problems/roman-to-integer/) \n难度：简单\n![]( https://i.bmp.ovh/imgs/2021/06/ed551dd42d8355cf.png )\n\n## 解题思路\n对于每个罗马符号所对应的数值，我们可以将其用一个HashMap存起来，将其字符作为key，以及数值为相应的value\n\n在方法中对输入的字符串的所有字符进行遍历，get到所对应的值，并拿到它的后一位数的值，如果当前符号的值大于后一位符号的值，则进行＋运算，否则-运算。\n\n## 具体代码\n```java\n//leetcode项目\nclass Solution {\n    Map<Character,Integer> map=new HashMap<Character,Integer>();\n    public int romanToInt(String s) {\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int ans = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int value = map.get(s.charAt(i));\n            if (i < n - 1 && value < map.get(s.charAt(i + 1))) {\n                ans -= value;\n            } else {\n                ans += value;\n            }\n        }\n        return ans;\n    }\n}\n```","tags":["算法","HashMap"]},{"title":"记录博客主页的搭建(二)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(二)/","content":"\n# 记录博客主页的搭建(二)\n\n## 完成上篇文章的所有步骤\n主题是个性化个人博客的很重要的一个模块，当然hexo默认也有一个主题，但是我们可以到[hexo的主题商城](https://hexo.io/themes/)中下载更多我们喜欢的主题。\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/e2ca448dcc957f2e.jpg )\n\n## 选择想要的主题\n\n点击大图可以进行预览，点击名称就可以进入主题的GitHub仓库，就可以进行clone了\n\n然后在本地clone主题的仓库，放到hexo目录的themes文件夹中，再去修改_config.yml文件，就可以应用这个主题了\n\n将theme后面的名称改为刚才clone的文件夹名称，就可以应用主题了\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-aircloud\n```\n\n## 创建标签以及存档\n\n默认的主题是不带有标签和介绍的，这时候需要在博客根目录的source文件夹下建立tags文件夹和about文件夹。\n\n*注：建议不要直接新建文件，而是采用 hexo 的 hexo new page tags 和 hexo new page about 的方式新建文件，这样可以被 hexo 索引到。*\n\n创建好之后在两个文件夹的index.md中分别输入以下内容\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n再次打开主页就会看到生成了两个新的列表\n\n## 更换头像以及网站logo\n\n在博客根目录的 source 文件夹下建立 img 文件夹\n*采用 hexo 的 hexo new page img *\n\n然后并将头像文件命名为avatar.jpg，logo文件命名为favicon.ico\n\n然后修改_config.yml文件，增加以下内容\n```\nsidebar-avatar: img/avatar.jpg\n```\n就可以了\n\n## 网站标题\n在 _config.yml 文件中，增加以下内容\n```\nSEOTitle: George'blog\n```\n冒号后面修改成你想要的名字就可以了\n\n## 签名\n比如最顶端的签名，我们同样可以自定义\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/89d7894724475826.jpg )\n\n只要在_config.yml文件，修改以下内容即可\n```\nsubtitle: 你想要的签名\n```\n\n## 搜索功能\n\n搜索功能同样是不自带的，我们在安装搜索功能之前，首先要安装一个插件\n在git中输入以下命令进行安装\n```\nnpm i hexo-generator-search --save\n```\n\n然后在_config.yml文件中增加以下内容即可\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n## 社交网络\n底部的社交网络我们可以自行修改，但是只能在官方限制的范围内进行修改\n编辑根目录的 _config.yml 文件，增加：\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     5676314204\nzhihu_username:     swaggy-chen\ngithub_username:    chenyicai0819\ntwitter_username:   George chan\n```\n*还有一些其他的社交网络可以参考官方文档*\n\n## 赞赏功能\n\n我们同样可以在我们的博客中添加一个赞赏功能\n只要在img文件夹中增加收款码图片，并命名为donate.jpg\n然后在 _config.yml 文件中增加以下内容，即可在在每篇文章下面增加一个赞赏功能\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n## 修改用户名\n只需修改 _config.yml 文件，中以下内容，即可修改用户名\n```\nauthor: 你的用户名\n```\n\n## 完成主题更换\n\n至此，基本的冤死就已经设置完毕了，基本上只要修改 _config.yml 文件，就可以控制网站中所有的元素了，而官方的帮助文档也写的很清楚如何对各个模块进行设置\n\n我的这篇文章只是针对我的设置进行了一个记录，所以需要更多资料的可以去参考官方的文档，基本上是写的非常明白了\n\n## 部署到GitHub\n\n跟之前一样，完成修改之后要部署到github，只需要以下几行命令\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n\n部署完成之后稍等一会，就可以看到修改之后的内容了\n\n## 相关链接\n\n[官方文档](https://hexo.io/zh-cn/docs/)\n\n[主题商城](https://hexo.io/themes/)\n\n","tags":["Hexo","记录"]},{"title":"记录博客主页的搭建(一)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(一)/","content":"\n# 记录博客主页的搭建(一)\n\n## 1.心血来潮\n有一个自己的网站，是我心中一直存在的一个想法，因最近学业压力不是很大，碰巧看到阿里云的域名首年特惠只要一元，就顺便买了一个域名，准备着手搭建个人网站，在此之前，我对博客网站几乎是没有过了解，所以在查阅了一些资料之后，以Hexo+Github Page的方式进行我的网站的搭建，以下就是具体的过程。\n\n## 2.搭建过程\n\n**相关的搭建过程网上随便一找就有很多，我这里只是对我建站的过程进行记录，具有一定参考价值。**\n\n### 2.1 下载node.js以及git并安装\n在使用[Hexo](https://hexo.io/zh-cn/)框架进行搭建网站之前，首先要下载安装[node.js](https://nodejs.org/zh-cn/)和[git](https://git-scm.com/)，以便于安装Hexo以及代码的管理。\n\n*具体的安装注意事项*\n1. Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本\n2. 使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）\n3. 对于中国大陆地区用户，可以前往官网或者淘宝Git for Windows镜像下载 git 安装包（仅针对Windows）\n4. 安装完毕以上两个软件之后就可以进行Hexo的安装了\n### 2.2 安装Hexo\n在想要安装Hexo的位置右键打开**Git Bash Here**通过命令行来进行安装，输入以下命令\n```\nnpm install -g hexo-cli\n```\n点击回车即可进行安装，然后安装完成之后进行一下初始化\n```\nhexo init\nnpm install\n```\n分别输入以上两句并回车，就会生成初始的菜单，大概的目录是这样子的\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n下面是各个目录的具体功能：\n\n**config.yml**\n网站的配置信息，可以在此配置大部分的参数。后面发布到github上面时，有用到这个文件；\n**package.json**\n应用程序的信息\n**source**\n是网站中一下资源的文件夹，博客内容也都放在这里\n**themes**\n网站主题的放置的位置\n\n*其他更具体的介绍可以参考[官方文档](https://hexo.io/zh-cn/docs/)*\n\n### 2.3 预览Hexo博客\n此时就可以预览自己搭建的博客了，但是所有东西都是初始的，输入以下的命令即可\n```\nnpm install hexo-server --save\nhexo server\n```\n*以上命令同样是在Git Bash Here中输入*\n然后在浏览器网址栏输入**localhost:4000**\n如果以上项目能启动就说明成功了，接下来将项目搭建到GitHub上面\n\n### 2.4 将项目部署到GitHub\n1. 在GitHub中新建一个仓库，然后命名为**用户名.github.io**，只有这样子GitHub才会将其设置为用户的博客![]( https://ftp.bmp.ovh/imgs/2021/06/bd90f51e057bd717.jpg )\n\n*因为我已经有一个库了，所以显示错误*\n\n2. **将本地搭建好的hexo发布到github上**\n\n首先输入以下代码安装一个插件\n```\nnpm install hexo-deployer-git --save\n```\n\n修改网站配置文件_config.yml,添加deploy信息\n\n```\ndeploy:\n  type: git \n  repo: git@github.com:用户名/用户名.github.io.git \n  branch: master(也就是想要上传的分支)\n```\n\n3. **生成SSH key**\n\n在git中输入以下命令\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n然后会提示输入passphrase（本步骤可以跳过），相当于设置一个密码，之后跟github进行操作时都会要求输入密码，避免误操作\n然后将新生成的key添加到ssh-agent中\n```\nssh-add ~/.ssh/id_rsa\n```\n就可以在上面的路径下找到ssh的文件了![]( https://ftp.bmp.ovh/imgs/2021/06/1536b7e2cd20e1b1.jpg )\n\n4. **将ssh添加到GitHub中**\n\n打开id_rsa.pub文件将一整串公钥拷贝下来\n打开GitHub的个人设置界面，按照以下图片的步骤进行添加ssh\n![]( https://ftp.bmp.ovh/imgs/2021/06/f27d25e0e14f55ce.jpg )\n\ntitle随意，key填id_rsa.pub文件中内容，然后保存即可。\n至此，就成功将ssh添加到github中了\n\n5. **测试是否连接成功**\n\n输入以下命令\n```\nssh -T git@github.com\n```\n如果出现以下文字就说明连接成功了\n```\nHi wispyoureyes! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n6. 上传静态文件\n\n成功与GitHub建立连接之后，就可以生成静态文件上传到github中了\n\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n然后再网址栏输入GitHub仓库的名称就可以访问了\n\n## 3.绑定域名\n\n1. 首先到阿里云或者其他的云服务商购买一个域名\n2. 然后进行域名解析\n3. 登陆阿里云控制台，选择域名选项，添加两条CNAME解析\n4. 然后在GitHub的仓库设置中，下滑找到Github Pages ，点击进去，在Custom domain里填入你的域名，然后点击Save，稍等一会就好了。\n5. 然后就可以通过你的域名来进入博客了\n\n*关于备案，如果要部署到国内的服务器上面需要进行备案，从哪里买的域名就从哪里备案GitHub属于国外的服务器，是不用进行备案的*\n\n\n\n## 4.相关链接\n\n[生成ssh](https://www.jianshu.com/p/31cbbbc5f9fa/)\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\n[阿里云](https://www.aliyun.com/?spm=5176.12901015.0.i12901015.ba0e525c2qLtLM)\n\n[淘宝git for windows 镜像](https://npm.taobao.org/mirrors/git-for-windows/)\n\n[淘宝node.js镜像](https://npm.taobao.org/mirrors/node)","tags":["Hexo","记录"]},{"title":"基于Swing的简易点餐系统","url":"/2021/06/21/2021-06-21-基于Swing的简易点餐系统/","content":"\n# 基于Swing的建议点餐系统\n\n## 1. 应用技术\n```\nSwing、JDBC、Oracle数据库、Java基础\n```\n## 2.项目功能\n```\n工作人员：菜品的增删改查、工作人员点餐、为顾客进行排号叫号、利润查询、结账。\n顾客：顾客点餐、查看积分、查看菜单、自助结账。\n```\n## 3.项目历程\n### 3.1 项目准备\n\n总所周知，Swing对于Java来说已经是一个不再使用的技术了，相对于微软的C#语言，Java的优势更在于Web端的应用，但是应教学的要求，主要是为了练习JDBC以及PL/SQL的使用，我们使用了Swing技术配合数据库使用，制作了一个简易的点餐系统，旨在熟悉一个项目的制作流程，从项目需求分析到项目开发到最后的维护发布，我作为小组长，带领了团队一共7位队员在老师的指导之下，完成了项目的开发。\n\n### 3.2 项目开发背景\n\n据了解，学校周围部分餐馆仍处于人工点餐、手工记账的阶段，这样子不仅容易在点餐时出现错记误记的情况，在最后记录时大量的数据也会十分繁琐，计算机软件统一的处理方式可以将以上的过程全都自动化一站式地完成，大大提高了效率；除此之外，使用计算机系统还大大减少了成本。\n发展点餐系统，是一种必然趋势，可以说点餐系统的出现，只是用现在较为成熟的计算机技术去改造传统行业的一个小小例子。这样的系统，将会不断地出现，而且会有力地推动传统行业的不断发展。\n\n### 3.3 项目开发\n\n在开始项目的开发之后，由于队员基础的参差不齐，所以在任务分配时对队员的能力分配了不同的任务，并针对队员能力进行了不同知识点的针对，由于是首次进行团队项目开发，并没有使用到GitHub进行协作开发，所以在最后整合代码时，碰到了较大的问题，jdk版本不统一，代码不能兼容等等问题，最后整合的代码也还有着大量的冗余，开发过程总体来说比较顺利，但是还是有很大的改进，在开发前进行数据库设计时，虽然说没有太多的表，但是对于项目小白的我们还是花费了一点时间。\n\n\n### 3.4 项目源码\n```\nhttps://github.com/chenyicai0819/2020_java_study/tree/main/OrderSystemToSix\n```","tags":["Swing","点餐系统"]},{"title":"我的第一条博客","url":"/2021/06/21/2021-06-21-我的第一条博客/","content":"\n# 这是我的第一条博客\n\n**1.初次接触**\n\n今天是2021年6月21日。我搭建了我的第一个个人博客网站，并发布了我的第一条个人博客，今后我会在上面发布一些自己的学习经历，个人感想等内容。\n"}]