[{"title":"二分查找","url":"/2022/02/02/2022-02-02-二分查找/","content":"\n# 二分查找\n## 1、","tags":["算法"],"categories":["算法","二分查找"]},{"title":"位运算","url":"/2022/02/01/2022-02-01-位运算/","content":"\n# 1、位运算\n\n程序中的所有数在计算机内存中都是以二进制的形式储存的。\n位运算就是直接对整数在内存中的二进制位进行操作。\n比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。\n举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果.\n&运算时，当且仅当两者都为 1 时，结果才为 1.\n使用二进制来表示就是如下：\n6  ：0 1 1 0\n11：1 0 1 1\n——————\n2  ：0 0 1 0\n\n相比于使用常规的运算符，在计算机语言中，合理使用位运算符能很好地帮助我们提高效率。\n\n## 2.1、位运算符\n\n|符号|描述|运算规则|\n| ---- | ---- | ---- |\n|&|与|两个位都为1时，结果才为1|\n|\\||或|两个位都为0时，结果才为0|\n|^|异或|两个位相同为0，相异为1|\n|~|非|0变1，1变0|\n|<<|左移|各二进位全部左移若干位，高位丢弃，低位补0|\n|>>|右移|各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）|\n\n## 2.2、实例\n### 2.2.1、与\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n2 ：0 0 1 0\n```\n当且仅当两者都为 1 的时候，结果才为 1，所以在这里只有第三位两者都为 1 ，所以结果就是 0010。\n\n### 2.2.2、或\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n15：1 1 1 1\n```\n当且仅当两者都为 0 的时候，结果才为 0，所以在这里所有的结果都为 1  ，所以结果就是 1111。\n\n### 2.2.3、非\n```\n6 ：0 1 1 0\n————————————\n9 ：1 0 0 1\n```\n非的规则是将 1 变成 0，0 变成 1，所以0110非操作之后就是1001，为9.\n\n### 2.2.4、异或\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n13：1 1 0 1\n```\n异或的运算规则：0^0=0  0^1=1  1^0=1  1^1=0 相同为 0，相异为 1.\n\n### 2.2.5、左移和右移\n**左移：**\n```\n6 ：0 1 1 0\n————————————\n12：1 1 0 0\n```\n左移就是将所有的 1 都左移一位，然后空位上补0，所以 6 左移一位的结果就是 12.相当于 6 乘 2 等于 12.\n**右移：**\n```\n6 ：0 1 1 0\n————————————\n3 ：0 0 1 1\n```\n右移就是将所有的 1 都右移一位，然后空位上补0，所以 6 右移一位的结果就是 3.相当于 6 除 2 等于 3.\n\n从上面可以看出，如果我们在平时需要用到乘法或者除法，就可以使用左移和右移来进行替代，可以更好地提高效率。\n\n## 2.3、使用技巧\n### 2.3.1、实现乘除法\n数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2\n```\nint a = 2;\na >> 1; ---> 1\na << 1; ---> 4\n```\n\n### 2.3.2、交换两个数\n使用位运算交换两个数的时候，可以不使用第三个变量，虽然这个操作普通的运算也能做到，但是效率远不如位运算。\n```java\n//普通操作\nvoid swap(int &a, int &b) {\n  a = a + b;\n  b = a - b;\n  a = a - b;\n}\n\n//位与操作\nvoid swap(int &a, int &b) {\n  a ^= b;\n  b ^= a;\n  a ^= b;\n}\n```\n\n### 2.3.3、判断奇偶数\n只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。\n```java\nif(0 == (a & 1)) {\n //偶数\n}\n```\n\n### 2.3.4、交换符号\n交换符号将正数变成负数，负数变成正数\n```java\nint reversal(int a) {\n  return ~a + 1;\n}\n```\n\n### 2.3.5、求绝对值\n整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作\n```java\nint abs(int a) {\n  int i = a >> 31;\n  return i == 0 ? a : (~a + 1);\n}\n```\n上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)\n```java\nint abs2(int a) {\n  int i = a >> 31;\n  return ((a^i) - i);\n}\n```\n\n除此之外，还有很多用途。\n\n## 2.4、写法\n\n和普通的运算符一样，位运算符也可以组成复合运算符的形式。\n如下：\n```\n&=        例：a&=b    相当于     a=a&b\n|=        例：a|=b    相当于     a=a|b\n>>=      例：a>>=b   相当于     a=a>>b\n<<=      例：a<<=b     相当于      a=a<<b\n^=        例：a^=b    相当于   a= a^b\n```\n\n## 2.5、算法题应用\n### 2.5.1、只出现一次的数字\n**问题描述**\n给定一个非空整数数组，除了某个元素只出现一次以外，**其余每个元素均出现两次**。找出那个只出现了一次的元素。\n说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**分析**\n\n1. 0和任意数字进行异或操作结果为数字本身.\n2. 两个相同的数字进行异或的结果为0.\n\n**解答**\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int value=0;\n        for(int i=0;i<nums.length;i++)\n        {\n            value^=nums[i];\n        }\n        return value;\n    }\n}\n```\n\n### 2.5.2、只出现一次的数字\n**问题描述**\n给定一个非空整数数组，除了某个元素只出现一次以外，**其余每个元素均出现了三次**。找出那个只出现了一次的元素。\n说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**分析**\n这题和上一题的思路略有不同，这题其他数字出现了3次，那么我们如果直接使用位运算异或操作的话无法直接找到结果，就需要巧妙的运用二进制的其他特性：判断整除求余操作。即判断所有数字二进制1的总个数和0的总个数一定有一个不是三的整数倍，如果0不是三的整数倍那么就说明结果的该位二进制数字为0，同理否则为1.\n在具体的操作实现上，问题中给出数组中的数据在int范围之内，那么我们就可以在实现上可以对int的32个位每个位进行依次判断该位1的个数求余3后是否为1，如果为1说明结果该位二进制为1可以将结果加上去。最终得到的值即为答案。\n**解答**\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int value=0;\n        for(int i=0;i<32;i++)\n        {\n            int sum=0;\n            for(int num:nums)\n            {\n                if(((num>>i)&1)==1)\n                {\n                    sum++;\n                }\n            }\n            if(sum%3==1)\n                value+=(1<<i);\n        }\n        return value;\n    }\n}\n```","tags":["java"]},{"title":"2021年终总结","url":"/2022/01/10/2022-01-10-2021年终总结/","content":"\n# 1、2021\n\n2021是崭新的一年，是疫情的第二年，也是大学生涯的第三年。\n\n## 1.1、编程学习\n\n今年一年，是冲刺学习 java 的一年，大部分的知识都是在今年学习到的。\n在今年，当了四个项目的组长，虽然都是简单的单体项目，但是在学习中一步一步成长的感觉还是十分舒服的。四个项目分别是：点餐系统、桂电宿舍管理系统、国医堂小程序以及骏泰理发店管理系统。\n2月，尽管是过年时间，线上学习还是不能停。\n6月，其他同学都放假回家了，我们留在学校加班学习，第一次不回家过暑假，看着家里的朋友在家喝茶玩耍，真是恨不得当场买票回去。但是想到以后工作之后，这将成为常态，感觉自己还是得适应，同时也感叹自己即将步入社会，也会开始怀念大学生活了。\n暑假的加班学习是为了今后更好的就业，所以我也一直在加油。\n8月，开发了自己的第一个博客，用的是 hexo 的框架，主要是图方便，还好看，主题多。然后博客是用 GitHubPage 搭建的，所有内容都存在GitHub上。想着这个博客里分享一些自己学到的技术，还有写一些自己的感想什么的。\n9月，开始面试了。在面试过程中，第一家公司，也就是现在签三方的公司，面试过程都比较轻松，感觉面试官也比较看重我。后面在面试一家工资较高的公司的时候，虽然笔试成绩还算不错，但是因为学的不够深入，很多问题没有回答上来，所以就被刷下来了。\n总结一下今年的秋招面试：有遗憾，但是也很满足了。\n11月，想着自己有一个闲置的服务器，就想着用来做点什么，就自己开发了一个书签项目，放在服务器里面，里面存了一些自己用过的书签网站，还可以快速跳转到我的博客，还可以快速搜索，自己还异想天开弄了一个广告框，想着有人能打广告，赚点零花钱。以后还会自己开发这个项目，增加更多功能。\n12月和好兄弟一起开发了一个真实的项目：桂林医学院报修系统！这个项目虽然是学长留下的二手项目，但是在接手项目时，从阅读源码到本地运行，从本地开发到正式上线，我真实感觉到了自己从项目中学习到了很多新的思想。一开始接手项目时，基本上是从0开始阅读源码，到现在已经可以灵活使用以及修改项目中的每一处代码，从中看到了自己的进步，同时也看到了自己和其他人的差距所在。\n印象比较深刻的是第一次上线自己写的程序的时候，刚刚一开始上线，系统就进不去了，折腾了一个晚上还是没有解决，最后还是靠学长帮忙才得以解决（虽然后面发现其实并不是我们的锅）。\n知道前几天，一起开发的兄弟才发现，原来是服务器jar的加密问题，具体的我也不太懂。\n其间还跟着老师去见了一次甲方，对项目的二期需求进行一个沟通，第一次真实经历这种场面，一开始还真有点紧张，但是到后面也逐渐放松了下来这样的经验是很珍贵的，对以后的职场应对有很大的帮助。在沟通过程中甲方有些不经过脑子的需求确实很难以理解，但是在积极的沟通之下还是进行的很顺利。\n现在项目一期也已经验收通过了，老师也说二期不用太过着急，但是还是要提上日程，尽快完成需要的项目。\n而另一个理发店项目基本处于放羊状态，也不着急，我们就慢慢做了。\n\n目前也在学习算法，只要算法玩的好，大厂什么的根本不是梦。\n## 1.2、专业学习\n\n今年是毕业年级了，要考虑的不只是学习，还有自己未来的发展方向。\n3月，现在是大三的下学期，这个学期会接触到更多的编程方面的课程，比如说：Java语言程序设计、算法分析与设计、软件工程、ACM程序设计等等。这样的课程对我来说是比较感兴趣的，相对于数学，我觉得我更适合编程，果然自己是一个科研废物。\n7月，成绩全都出了，今年终于迎来自己第一个大满贯，没有挂科科目，继续加油，争取更好成绩！今年暑假留校，加班学习。\n9月，正式成为一个大四狗。今年除了面对学习的压力，更多的是来自就业方面的，由于疫情的影响，大学生就业形式不容乐观，提升自己专业能力，才是使自己更有优势的唯一途径。\n12月，又是一个大满贯，终于把所有的课程都修完了，困扰了我多年的英语也终于都通过了。接下来就是毕业论文了，我做的内容是纯理论研究，对于我这样一个科研废物来说，这样的内容无疑是要我老命，但是没办法，终究自己还是数学专业的人，只能硬着头皮做了。\n奖项方面，今年跟同学一起拿了几个小奖项，数学建模竞赛校内三等奖、市场调查大赛校内三等奖、金融证券大赛南部赛区团队一等奖。\n感觉专业学习方面的年终总结确实写不出啥东西，毕竟科研方面自己还是不如其他同学。。。\n\n\n# 2、年度总结\n年度编程语言：java\n年度框架：Spring Boot\n年度IDE：IntelliJ IDEA\n年度技术社区：CSDN\n年度学科：数学\n年度歌手：五月天\n年度演员：沈腾\n年度电影：《飞驰人生》\n年度游戏：城市天际线\n年度社交软件：微信\n年度音乐软件：QQ音乐\n年度视频平台：bilibili\n年度UP主：徐大虾\n年度综艺：下一个是谁\n年度动漫：某科学的超电磁炮\n年度运动：篮球\n年度球队：洛杉矶湖人\n年度球星：凯尔 库兹马\n","tags":["随笔"],"categories":["随笔","年终总结"]},{"title":"SpringBoot发送微信模板消息","url":"/2021/12/10/2021-12-10-SpringBoot发送微信模板消息/","content":"\n# SpringBoot发送微信模板消息\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- MySQL 8.0\n\n## 2、工作\n\n这段时间在做项目的时候，甲方要求将之前的易班消息推送更换成微信公众号模板消息推送，所以本文就是记录一下使用模板消息的过程，\n\n开发的时候我用的是微信的[测试公众账号](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)，但是实际的功能和企业的账号是一样的。\n\n\n\n## 3、准备工作\n\n首先我们要知道，{% wavy 模板消息 %}是什么？以下就是公众号模板消息，我们在生活中很多场景都会接触到它。\n<img src=\"https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/Screenshot_2021-12-06-23-00-46-398_com.tencent.mm.jpg\" style=\"zoom:15%;\" />\n\n在进入了测试号的管理后台之后，我们可以在这里设置我们的模板消息的{% wavy 模板 %}\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209002928.png)\n\n首先我们要在公众平台中设置好我们的模板，然后 java 中根据模板信息来添加相应的内容。\n\n## 4、java后端编写\n\n我们创建一个名为`WeChatNotify`的工具类，里面存放的是模板消息的设置内容\n\n```java\n@Component\npublic class WeChatNotify {\n    @Autowired\n    private IDictService ds;\n    @Autowired\n    private ParseUtil pu;\n    @Autowired\n    private JdrService js;\n\n    // 发送模板信息\n    public String push(String openid,String map, Bxd bxd) {\n        //1，配置\n        WxMpInMemoryConfigStorage wxStorage = new WxMpInMemoryConfigStorage();\n        wxStorage.setAppId(\"wxacc93d31c5dbd26f\");\n        wxStorage.setSecret(\"f8c9e82b590ac71eb12e96f77cf65740\");\n        WxMpService wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(wxStorage);\n        //2,推送消息\n        WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder()\n                .toUser(openid)//要推送的用户openid\n                .templateId(\"-1pT4MrVw4asKamh0IQMF6c22Ih74dRjxqN8fwhjoQs\")//模版id\n                .url(\"https://www.cyc0819.top\")//点击模版消息要访问的网址\n                .build();\n\n        // 获取保修类别\n        String bxlb=pu.paraseBxlb(bxd.getBxlb());\n        //3,正式版发送模版消息，这里需要配置你的信息，替换微信公众号上创建的模板内容\n        templateMessage.addData(new WxMpTemplateData(\"map\", map, \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"type\",bxlb, \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"text\", bxd.getXxdd()+bxd.getBxnr(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"time\", bxd.getYysj(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"name\", bxd.getSbr(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"phone\", bxd.getSbrsj(), \"#173177\"));\n        try {\n            wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);\n            return \"推送成功\";\n        } catch (Exception e) {\n            System.out.println(\"推送失败：\" + e.getMessage());\n            e.printStackTrace();\n            return \"推送失败\";\n        }\n    }\n\n    // 检查openid是否已经绑定\n    public String selOpenid(String ybid){\n        String openid=js.selOpenidForYbid(ybid);\n        if (openid == null){\n            return null;\n        }\n        return openid;\n    }\n}\n```\n在这里，我们需要公众号的`appid,appsecret`，以及接收人的`openid`。\n\n{% note warning:: 如何获取用户的 openid 可以看以下这篇文章。 %}\n{% link SpringBoot+Vue微信授权获取用户openid :: http://cyc0819.top/2021/12/09/2021-12-09-SpringBoot+Vue%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7openid/ %}\n\n给足所需要的消息，然后在要发送消息的地方调用即可\n```java\npublic String zdpdWeChat(String eid, String bxlb,Bxd bxd){\n    String ybid=zdpd(eid,bxlb);\n    String map=es.selxxwz(Integer.parseInt(eid));\n    //调用发送模板信息\n    wcn.push(\"OPENID\",map,bxd);\n    return ybid;\n}\n```\n\n","tags":["java","SpringBoot"],"categories":["java","SpringBoot"]},{"title":"SpringBoot+Vue微信授权获取用户openid","url":"/2021/12/09/2021-12-09-SpringBoot+Vue微信授权获取用户openid/","content":"\n# SpringBoot+Vue微信授权获取用户openid\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- MySQL 8.0\n- Vue 3.0\n\n## 2、需求\n\n这几天在做桂林医学院的项目的时候，甲方提出了需求说能不能将消息通知改成微信公众号通知，因为公众号的效率比较高，同时受众也是比较多（原本用的是易班的 api，文档及其不友好，bug 官方也不解决，按照上一届学长的说法，之前发送消息接收人得等两天之后才能收到）。\n\n而如果用到微信的公众号，必须就得接收人主动绑定自己的微信号，我们才能获取他的 openid ，才能对其发送模板消息。\n\n## 3、微信公众号模板消息\n\n开发的时候我用的是微信的[测试公众账号](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)，但是实际的功能和企业的账号是一样的。\n\n首先我们要知道，{% wavy 模板消息 %}是什么？以下就是公众号模板消息，我们在生活中很多场景都会接触到它。\n<img src=\"https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/Screenshot_2021-12-06-23-00-46-398_com.tencent.mm.jpg\" style=\"zoom:15%;\" />\n\n在进入了测试号的管理后台之后，我们可以在这里设置我们的模板消息的{% wavy 模板 %}\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209002928.png)\n\n当然，本文的主题并不是模板消息的发送，而是使用模板消息的时候引发的其他问题，具体的模板消息可以移步我的：\n{% link SpringBoot发送微信模板消息 :: http://cyc0819.top/2021/12/10/2021-12-10-SpringBoot%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/ %}\n\n## 4、SpringBoot获取openid\n\nopenid 是微信用户的唯一标识，就跟人的身份证一样，每个微信号都有一个自己的 openid ，用于识别每个微信，一般情况下，我们无法看到，更无法修改我们的 openid，此时如果需要获取，就需要微信官方给我们提供的接口：\n\n我们点开下图中的{% span blue::蓝色 %}字体,\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003547.png)\n可以进入到[网页授权](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)的界面：\n\n里面详细介绍了获取openid，甚至是用户信息的过程：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003923.png)\n\n以下是我通过 java 实现的一些过程，可供参考。\n\n### 4.1、用户同意授权，获取code\n\n根据官方的说法，我们需要请求一个链接来获取到用户的 CODE\n链接如下：\n`https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect`\n\n这里有几个参数，官方文档都有说明，这里重点是把要去上一步中：\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003547.png)\n\n最后面的修改那里，将域名改成与  REDIRECT_URI 一致\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209004933.png)\n\n而此时我们选择的`scope`是需要用户手动通过授权的`snsapi_userinfo`\n\n然后我们就有了我们的链接，此时就要去代码中对其进行请求了。\n\n以下就是java代码\n首先我们在 SpringBoot模块中建一个 `WechatOAuth` 控制器，用来接受前端发来的请求\n```java\n@RestController\n@RequestMapping(\"wechat\")\npublic class WechatOAuth {\n\n    @Autowired\n    private AuthUtil authUtil;\n    @Resource\n    private UserService userService;\n\n    // 用户同意授权，获取code\n    @RequestMapping(\"/oauth\")\n    public void oauth(HttpServletResponse response, String id) throws IOException {\n\n        // System.out.println(\"开始询问用户是否同统一授权\");\n        String appid = \"wxac**********d26f\";\n        String path = \"http://10.33.73.62:8089/wechat/invoke\";\n        path = URLEncoder.encode(path, \"UTF-8\");\n\n        String url = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=\" + appid\n                + \"&response_type=code&scope=snsapi_userinfo&redirect_uri=\" + path\n                + \"&state=\" + id\n                + \"&connect_redirect=1#wechat_redirect\";\n        //请求转发链接\n        response.sendRedirect(url);\n    }\n}\n```\n在这里，我们请求链接获得 code ，然后返回我们设置好的{% wavy 回调地址 %}，也就是上面的 path，（注意，此处的地址要和前面我们设置的一致，后面的端口可以改变）\n\n### 4.2、通过code换取网页授权openid\n\n然后我们再写一个转发之后的控制器。\n也就是上一步中`String path = \"http://10.33.73.62:8089/wechat/invoke\";`\n\n```java\n// 用户同意授权\n    @RequestMapping(\"/invoke\")\n    public String oauthInvoke(HttpServletRequest request, HttpServletResponse response) {\n        // 获得code\n        System.out.println(\"用户同意授权，开始获取openid\");\n        String code = request.getParameter(\"code\");\n        String state = request.getParameter(\"state\");\n        System.out.println(code);\n        System.out.println(state);\n\n        // 判断是否绑定过openid\n        String isOpenid=userService.selUser(state).getOpenid();\n        if (isOpenid!=null){\n            return \"您已经绑定过微信了,如需修改请联系管理员\";\n        }\n        // 通过token获取access_token\n        String appid = \"wxacc93d31c5dbd26f\";\n        String secret = \"f8c9e82b590ac71eb12e96f77cf65740\";\n        String url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=\" + appid\n                + \"&secret=\" + secret\n                + \"&code=\" + code\n                + \"&grant_type=authorization_code\";\n        try {\n            JSONObject jsonObject = authUtil.doGetJson(url);\n            String openid= (String) jsonObject.get(\"openid\");\n            System.out.println(openid);\n            // 将openid插入到user表中\n            userService.addOpenid(state,openid);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"授权成功,绑定微信成功\";\n    }\n```\n\n此处同样是请求链接，就可以返回一个 json 数据，里面就有我们所需要的数据，如果还需要用户信息的数据，可以继续跟着官方的步骤继续往下做，但是我们这里只需要一个 openid，所以就到这一步。\n\n在这一步中，我们请求该链接，然后用`authUtil`工具里来解析，将其返回的数据转换为 json 数据，以方便我们的提取使用，转换为 json 数据之后，只要从中通过 `key` 取出来即可。\n\n此处首先会判断用户的 openid 是否存在，如果存在就弹出提示，不执行以下的操作，否则在查出用户的openid 之后，即可绑定到数据库，弹出提示信息。\n\n以下是此处用到的 authUtil 工具类\n```java\n@Component\npublic class AuthUtil {\n\n    public static final String APPID = \"wx45c1428e5584fcdb\";\n    public static final String APPSECRET = \"98174450eb706ada330f37e646be85d5\";\n\n    public JSONObject doGetJson(String url) throws ClientProtocolException, IOException {\n        JSONObject jsonObject = null;\n        //首先初始化HttpClient对象\n        DefaultHttpClient client = new DefaultHttpClient();\n        //通过get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //通过HTTPclient的execute方法进行发送请求\n        HttpResponse response = client.execute(httpGet);\n        //从response里面拿自己想要的结果\n        HttpEntity entity = response.getEntity();\n        if(entity != null){\n            String result = EntityUtils.toString(entity,\"UTF-8\");\n            // jsonObject = JSONObject.fromObject(result);\n            jsonObject= JSON.parseObject(result);\n        }\n        //把链接释放掉\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n}\n```\n\n## 5、前端请求后端接口\n\n我们需要一个能看得过去，能让用户输入账号密码的前端界面，所以以下是我们 vue 的代码\n```vue\n<template>\n  <div class=\"login\">\n    <div class=\"form-login\">\n      <el-form ref=\"form\" :model=\"data.form\" >\n        <el-form-item label=\"账户\">\n          <el-input v-model=\"data.form.name\" class=\"input-login\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"密码\">\n          <el-input v-model=\"data.form.pass\" type=\"password\" class=\"input-login\"></el-input>\n        </el-form-item>\n        <el-button type=\"primary\"  @click=\"Wechatlogin\">微信授权</el-button>\n      </el-form>\n    </div>\n  </div>\n</template>\n\n<script>\nimport {getCurrentInstance, reactive} from \"vue\";\nimport qs from \"qs\";\nimport router from \"../../router\";\nimport { ElLoading } from 'element-plus'\n\nexport default {\n  name: \"Wechar\",\n  setup(){\n    const {proxy}=getCurrentInstance();\n    const qs=require('qs');\n    const data=reactive({\n      form: {\n        name: '',\n        pass: '',\n      },\n    })\n    const Wechatlogin = () => {\n      const loading = ElLoading.service({\n        lock: true,\n        text: 'Loading',\n        background: 'rgba(0, 0, 0, 0.7)',\n      })\n      proxy.$axios.post('user/login',qs.stringify({ \"userId\":data.form.name,\"userPass\":data.form.pass })).then(res=>{\n        if (\"允许登录\"==res.data){\n          window.location.href=\"http://10.33.73.62:8089/wechat/oauth?id=\"+data.form.name\n          loading.close()\n        }else{\n          loading.close()\n          alert(res.data);\n        }\n      });\n\n    }\n    return{\n      data,Wechatlogin,\n    }\n  }\n}\n</script>\n```\n\n这里点击授权的按钮之后，首先会判断用户是否存在以及密码是否正确，然后就去调用后端的接口。\n\n{% note warning:: 注意此处有一个坑：\n可以看到我这里`window.location.href=\"http://10.33.73.62:8089/wechat/oauth?id=\"+data.form.name`使用的是`window.location.href`请求后端接口。\n这里是不能用`axios`进行请求的，会出现跨域异常（跨域到微信的服务器）。\n算是一个逼坑指南。 %}\n\n\n## 6、完整流程\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209115733.png)\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209115941.png)\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120057.png)\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120115.png)\n\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120147.png)","tags":["java","SpringBoot，Vue"],"categories":["java","SpringBoot","前端","Vue"]},{"title":"json—lib依赖无法下载问题","url":"/2021/12/08/2021-12-08-json—lib依赖无法下载问题/","content":"\n# json-lib依赖无法下载问题\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- Maven源：阿里云\n\n## 2、问题\n\n昨天在研究微信验证时，需要用到 `JSONObject.fromObject(result);` 这个方法，所以需要引入 `json-lib` 的依赖，引入依赖很简单，本以为复制黏贴就可以了，但是不知道为什么阿里云的 maven 仓库却死活无法找到这个依赖的包。后面通过手动引入的方式解决。\n\n## 3、解决\n### 3.1、引入的依赖\n```xml\n<!-- https://mvnrepository.com/artifact/net.sf.json-lib/json-lib -->\n<dependency>\n    <groupId>net.sf.json-lib</groupId>\n    <artifactId>json-lib</artifactId>\n    <version>2.4</version>\n</dependency>\n```\n\n### 3.2、报错\n\n此时直接进行下载会提示找不到依赖的相关内容\n\n### 3.3、解决方法一\n\n翻阅了网上的说法，说是在依赖后面加上一句：`<classifier>jdk15</classifier>` ，因为远程提供了两个包，我试了一下在我这里并不管用。\n所以，此方法基本放弃。\n\n### 3.4、解决方法二\n\n另一个方法，就是去[MAVEN存储库](https://mvnrepository.com/)直接下载jar包，\n但是在我打开网站的时候，点击 jar 包进行下载，却发现，这里的也无法下载了\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208141505.png)\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208141543.png)\n\n所以基本上可以判断不是我们自己的问题了。\n\n偶然之间，我发现这个依赖竟然有一个官网：[JSON-lib](http://json-lib.sourceforge.net/)\n\n进去看看![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142229.png)\n官网里应该有 jar 包的下载链接\n果然，点击下面这个按钮就可以正常下载了\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142313.png)\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142413.png)\n\n**下载完成之后就可以进行手动的导入了**\n我这里选择的是将我们手动下载的 jar 包，放在 maven 本地仓库的相应位置\n首先，我们需要将后面的 `jdk15` 去掉，因为我们的依赖里是没有的。\n\n然后根据自己的本地仓库位置，找到 json-lib的本地仓库\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208143118.png)\n点击进入 2.4 文件夹,将我们更名之后的 jar 包放到其中\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208143204.png)\n最后记得把带有 `last` 的文件删掉\n\n最后到 java 项目中重新载入一下 maven 就可以了。\n\n\n\n## 4、结束\n\n`json-lib` 相当于 `jackson,fastjson`这样的 jar 来说，效率不高，所以建议使用后者。\n\n`json-lib`中的 `JSONObject.fromObject(result)` 方法可用\n`fastjson`中的`JSON.parseObject(result);`进行替代\n\n","tags":["java","maven"],"categories":["java","maven"]},{"title":"回顾SSM框架整合","url":"/2021/11/30/2021-11-30-回顾SSM框架整合/","content":"\n# 回顾SSM框架整合\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- mySQL 8.0\n- Tomcat 9.0.27\n\n## 2、创建数据库\n首先创建一个测试用的数据库 books：\n```sql\ncreate table books\n(\n    bid     int     not null primary key,\n    sname   varchar(255) null,\n    bname   varchar(255) null,\n    bauthor varchar(255) null,\n    bhome   varchar(255) null\n);\n```\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130132921.png)\n\n## 3、创建项目\n现在创建一个普通的 Maven 项目，并引入所需要的依赖\n```xml\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <spring.version>5.2.3.RELEASE</spring.version>\n    </properties>\n    \n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.3</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.zaxxer</groupId>\n            <artifactId>HikariCP</artifactId>\n            <version>3.4.5</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>${spring.version}</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.11</version>\n        </dependency>\n        <dependency>\n            <groupId>com.mchange</groupId>\n            <artifactId>c3p0</artifactId>\n            <version>0.9.5.2</version>\n        </dependency>\n    </dependencies>\n```\n\n## 4、设置资源过滤\n在 pom.xm 中插入资源过滤的代码\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.xml</include>\n                <include>**/*.properties</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.xml</include>\n                <include>**/*.properties</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n## 5、添加 web 框架支持\n给我们创建的普通项目添加上框架支持，在项目名上右键，即可添加框架支持。\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130133853.png)\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130134459.png)\n\n## 5、创建 spring 配置文件\n在刚刚项目的 resources 下面创建配置文件 db.properties ，其中写的是数据库的相关配置\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF8&userSSL=true&serverTimezone=GMT\njdbc.username=chenyicai\njdbc.password=cyc1234\n```\n\n以及创建 applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--    使用连接池，开源的连接池-->\n    <!--    阿里：druid-->\n    <!--    c3p0-->\n    <!--    hiraki：springboot默认使用的连接池-->\n    <!--    一个应用最大并发如果有500个，那么为了提高查询效率，预先创建500个连接，并且把500个连接放入连接池（容器）-->\n\n    <!-- 控制器类的创建交给SpringMVC，不能配置在bean容器中 -->\n    <context:component-scan base-package=\"com.chen\"></context:component-scan>\n\n    <context:property-placeholder location=\"classpath:db.properties\"></context:property-placeholder>\n\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"></property>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"></property>\n        <property name=\"user\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n\n        <!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3 -->\n        <property name=\"initialPoolSize\" value=\"15\"></property>\n\n        <!--最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 -->\n        <property name=\"maxIdleTime\" value=\"0\"></property>\n\n        <!--连接池中保留的最大连接数。默认值: 15 -->\n        <property name=\"maxPoolSize\" value=\"100\"></property>\n\n        <!-- 连接池中保留的最小连接数，默认为：3 -->\n        <property name=\"minPoolSize\" value=\"10\"></property>\n\n        <!--c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值:\n            0 -->\n        <property name=\"maxStatements\" value=\"200\"></property>\n\n        <!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认:\n            0 -->\n        <property name=\"checkoutTimeout\" value=\"3000\" />\n\n        <!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 -->\n        <property name=\"acquireIncrement\" value=\"2\" />\n\n        <!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次 -->\n        <property name=\"acquireRetryAttempts\" value=\"0\" />\n\n        <!--重新尝试的时间间隔，默认为：1000毫秒 -->\n        <property name=\"acquireRetryDelay\" value=\"5000\" />\n\n        <!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 -->\n        <property name=\"autoCommitOnClose\" value=\"false\"></property>\n\n        <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值:\n            null -->\n        <property name=\"automaticTestTable\" value=\"Test\"></property>\n\n        <!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认:\n            false -->\n        <property name=\"breakAfterAcquireFailure\" value=\"false\"></property>\n\n        <!--每60秒检查所有连接池中的空闲连接。默认值: 0，不检查 -->\n        <property name=\"idleConnectionTestPeriod\" value=\"0\"></property>\n\n        <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 -->\n        <property name=\"maxStatementsPerConnection\" value=\"10\"></property>\n    </bean>\n\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.chen.entity\"></property>\n        \n    </bean>\n</beans>\n```\n\n## 6、编写代码主体\n现在来编写代码中 entity，controller，service，mapper 层的代码\n**entity：books**\n```java\npublic class Books implements Serializable {\n    private Integer bid;\n\n    private String sname;\n\n    private String bname;\n\n    private String bauthor;\n\n    private String bhome;\n\n    private static final long serialVersionUID = 1L;\n    \n}\n```\n\n**mapper（此处演示的是传统的 DAO 的方式）:booksDao：**\n```java\npublic interface BooksDao {\n    int deleteByPrimaryKey(Integer bid);\n\n    int insert(Books record);\n\n    int insertSelective(Books record);\n\n    Books selectByPrimaryKey(Integer bid);\n\n    int updateByPrimaryKeySelective(Books record);\n\n    int updateByPrimaryKey(Books record);\n}\n```\n**booksDaoImpl：**\n```java\n@Repository\npublic class BooksDaoImpl implements BooksDao {\n\n    private SqlSessionFactory sqlSessionFactory;\n\n    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {\n        this.sqlSessionFactory = sqlSessionFactory;\n    }\n\n    @Override\n    public int deleteByPrimaryKey(Integer bid) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out=sqlSession.delete(\"deleteByPrimaryKey\",bid);\n        return out;\n    }\n\n    @Override\n    public int insert(Books record) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out=sqlSession.insert(\"insert\",record);\n        return out;\n    }\n\n    @Override\n    public Books selectByPrimaryKey(Integer bid) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        Books books=sqlSession.selectOne(\"selectByPrimaryKey\",bid);\n        return books;\n    }\n\n    @Override\n    public int updateByPrimaryKey(Books record) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out = sqlSession.update(\"updateByPrimaryKey\",record);\n        return out;\n    }\n}\n```\n\n**然后是 xml 文件，其中是执行的 sql：**\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org/DTD Mapper 3.0\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"user\">\n    <select id=\"selectByPrimaryKey\" parameterType=\"int\" resultType=\"com.chen.entity.Books\">\n        select\n        *\n        from books\n        where bid = #{bid,jdbcType=INTEGER}\n    </select>\n\n    <delete id=\"deleteByPrimaryKey\" parameterType=\"int\">\n        delete from books\n        where bid = #{bid,jdbcType=INTEGER}\n    </delete>\n\n    <insert id=\"insert\" parameterType=\"com.chen.entity.Books\" useGeneratedKeys=\"true\">\n        insert into books (sname, bname, bauthor,\n                           bhome)\n        values (#{sname,jdbcType=VARCHAR}, #{bname,jdbcType=VARCHAR}, #{bauthor,jdbcType=VARCHAR},\n                #{bhome,jdbcType=VARCHAR})\n    </insert>\n\n    <update id=\"updateByPrimaryKey\" parameterType=\"com.chen.entity.Books\">\n        update books\n        set sname = #{sname,jdbcType=VARCHAR},\n            bname = #{bname,jdbcType=VARCHAR},\n            bauthor = #{bauthor,jdbcType=VARCHAR},\n            bhome = #{bhome,jdbcType=VARCHAR}\n        where bid = #{bid,jdbcType=INTEGER}\n    </update>\n</mapper>\n```\n\n**service 层：BooksService**\n```java\npublic interface BooksService {\n    int deleteByPrimaryKey(Integer bid);\n\n    int insert(Books record);\n\n    Books selectByPrimaryKey(Integer bid);\n\n    int updateByPrimaryKey(Books record);\n}\n```\n**impl：**\n```java\npublic class BooksServiceImpl implements BooksService {\n\n    @Autowired\n    private BooksDao booksDao;\n\n    @Override\n    public int deleteByPrimaryKey(Integer bid) {\n        return booksDao.deleteByPrimaryKey(bid);\n    }\n\n    @Override\n    public int insert(Books record) {\n        return booksDao.insert(record);\n    }\n\n    @Override\n    public Books selectByPrimaryKey(Integer bid) {\n        return booksDao.selectByPrimaryKey(bid);\n    }\n\n    @Override\n    public int updateByPrimaryKey(Books record) {\n        return booksDao.updateByPrimaryKey(record);\n    }\n}\n```\n\n**最后是 Controller 层：BooksController**\n```java\n@RestController\npublic class BooksController {\n\n    @Autowired\n    private BooksService booksService;\n\n    public void setBooksService(BooksService booksService) {\n        this.booksService = booksService;\n    }\n\n    @RequestMapping(\"/del\")\n    int deleteByPrimaryKey(Integer bid){\n        return booksService.deleteByPrimaryKey(bid);\n    }\n\n    @RequestMapping(\"/ins\")\n    int insert(Books record){\n        return booksService.insert(record);\n    }\n\n    @RequestMapping(\"/sel\")\n    Books selectByPrimaryKey(Integer bid){\n        return booksService.selectByPrimaryKey(bid);\n    }\n\n    @RequestMapping(\"/up\")\n    int updateByPrimaryKey(Books record){\n        return booksService.updateByPrimaryKey(record);\n    }\n}\n```\n\n最后项目的结构如下：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130145929.png)\n\n## 7、现在需要在配置 xml 中编写扫描我们的 bean 的代码\n\n加入以下代码：\n```xml\n    <bean id=\"userDao\" class=\"com.chen.mapper.impl.BooksDaoImpl\">\n        <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    </bean>\n\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.chen.entity\"></property>\n        <property name=\"mapperLocations\" value=\"classpath*:mapper/BooksMapper.xml\"></property>\n    </bean>\n```\n如图：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130150442.png)\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130150809.png)\n\n## 8、web 配置\n在 web.xml 中配置以下内容,用于配置dispatcherServlet中心控制器\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <display-name>Archetype Created Web Application</display-name>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:applicationContext.xml</param-value>\n    </context-param>\n    <!-- 监听器会自动读取applicationContext.xml中的bean的信息，完成bean的初始化-->\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><!-- 前端控制器 -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>/</url-pattern><!-- 处理所有请求，当然也包含静态资源（js、css、img...） -->\n    </servlet-mapping>\n</web-app>\n```\n\n在创建一个 dispatcher-servlet.xml，用于 MVC 的装配\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 扫描控制器的包，以确定哪些类是控制器类（哪些类上使用了@Controller注解） -->\n    <context:component-scan base-package=\"cn.edu.guet.controller\"></context:component-scan>\n\n    <!-- 表示：所有的静态资源使用默认的Servlet -->\n    <mvc:default-servlet-handler></mvc:default-servlet-handler>\n\n    <mvc:annotation-driven></mvc:annotation-driven>\n\n\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property><!-- 告诉SpringMVC去哪个目录找文件 -->\n        <property name=\"suffix\" value=\".jsp\"></property><!-- 文件的后缀 -->\n    </bean>\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n    <!--通过处理器适配器AnnotationMethodHandlerAdapter来开启支持@RequestMapping注解-->\n\n</beans>\n```\n\n## 9、运行测试\n此时我们用 Tomcat 构建项目。\n出现以下结果：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130172158.png)\n\n如果出现这种情况，我们就需要将 maven 的包手动导入，才能成功启动项目。\n步骤如下：\n1. 打开项目结构。\n2. 点击构件，然后点击WEB-INF目录，点击新建文件夹按钮，创建lib文件夹。\n3. 然后引入库。\n4. 将其全选，然后需要的jar包便全部导入到项目中。\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130173210.png)\n\n**再运行，即可**","tags":["java","spring"],"categories":["java","spring"]},{"title":"eCharts学习笔记","url":"/2021/11/27/2021-11-27-eCharts学习笔记/","content":"\n# eCharts 学习笔记\n\n## 1、简介\neCharts 是百度出品的一款基于 JavaScript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。最开始是由百度团队开源的，后面于2018年交由Apache基金会，称为ASF孵化项目。并于2021年1月26日正式毕业。\n\n## 2、在 Vue 中使用\n1. 首先下载 eCharts：\n```shell\nnpm install echarts --save\n```\n2. 全局引入 eCharts:\n```js\nimport * as echarts from 'echarts';\n```\n3. 或者可以按需引入\n```js\n// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。\nimport * as echarts from 'echarts/core';\n// 引入柱状图图表，图表后缀都为 Chart\nimport { BarChart } from 'echarts/charts';\n// 引入提示框，标题，直角坐标系，数据集，内置数据转换器组件，组件后缀都为 Component\nimport {\n  TitleComponent,\n  TooltipComponent,\n  GridComponent,\n  DatasetComponent,\n  DatasetComponentOption,\n  TransformComponent\n} from 'echarts/components';\n// 标签自动布局，全局过渡动画等特性\nimport { LabelLayout, UniversalTransition } from 'echarts/features';\n// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步\nimport { CanvasRenderer } from 'echarts/renderers';\n\n// 注册必须的组件\necharts.use([\n  TitleComponent,\n  TooltipComponent,\n  GridComponent,\n  DatasetComponent,\n  TransformComponent,\n  BarChart,\n  LabelLayout,\n  UniversalTransition,\n  CanvasRenderer\n]);\n```\n## 3、基本语法结构\n\n在使用 eCharts 之前，我们需要给它一个 DOM 容器，官方是推荐我们使用具有定义好的长和宽的一个父容器（可以是 div ）。\n所以我们首先构建一个父容器 div 来存放 eCharts 图表\n```html\n<div id=\"billreport\"\n    :style=\"{ width: '95%', height: '500px' }\"></div>\n```\n\n由于 eCharts 基于js构建的，所以只要会js的语法，eCharts的语法自然也不在话下。\n而 eCharts 的基本语法结构为：\n```js\nsetup(){\nconst data=reactive({\n    option:{\n    \t//图表信息\n    }\n})\n\nconst ech = () => {\n\t//绘制图表的方法\n\t}\n}\n\nonBeforeMount(()=>{\n\t//在页面渲染之前加载图表的信息\n})\n```\n\n## 4、图表配置信息\n图表配置信息，即 option 中的内容，在这一部分，我们将配置一系列的信息，正是这些信息生成了对应的图表。\n```js\noption:{\n\ttitle:{\n\t\ttext: \"收入与支出趋势图\"//图表的标题\n\t},\n\ttooltip:{//提示的信息\n\t\ttrigger:'axis'//触发方式\n\t},\n    legend: {//图例\n        data: [{\n        \tname: '收入',\n        \t// 强制设置图形为圆。\n        \ticon: 'circle',\n        \t// 设置文本为红色\n        \ttextStyle: {\n            \tcolor: 'red'\n        \t}\n    \t},\n              {\n        \tname: '支出',\n        \t// 强制设置图形为圆。\n        \ticon: 'circle',\n        \t// 设置文本为红色\n        \ttextStyle: {\n            \tcolor: 'red'\n        \t}\n    \t}]//图例的标题，分别对应 series 中的数据\n    }，\n    xAxis: {//配置要在x轴显示的项\n        type: 'category',//'value' 数值轴，适用于连续数据。 'category' 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。 'time' 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。 'log' 对数轴。适用于对数数据。\n        boundaryGap: false,// 刻度离纵轴有无间隙，默认true有间距\n        data: []//横轴坐标的值\n    },\n    yAxis: {//配置y轴的项，配置与x轴类似\n        type: 'value'\n    },\n    series: [//系列列表,显示在图表中的内容\n      {\n        name: '收入',//系列名称\n        type: 'line',//图表类型\n        stack: '收入',//堆叠，如果有相同名称的会堆叠\n        data: []\n      },\n      {\n        name: '支出',\n        type: 'line',\n        stack: '支出',\n        data: []\n      }\n   ]\n}\n```\n\n图表类型表：\n\n| 配置                  | 图表类型                       |\n| --------------------- | ------------------------------ |\n| type: 'bar'           | 柱状/条形图                    |\n| type: 'line'          | 折线/面积图                    |\n| type: 'pie'           | 饼图                           |\n| type: 'scatter'       | 散点（气泡）图                 |\n| type: 'effectScatter' | 带有涟漪特效动画的散点（气泡） |\n| type: 'radar'         | 雷达图                         |\n| type: 'tree'          | 树型图                         |\n| type: 'treemap'       | 树型图                         |\n| type: 'sunburst'      | 旭日图                         |\n| type: 'boxplot'       | 箱形图                         |\n| type: 'candlestick'   | K线图                          |\n| type: 'heatmap'       | 热力图                         |\n| type: 'map'           | 地图                           |\n| type: 'parallel'      | 平行坐标系的系列               |\n| type: 'lines'         | 线图                           |\n| type: 'graph'         | 关系图                         |\n| type: 'sankey'        | 桑基图                         |\n| type: 'funnel'        | 漏斗图                         |\n| type: 'gauge'         | 仪表盘                         |\n| type: 'pictorialBar'  | 象形柱图                       |\n| type: 'themeRiver'    | 主题河流                       |\n| type: 'custom'        | 自定义系列                     |\n\n## 5、x 轴、y 轴\n\nx 轴和 y 轴都由轴线、刻度、刻度标签、轴标题四个部分组成。\n一般情况下，二维的图标结构都会有 x 轴和 y 轴，通常情况下，x 轴会在图表的下方，而 y 轴在图表的左边。\n而 eCharts 也提供了一些特定的坐标轴的设置选项，如：\n**轴线：**\n我们可以通过 axisLine 来对轴线进行设置，比如轴线两头的箭头，轴线的样式等等，比如：\n```js\noption = {\n  xAxis: {\n    axisLine: {\n      show:'true' //显示轴线\n      symbol: 'arrow', //轴线两边的箭头\n      lineStyle: { //轴线的样式，有颜色、宽度、类型等等\n        type: 'dashed'\n        // ...\n      }\n    }\n    // ...\n  },\n  yAxis: {\n    axisLine: {\n      symbol: 'arrow',\n      lineStyle: {\n        type: 'dashed'\n        // ...\n      }\n    }\n  }\n  // ...\n};\n```\n轴线两边的箭头选项：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129165935.png)\n\n**坐标轴刻度：**\nECharts 提供了轴线 axisTick 相关的配置，我们可以根据实际情况调整，例如刻度线的长度，样式等。以下是一个坐标轴刻度的例子：\n```js\noption = {\n  xAxis: {\n    axisTick: {\n      show:true //开启坐标轴刻度\n      alignWithLabel:true //使刻度与标签对其（类目轴中在 boundaryGap 为 true 的时候有效）\n      inside:true //刻度线是否朝里（true为朝里）\n      interval：0 //坐标轴刻度的显示间隔,如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。\n      length: 6,//刻度线的长度\n      lineStyle: { //样式设置\n        type: 'dashed'\n        // ...\n      }\n    }\n    // ...\n  },\n  yAxis: {\n    axisTick: {\n      length: 6,\n      lineStyle: {\n        type: 'dashed'\n        // ...\n      }\n    }\n  }\n  // ...\n};\n```\n\n**刻度标签：**\nECharts 提供了轴线 axisLabel 相关的配置，我们可以根据实际情况调整。以下是一个例子：\n![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129171709.png)\n如上图所示，下面的星期就是刻度标签\n```js\noption = {\n  xAxis: {\n    axisLabel: {\n      show:true //显示刻度标签\n      interval:0 //显示刻度，同上\n      inside:true //标签是否朝里（true朝里）\n      rotate：45 // 标签偏移的角度\n      margin:5 //标签与轴线的距离\n      formatter: '{value} kg', //刻度标签的内容格式器，支持字符串模板和回调函数两种形式。\n      align: 'center' //文字水平对齐方式，默认自动。可选为：'left','center','right'\n      // ...\n    }\n    // ...\n  },\n  yAxis: {\n    axisLabel: {\n      formatter: '{value} 元',\n      align: 'center'\n      // ...\n    }\n  }\n  // ...\n};\n```\n\n**标签中的formatter：**\n```js\n// 使用字符串模板，模板变量为刻度默认标签 {value}\nformatter: '{value} kg'\n// 使用函数模板，函数参数分别为刻度数值（类目），刻度的索引\nformatter: function (value, index) {\n    return value + 'kg';\n}\n```\n更多关于 formatter 的内容可以参考官方的 [API](https://echarts.apache.org/zh/option.html#xAxis.axisLabel.formatter)\n\n## 6、主题配置\n\n在eCharts的内部，内置了两套主题，分别是亮色主题以及暗色主题\n通过以下的方式，我们可以修改主题\n```js\nvar chart = echarts.init(dom, 'light');\nvar chart = echarts.init(dom, 'dark');\n```\n\n或者我们可以通过eCharts的[主题编辑器](https://echarts.apache.org/zh/theme-builder.html)来创建自己的主题![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211128132725.png)\n\n## 7、数据集（dataset）\ndataset 组件可以用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以基于数据指定数据到视觉的映射。\n\n**写法一：**\n```js\ndataset: {\n    // 提供一份数据。\n    //第一行对应的是 x 轴\n    source: [\n        ['product', '2015', '2016', '2017'],\n        ['Matcha Latte', 43.3, 85.8, 93.7],\n        ['Milk Tea', 83.1, 73.4, 55.1],\n        ['Cheese Cocoa', 86.4, 65.2, 82.5],\n        ['Walnut Brownie', 72.4, 53.9, 39.1]\n    ]\n},\n```\n在 dataset 中管理数据之后，就可以不用在 series 单独进行数据的声明，而是直接在 data 除进行调用\n```js\n// 声明多个柱状图系列，默认情况下，每个系列会自动对应到 dataset 的每一列。\nseries: [\n    {type: 'bar'},\n    {type: 'bar'},\n    {type: 'bar'}\n]\n```\n\n**写法二：**\n```js\ndataset: {\n    // 这里指定了维度名的顺序，从而可以利用默认的维度到坐标轴的映射。\n    // 如果不指定 dimensions，也可以通过指定 series.encode 完成映射，参见后文。\n    dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n},\n```\n\n## 8、图例\n图例是图表中对内容区元素的注释、用不同形状、颜色、文字等来标示不同数据列，通过点击对应数据列的标记，可以显示或隐藏该数据列。图例虽然不是图表中的主要信息、却是了解图表信息的钥匙。\n以下是一个例子：\n```js\noption = {\n  legend: {\n    type:'plain' //图例的类型可选值：'scroll'：可滚动翻页的图例。当图例数量较多时可以使用。\n    // Try 'horizontal'\n    orient: 'vertical', //图例列表的布局朝向。可选：'horizontal'水平，'vertical'垂直\n    right: 10, //图例组件离容器右侧的距离。\n    top: 'center' //图例组件离容器上侧的距离。\n  },\n  dataset: {\n    source: [\n      ['product', '2015', '2016', '2017'],\n      ['Matcha Latte', 43.3, 85.8, 93.7],\n      ['Milk Tea', 83.1, 73.4, 55.1],\n      ['Cheese Cocoa', 86.4, 65.2, 82.5],\n      ['Walnut Brownie', 72.4, 53.9, 39.1]\n    ]\n  },\n  xAxis: { type: 'category' },\n  yAxis: {},\n  series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]\n};\n```\n显示内容如下：![](https://cdn.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129173307.png)\n更多内容参考官方 [API](https://echarts.apache.org/zh/option.html#legend)","tags":["前端","eCharts"],"categories":["前端","eCharts"]},{"title":"SpringSecurity+JWT实现的登录认证","url":"/2021/11/20/2021-11-20-SpringSecurity+JWT实现的登录认证/","content":"\n# SpringSecurity+JWT实现的登录认证\n\n## 1、简介\n\n1. Spring Security\n在 Web 编程开发中，登录安全往往也是很重要的一个部分，而 Spring Security 所做得就是这个工作。在 java 领域，成熟的安全框架解决方案一般有 Apache Shiro、Spring Security 等两种技术选型。Apache Shiro 简单易用也算是一大优势，但其功能还是远不如 Spring Security 强大。后者可以为应用提供声明式的安全访问限制，他提供了一系列的可以由开发者主动配置的 bean ，并利用 Spring IoC和 AOP等功能特性来为应用系统提供声明式的安全访问控制功能，减少了诸多重复工作。\n\n2. JWT\nJWT 的全称是：Json Web Token 。是在网路应用中传递信息的一种基于 json 的开发标准，可用于作为 json 对象在不同系统之间进行安全地信息传输。主要使用场景一般是用来在身份提供者和服务提供者间传递被认证的用户身份信息。\n\n## 2、设计登录认证所用的表\n\n本次登录认证需要用到三个表，分别是用户表，身份表以及用户和身份绑定的表。``\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for hibernate_sequence\n-- ----------------------------\nDROP TABLE IF EXISTS `hibernate_sequence`;\nCREATE TABLE `hibernate_sequence`  (\n  `next_val` bigint(0) NULL DEFAULT NULL\n) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;\n\n-- ----------------------------\n-- Records of hibernate_sequence\n-- ----------------------------\nINSERT INTO `hibernate_sequence` VALUES (1);\nINSERT INTO `hibernate_sequence` VALUES (1);\n\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role`  (\n  `id` bigint(0) NOT NULL,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of role\n-- ----------------------------\nINSERT INTO `role` VALUES (1, 'ROLE_NORMAL');\nINSERT INTO `role` VALUES (2, 'ROLE_ADMIN');\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` bigint(0) NOT NULL,\n  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles`  (\n  `user_id` bigint(0) NULL DEFAULT NULL,\n  `roles_id` bigint(0) NULL DEFAULT NULL,\n  INDEX `FKj9553ass9uctjrmh0gkqsmv0d`(`roles_id`) USING BTREE,\n  INDEX `FK55itppkw3i07do3h7qoclqd4k`(`user_id`) USING BTREE,\n  CONSTRAINT `FK55itppkw3i07do3h7qoclqd4k` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,\n  CONSTRAINT `FKj9553ass9uctjrmh0gkqsmv0d` FOREIGN KEY (`roles_id`) REFERENCES `role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES (1, 2);\nINSERT INTO `user_roles` VALUES (1, 1);\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users`  (\n  `id` bigint(0) NOT NULL,\n  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES (1, 'chenyicai', '$2a$10$hZG8XjmuAcuY.izAj0D7wuQIvPDdwdz.y4KcbGPI18Mri1hx1FWA6');\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n![](https://z3.ax1x.com/2021/11/20/IqIxJI.png)\n\n![](https://z3.ax1x.com/2021/11/20/IqoFeg.png)\n\n![](https://z3.ax1x.com/2021/11/20/IqokwQ.png)\n\n## 3、创建新工程并导入依赖及实体类\n\n1. 在创建一个SpringBoot工程之后我们需要引入Security和JWT必须的依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>io.jsonwebtoken</groupId>\n\t<artifactId>jjwt</artifactId>\n\t<version>0.9.0</version>\n</dependency>\n```\n\n2. 在配置文件中配置数据库信息\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/jwtdemo?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true\n    username: chenyicai\n    password: cyc1234\n  ackson:\n    serialization:\n      indent_output: true\nserver:\n  port: 8086\n#日志级别（一般设置为INFO）\nlogging:\n  level:\n    cn:\n      edu:\n        guet:\n          mapper: debug\n  org:\n    springframework:\n      security: info\nmybatis:\n  type-aliases-package: cn.edu.guet.entity\n  mapper-locations: classpath:mapper/*.xml\n```\n3. 创建用户以及身份实体类\n\nUsers类：（省略 getset 方法）\n\n此处所创建的 User 类继承了 Spring Security 的 UserDetails 接口，从而成为了一个符合 Security 安全的用户，即通过继承 UserDetails，即可实现 Security 中相关的安全功能。\n```java\npublic class User implements UserDetails {\n\n    private Long id;\n\n    private String username;\n\n    private String password;\n\n    private List<Role> roles;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        List<GrantedAuthority> authorities = new ArrayList<>();\n        for (Role role : roles) {\n            authorities.add( new SimpleGrantedAuthority( role.getName() ) );\n        }\n        return authorities;\n    }\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n```\nRole类：（省略 getset 方法）\n```java\npublic class Role {\n\n  private Long id;\n\n  private String name;\n\n}\n```\n\n## 4、JWT工具类\n\n该工具类主要用于对 JWT Token 进行各项操作，比如生成Token、验证Token、刷新Token 等\n```java\n@Component\npublic class JwtTokenUtils implements Serializable {\n    private static final long serialVersionUID = -5625635588908941275L;\n\n    private static final String CLAIM_KEY_USERNAME = \"sub\";\n    private static final String CLAIM_KEY_CREATED = \"created\";\n    private static final String CLAIM_KEY_AUTHORITIES=\"authorities\";\n\n    // 生成token\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put( CLAIM_KEY_USERNAME, userDetails.getUsername());\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n\n    // 验证token\n    public boolean validateToken(String token, UserDetails userDetails) {\n        String username = getUserNameFromToken(token);\n        return  !isTokenExpired(token);\n    }\n    // 刷新token\n    public String refreshToken(String token){\n        Claims claims = getClaimsFromToken(token);\n        claims.put(CLAIM_KEY_CREATED,new Date());\n        return generateToken(claims);\n    }\n    // 验证token是否失效\n    public boolean isTokenExpired(String token){\n        Date expireDate = getExpiredDateFromToken(token);\n        return expireDate.before(new Date());\n    }\n    // 从token中获取过期时间\n    public Date getExpiredDateFromToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        return claims.getExpiration();\n    }\n    // 从token中获取用户名\n    public String getUserNameFromToken(String token){\n        String username;\n        try{\n            Claims claims = getClaimsFromToken(token);\n            username = claims.getSubject();\n        } catch (Exception e) {\n            username = null;\n        }\n        return username;\n    }\n    // 从token中获取荷载\n    private Claims getClaimsFromToken(String token){\n        Claims claims = null;\n        try {\n            claims = Jwts.parser()\n                    .setSigningKey(Const.SECRET)\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n        return claims;\n    }\n    // 生成过期时间\n    private Date generateExpirationDate() {\n        return new Date(System.currentTimeMillis()+Const.EXPIRATION_TIME*1000);\n    }\n    // 根据荷载生成token\n    String generateToken(Map<String, Object> claims) {\n        return Jwts.builder()\n                .setClaims(claims)\n                .setExpiration(generateExpirationDate())\n                .signWith(SignatureAlgorithm.HS512, Const.SECRET )\n                .compact();\n    }\n}\n```\n\n这里还有一个常量类，存储了JWT的一些常量信息\n```java\npublic class Const {\n\n  // 5天(以毫秒ms计)\n  public static final long EXPIRATION_TIME = 432_000_000;\n  // JWT密码\n  public static final String SECRET = \"CodeSheepSecret\";\n  // Token前缀\n  public static final String TOKEN_PREFIX = \"Bearer\";\n  // 存放Token的Header Key\n  public static final String HEADER_STRING = \"Authorization\";\n}\n\n```\n\n## 5、Token过滤器\n\n用于每次外部对接口请求时的Token处理\n```java\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtils jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\n        // 确认是否能根据key拿到value\n        String authHeader = httpServletRequest.getHeader( Const.HEADER_STRING );\n        if (authHeader == null) {\n            authHeader =Const.TOKEN_PREFIX+\" \"+httpServletRequest.getHeader(\"token\");\n        }\n        // 判断登录用户的token不为空和是Bearer开头的\n        if (authHeader != null && authHeader.startsWith( Const.TOKEN_PREFIX )) {\n            // 取到token\n            final String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );\n            // 从用户请求携带的token获取用户名，能取到证明token除了时间以外都合法了\n            String username = jwtTokenUtil.getUserNameFromToken(authToken);\n            System.out.println(username);\n            // token 存在用户名但没有认证的\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                // 根据userDetails验证了token是否有效（验证时间是否过期和当前用户名是否匹配）\n                if (jwtTokenUtil.validateToken(authToken, userDetails)) {\n                    // 我们的token，框架是不认识的，token有效就转化构建 UsernamePasswordAuthenticationToken表示认证通过和进行相关授权\n                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(\n                            userDetails, null, userDetails.getAuthorities());\n                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(\n                            httpServletRequest));\n                    // 设置了认证主体，到UsernamePasswordAuthenticationFilter就不会拦截，因为你应该带有了它的token\n                    SecurityContextHolder.getContext().setAuthentication(authentication);\n                }\n            }\n        }\n        // 继续执行其他过滤器\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    }\n}\n```\n\n## 6、Service层业务操作\n\n主要是登录以及注册的业务\n\n首先是AuthService接口：\n```java\npublic interface AuthService {\n    User register( User userToAdd );\n    String login( String username, String password );\n}\n```\n\nAuthServiceImpl实现类：\n```java\n@Service\npublic class AuthServiceImpl implements AuthService {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    // 登录\n    @Override\n    public String login( String username, String password ) {\n        UsernamePasswordAuthenticationToken upToken = new UsernamePasswordAuthenticationToken( username, password );\n        final Authentication authentication = authenticationManager.authenticate(upToken);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        final UserDetails userDetails = userDetailsService.loadUserByUsername( username );\n        final String token = jwtTokenUtil.generateToken(userDetails);\n        return token;\n    }\n\n    // 注册\n    @Override\n    public User register( User userToAdd ) {\n        final String username = userToAdd.getUsername();\n        if( userRepository.findByUsername(username)!=null ) {\n            return null;\n        }\n        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n        final String rawPassword = userToAdd.getPassword();\n        userToAdd.setPassword( encoder.encode(rawPassword) );\n        return userRepository.save(userToAdd);\n    }\n}\n```\n\n然后是 UserService 实现类，它实现了 UserDetailsService，可用于在登录认证时检验用户的身份\n```java\n@Service\npublic class UserService implements UserDetailsService {\n    @Autowired\n    UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.findByUsername(s);\n        List<Role> roleList =userMapper.findRoleByUsername(s);\n        user.setRoles(roleList);\n        System.out.println(user.getId());\n        System.out.println(user.getUsername());\n        System.out.println(user.getPassword());\n        System.out.println(user.getAuthorities());\n        System.out.println(user.getRoles());\n        if (user == null) {\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        return user;\n    }\n}\n```\n\n## 7、Spring Security配置类编写\n\n这是比较重要的一点，这里决定了拦截的页面以及其他的一些操作。这是一个高度综合的配置类，主要是通过重写 WebSecurityConfigurerAdapter 的部分 configure 配置，来实现用户自定义的部分。\n```java\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled=true)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private UserService userService;\n\n    @Bean\n    public JwtFilter authenticationTokenFilterBean() throws Exception {\n        return new JwtFilter();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    protected void configure( AuthenticationManagerBuilder auth ) throws Exception {\n        auth.userDetailsService( userService ).passwordEncoder( new BCryptPasswordEncoder() );\n    }\n\n    @Override\n    protected void configure( HttpSecurity httpSecurity ) throws Exception {\n        httpSecurity.csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll() // OPTIONS请求全部放行\n                .antMatchers(HttpMethod.POST, \"/authentication/**\").permitAll()  //登录和注册的接口放行，其他接口全部接受验证\n                .antMatchers(HttpMethod.POST).authenticated()\n                .antMatchers(HttpMethod.PUT).authenticated()\n                .antMatchers(HttpMethod.DELETE).authenticated()\n                .antMatchers(HttpMethod.GET).authenticated();\n\n        // 使用前文自定义的 Token过滤器\n        httpSecurity\n                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);\n\n        httpSecurity.headers().cacheControl();\n    }\n}\n```\n## 8、接下来编写Controller类进行测试\n\n首先是登陆注册的类：\n```java\n@RestController\npublic class JwtAuthController {\n\n    @Autowired\n    private AuthService authService;\n\n    // 登录\n    @RequestMapping(value = \"/authentication/login\", method = RequestMethod.POST)\n    public String createToken( String username,String password ) throws AuthenticationException {\n        return authService.login( username, password );\n    }\n\n    // 注册\n    @RequestMapping(value = \"/authentication/register\", method = RequestMethod.POST)\n    public User register( @RequestBody User addedUser ) throws AuthenticationException {\n        return authService.register(addedUser);\n    }\n\n}\n```\n\n然后是测试权限的类：\n```java\n@RestController\npublic class TestController {\n\n    // 测试普通权限\n    @PreAuthorize(\"hasAuthority('ROLE_NORMAL')\")\n    @RequestMapping( value=\"/normal/test\", method = RequestMethod.GET )\n    public String test1() {\n        return \"ROLE_NORMAL /normal/test接口调用成功！\";\n    }\n\n    // 测试管理员权限\n    @PreAuthorize(\"hasAuthority('ROLE_ADMIN')\")\n    @RequestMapping( value = \"/admin/test\", method = RequestMethod.GET )\n    public String test2() {\n        return \"ROLE_ADMIN /admin/test接口调用成功！\";\n    }\n}\n```\n\n## 9、现在我们进行测试\n\n1. 首先测试能否正常登录并获取到Token![](https://z3.ax1x.com/2021/11/20/IqbGDK.png)\n可以看到在账号密码正确的情况下，能返回一个Token，接下来只要访问网页时带上这个Token，就可以顺利进行访问\n\n2. 接下来测试能否正常访问网页\n首先是不带Token的情况：\n![](https://z3.ax1x.com/2021/11/20/IqbOPJ.png)\n很明显，被拒绝访问了。\n接下来我们测试一下携带Token的情况：\n![](https://z3.ax1x.com/2021/11/20/IqxMd0.png)\n可以成功访问。\n\n","tags":["SpringSecurity","JWT"],"categories":["java","SpringSecurity","JWT"]},{"title":"我们还有必要深入学习jQuery吗","url":"/2021/11/17/2021-11-17-我们还有必要深入学习jQuery吗/","content":"\n# 我们还有必要深入学习 jQuery 吗\n\n## 表达想法\n\n前几天在某个视频平台看到一个博主的视频，该博主对于『 我们还有必要深入学习 jQuery 吗？』这个问题做出了一个很肯定的答案：就是没有必要。\n\n而他对于这个结论并也不是空穴来风，同样是做出了一系列的解释。比如说：jQuery 已经过时了、Vue.js以及React.js这样的前端框架能更好地实现jQuery所能实现的功能等等。\n\n当然，作为该博主的个人想法，评论区自然是炸开了锅，有人赞同该博主的言论，而也有人对该博主的言论表示不敢苟同。这里我说说我个人的想法：\n\n我认为 jQuery 虽然是一个多年以前的技术，但是他作为学习路上所必须经历的一段经历，我认为还是有必要进行学习的，但是也不用过度深入，在该阶段花费过多的时间。\n\njQuery 的开发模式和 Vue.js 等框架的开发模式是不同的两种开发模式，只有体会到两种开发模式的不同之处，我们才能更深入地理解如今所流行的前端框架所流行的原因，以及 jQuery 落后的原因等等。同样在若干年以后，可能会有更多新的前端框架的出现，替代现在地 vue.js、react.js 等等，到时候，经历过 vue.js 时代的我们，是不是又能从一种新的层面看到多种开发模式地区别呢？我们所了解到的是：为什么是这样子？而不是本来就是这样子。永远保持好奇与探索，对一个开发者来说是极其重要的。\n\n而对于 js ，我认为我们应该重点对原生的js进行学习，毕竟 jQuery，vue，react 这些框架都是在js的基础上进行封装的，所以说我们在使用这些框架的时候，实际上我们还是在使用 js ，但是方便就方便在这些框架的一些优秀的封装类帮我们实现了 js 中很多复杂操作，我们只要按照框架所规定的语法进行编写，就能很方便的实现 js 中一些复杂的操作，这也是为什么框架技术能够如此流行的原因之一。\n\n而我们不能只知道使用，而不知原理，这样子是走不远的，但是这并不表示我们就应该去生啃这些框架的源码，而是说我们应该学好 js 的语法，这样子在我们使用时也能很好地理解框架的原理，在使用的过程中，逐步地理解框架。\n\n## jQuery 有什么优点？\n\n抛开现在流行的 vue 等前端框架不谈，我们来说说 jQuery 时代，他都有哪些有优点。\n\n1. 能很好的操作 DOM\n有这样一个例子，如果我要修改一个元素的样式，我用原生的js是这样子完成地：\n```js\nvar dom=document.getElementById('test')\ndom.style.color='red'\n```\n而我用 jQuery 来替代上面地代码\n```js\n$('#test').css('color','red');\n```\n相对于原生的 js 来说，我们的代码精简了许多，在 jQuery 中我们用`$`来替代了原生 js 中的`document.getElementById`这一行语句，所以代码精简了许多。\n\n2. 极其方便地 ajax 操作\n在jQuery中，如果我们要使用ajax访问后台的数据，我们可以这样子实现：\n```js\n$.ajax({\n\turl:'/index',\n\tsuccess:function(res){\n\t\tconsole.log(\"请求成功\")\n\t}\n})\n```\n而如果我们要在原生的js中使用 ajax ，那别提有多复杂了，我们首先得创建一个异步对象，然后再设置请求的 url 以及参数，然后发送请求，最后我们需要将其注册到一个事件上，才能进行访问。虽然我们也能将其封装成一个可重复使用的方法，但是对于 jQuery 来说，他还是太麻烦了。\n\n3. 更方便的页面动效\n通常我们的界面需要用到一些很有趣的画面，我们在 jQuery 中可以这样子实现：\n```js\n$(\"#test\").animate({left:'100px'})\n```\n\n以上的这些操作，说实话在 js 中我们都可以实现，而 jQuery 作为一个很好的 js 框架，他所封装的很多函数可以大大方便我们的操作，所以这也就是 jQuery 为什么会流行的原因之一。我们自己也能封装一个这样的代码库，只是我们可能不能做到这么优秀，也不一定有时间和精力来做这样的工作。\n\n## MVVM 框架是怎么替代 jQuery 的？\n\n现在的 MVVM 框架，他们都引入了几个新的概念：模块化、组件化。并采用了虚拟 DOM 的方式来替代原来的 DOM 操作，在这些框架中，数据和视图实现了分离，对数据的操作不在需要引用响应的 DOM 对象，达到了编程世界中一个共同的目标——解耦。\n\n1. 针对 DOM 操作\n在 MVVM 框架中，我们基本看不到 DOM 操作的影子，是因为他们采用了一种绑定元素渲染的方式，来绑定我们的视图以及数据。比如说 vue 框架中的`v-model`。\n但是 DOM 操作不可能完全不需要，某些特殊情况还是会用到。\n\n2. 针对 ajax 操作\n在 ajax 操作方面，基本上是被 axios 这样的库给替代了，而且所实现的功能与 ajax 都差不多，而且能更好地契合这些框架。\n\n3. 针对界面动效\nCSS 3已经能很好地实现界面动态地效果。而且有很多优秀的动效库，能完美适配现在流行的框架，并能更好的实现很多好看的动效。\n\n\n## 感想\n\n可能在若干年后地某一天，又会出现更新的比现在更好的框架，那时候又会更加方便我们的使用。而我们同样要顺应时代地潮流，去学习这些新的技术，从入了编程这一行开始，我就深知这是一个需要不断学习知识，更新自己的行业，如果停止学习，就会被高速发展的互联网行业抛弃。所以这是一个很『内卷』的行业，我喜欢这种挑战，也渴望能从这种挑战中获得一个不断进步的自己。","tags":["随笔","前端"],"categories":["随笔","前端"]},{"title":"Service中包含哪些代码","url":"/2021/11/12/2021-11-12-Service中包含哪些代码/","content":"\n# Service中包含哪些代码\n\n## 1、简介\nService层中 = 核心功能(几十行 上百代码) + 额外功能(附加功能)\n1. 核心功能\n   业务运算\n   DAO调用\n2. 额外功能 \n   1. 不属于业务\n   2. 可有可无\n   3. 代码量很小 \n   \n\n以及：事务、日志、性能...\n\nService层，作为程序的业务层面，其中最重要的必然是程序的业务流程，只有对程序的业务流程有足够的了解，才能写出优秀的Service层代码。\n\n不冗余，是一个程序员代码水平的一个体现。\n\n## 2、接口\n为什么要先写接口？\n接口的作用是什么？\n\n这里我引用一句话:\n```\n接口主要用于描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。——《Java核心技术卷一》\n```\n这句话所描述的是接口的扩展性。简而言就是：接口是一个统一的插座，如果有需要我们就可以直接进行调用，实现了即插即用。\n\n例如：有一个登录功能需要我们去实现，而该系统又有多种登陆方式，我们不可能每种接口都写一个Service代码给Controller进行调用，这样是十分繁琐的。而我们将多种登陆的方式统一成一个接口，然后根据用户的需求来分配最后实际的实现类。此时对于使用者来说，他们只需要关注的是登陆这个方法，整个登陆操作变得十分灵活，根据不同的场景使用不同的方式登陆。\n\n对于开发者来说，接口中清晰地列出了所有地方法，对于后期的维护以及修改也是有极大的方便。\n\n## 3、Service之间的互相调用\n\nService层之间可以相互调用吗？\n\n这个问题相信很多人都有过思考，理论上来讲是不应该相互进行调用的，因为Service层的存在的一个很重要的目的就是 **解耦** 。\n\n将业务层的每一个业务独立出来，以至于他们之间不相互影响，能够实现代码的优化，否则多种业务的代码混在一起，长久之后谁都看不出来代码的逻辑。所以说Service层就实现了这一个很重要的功能。\n\n所以如果Service层之间的代码相互调用，是不是会是一种倒退呢？\n\n有些人可能会问，有些业务中确实是会使用到其他业务中的代码，那这部分代码怎么办？重新写？那是不可能的，这又犯了冗余这个错误。所以我们该怎么解决呢？\n\n首先，我们要清楚，这个情况是出于Service间有通用的逻辑，而不是通用的业务，每个Service对应一个业务，业务之间应该有明确的分界，不然会出现业务间的耦合，这是设计的不合理。\n\n 既然是通用的逻辑，我们是不是又可以把他们抽象出来，独立成一个工具类，当我们需要的时候直接进行调用这个工具类就可以了呢？\n\n 所以我个人认为Service层之间是不建议相互调用的。\n\n ## 4、需要向Conrtroller层展示业务吗？\n\n当我们实现一个登录功能的时候，Controller层，调用Service层，往往我以前的写法是，Service返回登录成功或者失败的代码，然后Controller进行一个判断，判断是否成功登录，然后再向前端返回信息。这样子的写法有个问题，Controller判断的一个过程，算不算是业务？如果算，是不是Controller层又接触到了业务？\n\n又回到了之前的问题，为什么要有Service层？\n\n所以说，我们应该让Controller层尽可能少的接触到业务，所以我们的写法可以优化为，再Service层做完所有业务相关的工作，最后返回给Controller层的是一个开箱即用的接口，这样子是不是可以避免Controller层接触到业务相关的代码呢？\n这就又符合了我们使用Service层的初衷了。\n\n## 5、最后\n\n在看了一些文章之后，个人的一些小小观点。","tags":["java"],"categories":["java"]},{"title":"算法学习_leetcode设计模块","url":"/2021/10/09/2021-10-09-算法学习_leetcode设计模块/","content":"\n# leetcode设计模块\n\n## 1、子矩形查询\n### 题目\n[lettcode-1476题](https://leetcode-cn.com/problems/subrectangle-queries/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FPlgH.png )\n\n### 解题思路\n按照题目的要求，我们需要根据输入的坐标，拿到该坐标的值。\n以及根据输入的两个坐标和一个值，修改两个坐标之间的值为所给出来的值。\n所以实现这两个功能首先我们需要一个二维数组。拿到坐标的值并不难。\n主要是修改两个坐标之间的值。\n因为输入的两个坐标，假如是`(1,1)`和`(3,4)` ,所以可以看出来纵坐标是修改1和4之间的值，然后横坐标是修改1，3之间的值。所以通过遍历可以遍历第一行的1-4列，第二行的1-4列一直循环下去，最终修改所有的值。\n\n### 具体代码\n```java\nclass SubrectangleQueries {\n    int[][] rectangle;\n\n    public SubrectangleQueries(int[][] rectangle) {\n        this.rectangle=rectangle;\n    }\n\n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for (int i=row1;i<=row2;i++){\n            for (int j=col1;j<=col2;j++){\n                rectangle[i][j]=newValue;\n            }\n        }\n    }\n\n    public int getValue(int row, int col) {\n        return rectangle[row][col];\n    }\n}\n```\n\n## 2、TinyURL 的加密与解密\n\n### 题目\n[lettcode-535题](https://leetcode-cn.com/problems/encode-and-decode-tinyurl/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FkmEq.png)\n\n### 解题思路\n\n为了加密 URL，我们使用计数器 (ii) ，每遇到一个新的 URL 都加一。我们将 URL 与它的次数 ii 放在哈希表 HashMap 中，这样我们在稍后的解密中可以轻易地获得原本的 URL\n\n### 具体代码\n```java\npublic class Codec {\n\n    Map<Integer, String> map = new HashMap<>();\n    int i = 0;\n\n    // Encodes a URL to a shortened URL.\n    public String encode(String longUrl) {\n        map.put(i,longUrl);\n        return \"http://tinyurl.com/\" + i++;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n```\n\n## 3、二叉搜索树迭代器\n\n### 题目\n[lettcode-173题](https://leetcode-cn.com/problems/binary-search-tree-iterator/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FAJSS.png)\n\n### 解题思路\n\n二叉树，我们可以使用一个TreeNode来实现，其中我们将遍历到的值错放到一个list集合中去。\n二叉树的中序遍历，遍历顺序是：左节点-中节点-右节点。\n所以我们在方法中输入一个二叉树，重复进行遍历，即可得到最后中序遍历的结果。\n\n### 具体代码\n```java\nclass BSTIterator {\n\n    private int index;\n    private List<Integer> arr;\n\n    public BSTIterator(TreeNode root) {\n        index = 0;\n        arr = new ArrayList<Integer>();\n        inorderTraversal(root, arr);\n    }\n\n    public int next() {\n        return arr.get(index++);\n    }\n\n    public boolean hasNext() {\n        return index < arr.size();\n    }\n\n    private void inorderTraversal(TreeNode root, List<Integer> arr) {\n        if (root == null) {\n            return;\n        }\n        //实现中序遍历 左-中-右\n        inorderTraversal(root.left, arr);\n        arr.add(root.val);\n        inorderTraversal(root.right, arr);\n    }\n}\n```\n\n## 4、设计一个支持增量操作的栈\n\n### 题目\n[lettcode-1381题](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5F35b6.png)\n\n### 解题思路\n\n题目要求这个栈需要有一个最大数量，所以我们需要定义一个变量来限制栈的大小。\n如果没有达到最大数量，就将新元素添加到栈的顶端，否则就不允许添加。\n当删除栈中元素的时候，首先删除栈顶端的元素，如果栈中没有东西，就返回一个 -1\n更新栈中的元素的时候首先判断栈中的数量与输入的k的大小关系，如果k大，就将栈中元素数量作为更新的数量，由于index是由0开始的，所以数量就是index+1，否则就是以k作为数量。\n\n### 具体代码\n```java\nclass CustomStack {\n\n\n    int maxSize;\n    int[] myStack=null;\n    int head=-1;\n    public CustomStack(int maxSize) {\n        myStack=new int[maxSize];\n        this.maxSize=maxSize;\n    }\n\n    public void push(int x) {\n        if (head==myStack.length-1){\n            return;\n        }else {\n            myStack[++head]=x;\n        }\n    }\n\n    public int pop() {\n        if (head==-1){\n            return -1;\n        }else{\n            return myStack[head--];\n        }\n    }\n\n    public void increment(int k, int val) {\n        int min;\n        if (head<k){\n            min=head+1;\n        }else{\n            min=k;\n        }\n        for (int i=0;i<min;i++){\n            myStack[i]+=val;\n        }\n    }\n}\n```\n\n## 5、在受污染的二叉树中查找元素\n\n### 题目\n[lettcode-1261题](https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FJsVP.png)\n\n### 解题思路\n\n通过题目我们可以看出，根节点的左子树是2x+1，右子树是2x+2，所以以此类推下去，就能还原出二叉树。\n首先得判断是否有子节点。\n然后如果一个节点没有父子树，就说明他是根节点，就将他设为0\n\n### 具体代码\n\n```java\nclass FindElements {\n\n    Set<Integer> set=new HashSet<>();\n\n    public FindElements(TreeNode root) {\n        rebuildTree(root, null);\n    }\n\n    public boolean find(int target) {\n        // 判断 Set 集合是否包含指定的对象\n        return set.contains(target);\n    }\n    private void rebuildTree(TreeNode root, TreeNode parent) {\n        if (root == null) {\n            return;\n        }\n        // 如果没有父节点，就设为0\n        // 否则就执行下面的条件\n        if (parent == null) {\n            root.val = 0;\n        } else {\n            root.val = root == parent.left ?\n                    (parent.val << 1) + 1 : (parent.val << 1) + 2;\n        }\n        // 将结果添加到set中\n        set.add(root.val);\n        // 重复执行上面的内容\n        rebuildTree(root.left, root);\n        rebuildTree(root.right, root);\n\n    }\n}\n```\n\n## 6、扁平化嵌套列表迭代器\n### 题目\n[lettcode-341题](https://leetcode-cn.com/problems/flatten-nested-list-iterator/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5Faz40.png)\n\n### 解题思路\n\n从题目上看，题目所输入的数据就是一个嵌套的数组，一个数组中可以存放整数，也可以存放一个新的数组。\n而当我们进行遍历时需要先遍历完一个数组，然后再遍历后面的数组，相当于把多个数组中的值给摊开成一个只有整数的数组。\n所以我们在遍历时，将遍历的方法抽成一个独立的方法。如果碰到嵌套数组，我们就再次对遍历的方法进行调用，依次重复多次，就可以实现对多个嵌套数组的遍历。\n\n### 具体代码\n```java\npublic class NestedIterator implements Iterator<Integer> {\n\n    List<Integer> list = new ArrayList<>();\n    int index=0;\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        add(nestedList);\n    }\n\n    private void add(List<NestedInteger> nestedList) {\n        for (NestedInteger nestedInteger : nestedList) {\n            if (nestedInteger.isInteger()) {\n                list.add(nestedInteger.getInteger());\n            } else {\n                //重新遍历嵌套的数组\n                add(nestedInteger.getList());\n            }\n        }\n    }\n\n    @Override\n    public Integer next() {\n        return list.get(index++);\n    }\n\n    @Override\n    public boolean hasNext() {\n        return index<list.size();\n    }\n}\n```\n\n## 7、实现 Trie (前缀树)\n### 题目\n[lettcode-208题](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FBvsU.png)\n\n### 解题思路\n\n前缀树，又叫做字典树。通过阅读题目，这一题我们可以用List数组来实现。\n其中添加元素可以用add方法来实现，而contains方法可以用来判断数组中书否有该元素。\nstartsWith方法即可用用于判断数组中的元素是否包含某一个值。\n\n### 具体代码\n```java\npublic class Trie {\n\n    private List<String> list;\n    private int index = 0;\n\n    public Trie() {\n        list = new ArrayList<>();\n    }\n\n    public void insert(String word) {\n        list.add(word);\n    }\n\n    public boolean search(String word) {\n        if (list.contains(word)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean startsWith(String prefix) {\n        for (String lists:list){\n            if (lists.startsWith(prefix)){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 8、皇位继承顺序\n### 题目\n[lettcode-1600题](https://leetcode-cn.com/problems/throne-inheritance/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FyFWn.png)\n\n### 解题思路\n\n这题一开始读起来有点晦涩难懂，和后面读起来其实就是类似于我国古代的世袭机制。\n首先是皇帝，然后长子次子，但是长子之后的皇帝应该是长子的后代，如果长子没有后代了，皇帝才会传给次子。类似这样子循环下去。\n然后我们需要每个人有一个列表来存储他的后代们。所以可以使用HashMap来实现这一功能。\n然后该Map的键是String类型，值是一个list类型。所以比如说皇帝A，他的A就是键，他的后代就构成了Map的值list。\n死亡人员我们可以用一个Set来实现，因为他是不可重复的，一个人也不可能死很多次，所以我们将死亡的人员放到其中。\n最后是排序。首先判断在set中的人员，将他们删除，然后循环遍历List中的值。首先我们输入皇帝的名字，然后就会遍历皇帝的后代，遍历到皇帝的第一个后代，又会遍历到他的第一个后代的后代，一直到完，就是深度优先遍历。\n所以我们可以将便利的代码抽成一个独立的方法，以供重复进行调用，实现这个功能。\n\n### 具体代码\n```java\npublic class ThroneInheritance {\n\n    private String kingName;\n    private Map<String, List<String>> map = new HashMap<>();\n    //不可重复\n    private Set<String> deathSet = new HashSet<>();\n\n    public ThroneInheritance(String kingName) {\n        this.kingName=kingName;\n        map.put(kingName,new ArrayList<>());\n    }\n\n    public void birth(String parentName, String childName) {\n        map.get(parentName).add(childName);\n        map.put(childName,new ArrayList<>());\n    }   \n\n    public void death(String name) {\n        deathSet.add(name);\n    }\n\n    public List<String> getInheritanceOrder() {\n        List<String> list=new ArrayList<>();\n        add(list,kingName);\n        return list;\n    }\n\n    public void add(List<String> list, String name){\n        if (!deathSet.contains(name)){\n            list.add(name);\n        }\n        //遍历该人物的子孙\n        for (String names:map.get(name)){\n            add(list,names);\n        }\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"RabbitMQ入门使用","url":"/2021/10/06/2021-10-06-RabbitMQ入门使用/","content":"\n# RabbitMQ入门使用\n\n## 1、同步、异步通信\n\n我们服务之间的通信，一般分为同步和异步两种方式。\n\n**同步**就是：当两个服务间通信时，必须要每一步按照顺序进行之后再进行下一步的内容。看上去同步可以立即得到结果，好像很好。但是这样的通信方式往往就会产生一些问题。\n1. 耦合度较高。当我们加入新的需求时，需要修改很多的代码。\n2. 性能不好。因为每次都要等待上一个服务完成，所以会消耗很多时间，导致性能下降.\n3. 资源浪费。在等待服务完成的时候，不能释放资源，也不能做事情，就导致了资源的浪费。\n4. 级联失败。如果服务调用过程中一个环节出现错误，就会导致其他环节跟着出现错误。就像是多米诺骨牌一样。\n\n**异步**就是：当两个服务间通信时，A将资料传给B的时候，就可以继续去做自己的事情，而不用一直等待B传送消息回来，在B有空的时候处理就可以。同时，异步通信解决了一些同步通信存在的问题：`耦合度低`，`吞吐量提升`，`故障隔离` ，`流量削峰`。\n但是同时也带来了一些新的问题：\n1. 依赖于Broker的可靠性、安全性、吞吐能力\n2. 架构复杂了，业务没有明显的流程线，不好追踪管理\n\n所以我们在使用的时候，应该根据实际情况来使用异步或者同步通信。\n\n## 2、消息队列（MQ）简介\n\nMQ （MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。\n\n消息队列中间件是分布式系统中重要的组件，主要解决应用耦合、异步消息、流量削锋等问题。实现高性能、高可用、可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n### 2.1、常见的MQ\n以下就是四种我们常用的MQ以及它们之间的对比：\n![](https://i.bmp.ovh/imgs/2021/10/6d1e83477fe9a9c8.png)\n\n接下来我们就以RabbitMQ来作为我们学习的工具。\n\n### 2.2、RabbitMQ介绍以及安装\n\nRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/\n\n由于它是基于Erlang语言开发的，所以我们必须安装Erlang语言的开发环境。\n为了省时间，我们这里直接在Dockers里面进行安装并做一个映射。\n步骤如下：\n\n1. 下载RabbitMQ的镜像\n```shell\ndocker pull rabbitmq:3-management\n```\n2. 安装mq\n```shell\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=chenyicai \\\n -e RABBITMQ_DEFAULT_PASS=123456 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d \\\n rabbitmq:3-management\n```\n然后我们的RabbitMQ就安装完成了，现在我们可以在浏览器输入服务器地址+15672进入RabbitMQ的控制台\n![](https://i.bmp.ovh/imgs/2021/10/d864df3d43bd58c4.png)\n账号密码就是我们前面设置好的`chenyicai`和`123456`\n登录之后：\n![](https://i.bmp.ovh/imgs/2021/10/9079fb7ec4d8d3db.png)\n\n以下是RabbitMQ中的几个基本概念：\n\n- channel：操作MQ的工具\n- exchange：路由消息到队列中\n- queue：缓存消息\n- virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组\n\n## 3、常见的消息模型\n\n### 3.1、官方给出的消息模型\n\n官方一共给出的五个MQ的Demo，分别对应了几种不同的用法：\n1. 基本消息队列（BasicQueue）\n2. 工作消息队列（WorkQueue）\n3. 发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：\n\t1. Fanout Exchange：广播\n\t2. Direct Exchange：路由\n\t3. Topic Exchange：主题\n\n![](https://i.bmp.ovh/imgs/2021/10/6e351b659680b5ee.png)\n![](https://i.bmp.ovh/imgs/2021/10/830978c3cd4ea8dc.png)\n\n### 3.2、Hello World\n\n现在我们就在SpringBoot里面实现以下官方示例中的Hello World这个例子。\n官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：\n1. publisher：消息发布者，将消息发送到队列queue\n2. queue：消息队列，负责接受并缓存消息\n3. consumer：订阅队列，处理队列中的消息\n\n所以我们实现这个例子的步骤如下：\n基本消息队列的消息发送流程：\n1. 建立connection\n```java\nConnectionFactory factory = new ConnectionFactory();\n//设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\nfactory.setHost(\"8.129.212.155\");\nfactory.setPort(5672);\nfactory.setVirtualHost(\"/\");\nfactory.setUsername(\"chenyicai\");\nfactory.setPassword(\"123456\");\n//建立连接\nConnection connection = factory.newConnection();\n```\n2. 创建通道channel\n```java\nChannel channel = connection.createChannel();\n```\n3. 利用channel声明队列\n```java\n//队列名\nString queueName = \"simple.queue\";\n//队列的属性\nchannel.queueDeclare(queueName, false, false, false, null);\n```\n4. 利用channel向队列发送消息\n```java\nString message = \"hello, rabbitmq!\";\nchannel.basicPublish(\"\", queueName, null, message.getBytes());\nSystem.out.println(\"发送消息成功：【\" + message + \"】\");\n```\n\n基本消息队列的消息接收流程：\n1. 建立connection\n2. 创建通道channel\n3. 利用channel声明队列\n4. 定义consumer的消费行为handleDelivery()\n利用channel将消费者与队列绑定\n```java\nchannel.basicConsume(queueName, true, new DefaultConsumer(channel){\n\t@Override\n\tpublic void handleDelivery(String consumerTag, Envelope envelope,\n             AMQP.BasicProperties properties, byte[] body) throws IOException {\n\t// 5.处理消息\n\tString message = new String(body);\n\tSystem.out.println(\"接收到消息：【\" + message + \"】\");\n\t}\t\n});\nSystem.out.println(\"等待接收消息。。。。\");\n```\n\n\n很显然如果每次使用消息队列都这样开关连接，那么是非常不好的一种现象，所以我们接下来就要使用Spring的一个框架，来更好地帮助我们对消息队列进行使用。\n\n##  4、SpringAMQP\n\n### 4.1、什么是SpringAMQP\n\nSpringAmqp的官方地址：https://spring.io/projects/spring-amqp\n![](https://i.bmp.ovh/imgs/2021/10/a347fedc49140107.png)\n\nAMQP：是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。\n\nSpringAMQP：是基于AMQP协议定义的一套API规范，提供了模板来发送和接受消息。包含两部分，其中Spring-AMQP是基础抽象，Spring-rabbit是底层的默认实现。\n\n### 4.2、SpringAMQP实现Hello World\n\nSpring中已经集成了AMQP的依赖，所以我们只需要引入依赖就可以实现自动注入，具体步骤如下：\n1. 引入SpringAMQP的依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n2. 在publisher中编写一个yml配置文件，添加mq连接的信息\n```yaml\nspring:\n  rabbitmq:\n    host: 8.129.212.155 # rabbitMQ的ip地址\n    port: 5672 # 端口\n    username: chenyicai\n    password: 123456\n    virtual-host: /\n```\n3. 在publisher服务中新建一个测试类，编写测试方法发送消息：\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAmqpTest {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSendMessage2SimpleQueue() {\n        String queueName = \"simple.queue\";\n        String message = \"hello, spring amqp!\";\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n```\n如果此时我们没有接受信息，信息就会存在mq的缓存区里面，如下:\n![](https://i.bmp.ovh/imgs/2021/10/7fff7b4306ad9074.png)\n![](https://i.bmp.ovh/imgs/2021/10/77dd30c482f123d4.png)\n4. 在consumer中接受消息（consumer中也要创建连接配置文件）\n```java\n@Component\npublic class SpringRabbitListener {\n\t@RabbitListener(queues = \"simple.queue\")\n    public void listenSimpleQueue(String msg) {\n        System.out.println(\"消费者接收到simple.queue的消息：【\" + msg + \"】\");\n    }\n}\n```\n现在我们就完成了一个Hello World的例子的实现。\n结果如下：\n![](https://i.bmp.ovh/imgs/2021/10/6d5247dea94d40d9.png)\n消息队列是阅后即焚的，是一个不可逆的过程。\n现在我们看看剩下的几个例子。\n\n### 4.3、Work Queue 工作队列\n工作队列，可以提高消息处理速度，避免队列消息堆积\n他的逻辑图如下：\n![](https://i.bmp.ovh/imgs/2021/10/71a3d073f2914be1.png)\n\n现在我们要来实现一个工作队列\n1. 在publisher服务中添加一个测试方法，循环发送50条消息到simple.queue队列\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAmqpTest {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSendMessage2WorkQueue() throws InterruptedException {\n        String queueName = \"simple.queue\";\n        String message = \"hello, message__\";\n        for (int i = 1; i <= 50; i++) {\n            rabbitTemplate.convertAndSend(queueName, message + i);\n            Thread.sleep(20);\n        }\n    }\n}\n```\n2. 在consumer服务中添加一个消费者，也监听simple.queue：\n```java\n@Component\npublic class SpringRabbitListener {\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenWorkQueue1(String msg) throws InterruptedException {\n        System.out.println(\"消费者1接收到消息：【\" + msg + \"】\" + LocalTime.now());\n        Thread.sleep(20);\n    }\n\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenWorkQueue2(String msg) throws InterruptedException {\n        System.err.println(\"消费者2........接收到消息：【\" + msg + \"】\" + LocalTime.now());\n        Thread.sleep(200);\n    }\n}\n```\n3. 然后我们修改yml配置文件，添加以下内容\n```yaml\nspring:\n  rabbitmq:\n    listener:\n      simple:\n        prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息\n```\n4. 然后我们进行测试，结果如下\n![](https://z3.ax1x.com/2021/10/06/5SSH0J.png)\n\n两个消费者就会交替获取信息，而睡眠20毫秒的用户会比睡眠200毫秒的用户获取更多的信息。\n\n### 4.4、发布（ Publish ）、订阅（ Subscribe ）\n\n发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）。\n常见exchange类型包括：\n\n- Fanout：广播\n- Direct：路由\n- Topic：话题\n\n![](https://z3.ax1x.com/2021/10/06/5SpKBQ.png)\n\n**注意**：exchange负责消息路由，而不是存储，路由失败则消息丢失\n\n#### 4.4.1、发布订阅-Fanout Exchange\n`Fanout Exchange` 会将接收到的消息广播到每一个跟其绑定的queue\n\n具体实现步骤如下：\n1. 在`consumer`服务声明`Exchange`、`Queue`、`Binding`\n在`consumer`服务常见一个类，添加`@Configuration` 注解，并声明`FanoutExchange`、`Queue`和绑定关系对象`Binding`\n```java\n@Configuration\npublic class FanoutConfig {\n    // itcast.fanout\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"itcast.fanout\");\n    }\n\n    // fanout.queue1\n    @Bean\n    public Queue fanoutQueue1(){\n        return new Queue(\"fanout.queue1\");\n    }\n\n    // 绑定队列1到交换机\n    @Bean\n    public Binding fanoutBinding1(Queue fanoutQueue1, FanoutExchange fanoutExchange){\n        return BindingBuilder\n                .bind(fanoutQueue1)\n                .to(fanoutExchange);\n    }\n\n    // fanout.queue2\n    @Bean\n    public Queue fanoutQueue2(){\n        return new Queue(\"fanout.queue2\");\n    }\n\n    // 绑定队列2到交换机\n    @Bean\n    public Binding fanoutBinding2(Queue fanoutQueue2, FanoutExchange fanoutExchange){\n        return BindingBuilder\n                .bind(fanoutQueue2)\n                .to(fanoutExchange);\n    }\n}\n```\n2. 在`consumer`服务的`SpringRabbitListener`类中，添加两个方法，分别监听`fanout.queue1`和`fanout.queue2`\n```java\n@Component\npublic class SpringRabbitListener {\n    @RabbitListener(queues = \"fanout.queue1\")\n    public void listenFanoutQueue1(String msg) {\n        System.out.println(\"消费者接收到fanout.queue1的消息：【\" + msg + \"】\");\n    }\n    @RabbitListener(queues = \"fanout.queue2\")\n    public void listenFanoutQueue2(String msg) {\n        System.out.println(\"消费者接收到fanout.queue2的消息：【\" + msg + \"】\");\n    }\n}\n```\n3. 在`publisher`服务发送消息到`FanoutExchange`\n```java\n\t@Test\n    public void testSendFanoutExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.fanout\";\n        // 消息\n        String message = \"hello, every one!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"\", message);\n    }\n```\n4. 测试，此时两个消费者都会受到这条消息\n![](https://z3.ax1x.com/2021/10/06/5S9Va9.png)\n\n#### 4.4.2、发布订阅-DirectExchange\n\n`Direct Exchange` 会将接收到的消息根据规则路由到指定的`Queue`，因此称为路由模式（routes）。\n\n- 每一个`Queue`都与`Exchange`设置一个`BindingKey`\n- 发布者发送消息时，指定消息的`RoutingKey`\n- `Exchange`将消息路由到`BindingKey`与消息`RoutingKey`一致的队列\n![](https://z3.ax1x.com/2021/10/06/5S9KxK.png)\n\n具体实现步骤如下：\n1. 在`consumer`服务中，编写两个消费者方法，分别监听`direct.queue1`和`direct.queue2`。并利用`@RabbitListener`声明`Exchange`、`Queue`、`RoutingKey`\n\n```java\n\t@RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"direct.queue1\"),\n            exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT),\n            key = {\"red\", \"blue\"}\n    ))\n    public void listenDirectQueue1(String msg){\n        System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"direct.queue2\"),\n            exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT),\n            key = {\"red\", \"yellow\"}\n    ))\n    public void listenDirectQueue2(String msg){\n        System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");\n    }\n```\n\n2. 在`publisher`服务发送消息到`DirectExchange`\n```java\n\t@Test\n    public void testSendDirectExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.direct\";\n        // 消息\n        String message = \"hello, red!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"red\", message);\n    }\n```\n\n测试如下：\n![](https://z3.ax1x.com/2021/10/07/5S9Lz6.png)\n两个都能收到`red`的消息，而我们现在换一种发送消息的方式看看，发送一个`blue`的消息，按照规定`direct.queue2`应该是没有消息的。\n![](https://z3.ax1x.com/2021/10/07/5SCkSP.png)\n确实是这个样子。\n\n#### 4.4.3、发布订阅-TopicExchange\n\n`TopicExchange`与`DirectExchange`类似，区别在于`routingKey`必须是多个单词的列表，并且以 `. `分割。\n`Queue`与`Exchange`指定`BindingKey`时可以使用通配符：\n\n- #：代指0个或多个单词\n- *：代指一个单词\n\n![](https://z3.ax1x.com/2021/10/07/5SCQWq.png)\n\n实现步骤如下：\n1. 在`consumer`服务中，编写两个消费者方法，分别监听`topic.queue1`和`topic.queue2`。\n并利用`@RabbitListener`声明`Exchange`、`Queue`、`RoutingKey`\n```java\n\t@RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"topic.queue1\"),\n            exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC),\n            key = \"china.#\"\n    ))\n    public void listenTopicQueue1(String msg){\n        System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"topic.queue2\"),\n            exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC),\n            key = \"#.news\"\n    ))\n    public void listenTopicQueue2(String msg){\n        System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");\n    }\n```\n2. 在`publisher`服务发送消息到`TopicExchange`\n```java\n\t@Test\n    public void testSendTopicExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.topic\";\n        // 消息\n        String message = \"中国新闻\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);\n    }\n```\n\n进行测试，此时两个消费者都能接收到消息\n![](https://z3.ax1x.com/2021/10/07/5SCc0e.png)\n\n如果修改`key`的值，后面不为`news`时，`topic.queue2`将无法收到消息\n```java\n@Test\n    public void testSendTopicExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.topic\";\n        // 消息\n        String message = \"中国新闻,一条\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"china.new\", message);\n    }\n```\n结果如下：\n![](https://z3.ax1x.com/2021/10/07/5SCI6f.png)\n\n\n\n### 4.5、SpringAMQP-消息转换器\n\n在`SpringAMQP`的发送方法中，接收消息的类型是`Object`，也就是说我们可以发送任意对象类型的消息，`SpringAMQP`会帮我们序列化为字节后发送。\n\n我们在`consumer`中利用`@Bean`声明一个队列：\n```java\n@Configuration\npublic class FanoutConfig {\n    @Bean\n    public Queue objectQueue(){\n        return new Queue(\"object.queue\");\n    }\n}\n```\n在`publisher`中发送消息以测试:\n```java\n\t@Test\n    public void testSendMap() throws InterruptedException {\n        // 准备消息    \n        Map<String,Object> msg = new HashMap<>();    \n        msg.put(\"name\", \"Jack\");    \n        msg.put(\"age\", 21);\n        // 发送消息 \n        rabbitTemplate.convertAndSend(\"object.queue\", msg);\n    }\n```\n会发现在消息队列中我们传过去的是一堆乱码\n![](https://z3.ax1x.com/2021/10/07/5SP6g0.png)\n\n其实就是`java`将我们的消息进行了一个序列化来进行传输，但是这样子十分不具有可读性，而且字符串较长，会影响到传输的效率。\n\n`Spring`的对消息对象的处理是由`org.springframework.amqp.support.converter.MessageConverter`来处理的。而默认实现是`SimpleMessageConverter`，基于`JDK`的`ObjectOutputStream`完成序列化。\n如果要修改只需要定义一个`MessageConverter` 类型的`Bean`即可。推荐用`JSON`方式序列化，步骤如下：\n\n1. 首先我们需要引入json的依赖\n```xml\n<dependency>\n\t<groupId>com.fasterxml.jackson.core</groupId>\n\t<artifactId>jackson-databind</artifactId>\n</dependency>\n```\n2. publisher服务声明MessageConverter（可以放在启动类上）\n```java\n\t@Bean\n    public MessageConverter messageConverter(){\n        return new Jackson2JsonMessageConverter();\n    }\n```\n然后我们进行测试\n![](https://z3.ax1x.com/2021/10/07/5SiFr8.png)\n\n此时显示的消息就很有可读性了。\n\n\n\n## 5、总结\n\n以上就是我对RabbirMQ入门学习的一个总结，还有很多的内容需要去学习，以后学到了会继续补充。s","tags":["java","消息队列"],"categories":["java","消息队列"]},{"title":"Swagger3入门使用","url":"/2021/10/05/2021-10-05-Swagger3入门使用/","content":"\n# Swagger3入门使用\n\n## 1、Swagger3简介\n\nSwagger 是一套基于 OpenAPI 规范（OpenAPI Specification，OAS）构建的开源工具，后来成为了 Open API 标准的主要定义者。\n对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证API 文档的及时性将有很大的帮助。\n\n**swagger2于17年停止维护，现在最新的版本为17年发布的 Swagger3（Open Api3）**\n\n## 2. Swagger3与Swagger2.x比较\n\n- 应用主类添加注解@EnableOpenApi (swagger2是@EnableSwagger2)\n- swagger配置类SwaggerProperties.class，与swagger2.xx 版本有差异，具体看下文\n- 自定义一个配置类 SwaggerConfiguration.class,看下文\n- 访问地址：http://localhost:8080/swagger-ui/index.html (swagger2.xx版本访问的地址为http://localhost:8080/swagger-ui.html)\n\n## 3、SpringBoot整合Swagger3\n\n### 3.1、引入依赖\n```xml\n<dependency>\n\t<groupId>io.springfox</groupId>\n\t<artifactId>springfox-boot-starter</artifactId>\n\t<version>3.0.0</version>\n</dependency>\n```\n\n### 3.2、在Controller类上添加注解\n\nSwagger通过几个注解，就能实现api的添加。\n\n`@Api` ：用在controller类，描述API接口\n`@EnableOpenApi` :表示开启SwaggerApi\n`@ApiOperation` ：描述接口方法\n`@ApiModel` ：描述对象\n`@ApiModelProperty` ：描述对象属性\n`@ApiImplicitParams`  ：描述接口参数\n`@ApiResponses` ：描述接口响应\n`@ApiIgnore` ：忽略接口方法\n`@ApiParam` ：为 Rest 接口参数添加其它元数据\n\n如下所示：\n```java\n@EnableOpenApi // 也可以不写此注解\n@Api(description=\"讲师管理\")\n@RestController\n@RequestMapping(\"/admin/edu/teacher\")\n\npublic class MyController {\n\n    @Autowired\n    private TeacherService teacherService;\n\n    @ApiOperation(value = \"所有讲师列表\")\n    @GetMapping\n    public List<Teacher> list(){\n        return teacherService.list();\n    }\n\n    @ApiOperation(value = \"根据ID删除讲师\")\n    @DeleteMapping(\"{id}\")\n    public boolean removeById(\n            @ApiParam(name = \"id\", value = \"讲师ID\", required = true)\n            @PathVariable String id){\n        return teacherService.removeById(id);\n    }\n\n    @ApiOperation(value = \"查询某个讲师\")\n    @GetMapping(\"/setlct/{id}\")\n    public Teacher teacher(@ApiParam(name = \"id\", value = \"讲师ID\", required = true) @PathVariable String id){\n        return teacherService.teacher(id);\n    }\n}\n```\n\n### 3.3、自定义一个配置类SwaggerProperties.class\n\n```java\n@Component\n@ConfigurationProperties(\"swagger\")\npublic class SwaggerProperties {\n    /**\n     * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量\n     */\n    private Boolean enable;\n    \n    /**\n     * 项目应用名\n     */\n    private String applicationName;\n\n    /**\n     * 项目版本信息\n     */\n    private String applicationVersion;\n\n    /**\n     * 项目描述信息\n     */\n    private String applicationDescription;\n\n    /**\n     * 接口调试地址\n     */\n    private String tryHost;\n\n    public Boolean getEnable() {\n        return enable;\n    }\n\n    public void setEnable(Boolean enable) {\n        this.enable = enable;\n    }\n\n    public String getApplicationName() {\n        return applicationName;\n    }\n\n    public void setApplicationName(String applicationName) {\n        this.applicationName = applicationName;\n    }\n\n    public String getApplicationVersion() {\n        return applicationVersion;\n    }\n\n    public void setApplicationVersion(String applicationVersion) {\n        this.applicationVersion = applicationVersion;\n    }\n\n    public String getApplicationDescription() {\n        return applicationDescription;\n    }\n\n    public void setApplicationDescription(String applicationDescription) {\n        this.applicationDescription = applicationDescription;\n    }\n\n    public String getTryHost() {\n        return tryHost;\n    }\n\n    public void setTryHost(String tryHost) {\n        this.tryHost = tryHost;\n    }\n}\n```\n\n### 3.4、自定义springfox swagger3配置类SwaggerConfiguration.class\n\n```java\nimport io.swagger.models.auth.In;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.springframework.boot.SpringBootVersion;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.oas.annotations.EnableOpenApi;\nimport springfox.documentation.service.*;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spi.service.contexts.SecurityContext;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\n@Configuration\npublic class SwaggerConfiguration implements WebMvcConfigurer {\n    private final SwaggerProperties swaggerProperties;\n\n    public SwaggerConfiguration(SwaggerProperties swaggerProperties) {\n        this.swaggerProperties = swaggerProperties;\n    }\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.OAS_30).pathMapping(\"/\")\n\n                // 定义是否开启swagger，false为关闭，可以通过变量控制\n                .enable(swaggerProperties.getEnable())\n\n                // 将api的元信息设置为包含在json ResourceListing响应中。 \n                .apiInfo(apiInfo())\n\n                // 接口调试地址\n                .host(swaggerProperties.getTryHost())\n\n                // 选择哪些接口作为swagger的doc发布\n                .select()\n                .apis(RequestHandlerSelectors.any())\n                .paths(PathSelectors.any())\n                .build()\n\n                // 支持的通讯协议集合\n                .protocols(newHashSet(\"https\", \"http\"))\n\n                // 授权信息设置，必要的header token等认证信息\n                .securitySchemes(securitySchemes())\n\n                // 授权信息全局应用\n                .securityContexts(securityContexts());\n    }\n\n    /**\n     * API 页面上半部分展示信息\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder().title(swaggerProperties.getApplicationName() + \" Api Doc\")\n                .description(swaggerProperties.getApplicationDescription())\n                .contact(new Contact(\"lighter\", null, \"123456@gmail.com\"))\n                .version(\"Application Version: \" + swaggerProperties.getApplicationVersion() + \", Spring Boot Version: \" + SpringBootVersion.getVersion())\n                .build();\n    }\n\n    /**\n     * 设置授权信息\n     */\n    private List<SecurityScheme> securitySchemes() {\n        ApiKey apiKey = new ApiKey(\"BASE_TOKEN\", \"token\", In.HEADER.toValue());\n        return Collections.singletonList(apiKey);\n    }\n\n    /**\n     * 授权信息全局应用\n     */\n    private List<SecurityContext> securityContexts() {\n        return Collections.singletonList(\n                SecurityContext.builder()\n                        .securityReferences(Collections.singletonList(new SecurityReference(\"BASE_TOKEN\", new AuthorizationScope[]{new AuthorizationScope(\"global\", \"\")})))\n                        .build()\n        );\n    }\n\n    @SafeVarargs\n    private final <T> Set<T> newHashSet(T... ts) {\n        if (ts.length > 0) {\n            return new LinkedHashSet<>(Arrays.asList(ts));\n        }\n        return null;\n    }\n\n    /**\n     * 通用拦截器排除swagger设置，所有拦截器都会自动加swagger相关的资源排除信息\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        try {\n            Field registrationsField = FieldUtils.getField(InterceptorRegistry.class, \"registrations\", true);\n            List<InterceptorRegistration> registrations = (List<InterceptorRegistration>) ReflectionUtils.getField(registrationsField, registry);\n            if (registrations != null) {\n                for (InterceptorRegistration interceptorRegistration : registrations) {\n                    interceptorRegistration\n                            .excludePathPatterns(\"/swagger**/**\")\n                            .excludePathPatterns(\"/webjars/**\")\n                            .excludePathPatterns(\"/v3/**\")\n                            .excludePathPatterns(\"/doc.html\");\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n## 4、测试\n\n完成上述的编写之后可以打开下面的地址查看是否成功创建\n```\nhttp://localhost:8080/swagger-ui/index.html\n```\n\n成功显示如下![](https://z3.ax1x.com/2021/10/05/4jUGVJ.png)\n\n![](https://z3.ax1x.com/2021/10/05/4jUa26.png)","tags":["java","Swagger"],"categories":["java","Swagger"]},{"title":"算法学习_最小栈","url":"/2021/10/04/2021-10-04-算法学习_最小栈/","content":"\n# 最小栈\n\n## 题目\n[lettcode-155题](https://leetcode-cn.com/problems/min-stack/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/874db5e3352e9d73.png )\n\n\n## 解题思路\n题目基本上就是要求找出一个栈中最小的值，通过java中内置的栈的方法即可实现这一目标\n\n首先我的想法是通过遍历比较所有的值来找出最小的那个值，但是这样子消耗了较多的时间，而且题目希望是设计一种栈的结构，而不是直接用栈的方法。\n\n所以后面换了一种新的方法，就是使用链表来实现，这样子的效率是较高的，相比于之前的方法，用时整整少了200多毫秒![](https://i.bmp.ovh/imgs/2021/10/677ed412598a9dc4.png)\n\n具体实现方式如下\n\n\n## 具体代码(第一种思路)\n```java\nclass MinStack {\n\n    Stack<Integer> stack;\n    public MinStack() {\n        stack = new Stack<Integer>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n    }\n\n    public void pop() {\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        int min=stack.get(0);;\n        for (int i=0;i<stack.size();i++){\n            if (stack.get(i)<min){\n                min=stack.get(i);\n            }\n        }\n        return min;\n    }\n}\n\n```\n\n## 具体代码(第二种思路)\n\n```java\nclass MinStack {\n\n    private Node head;\n    \n    public void push(int x) {\n        if(head == null) \n            head = new Node(x, x);\n        else \n            head = new Node(x, Math.min(x, head.min), head);\n    }\n\n    public void pop() {\n        head = head.next;\n    }\n\n    public int top() {\n        return head.val;\n    }\n\n    public int getMin() {\n        return head.min;\n    }\n    \n    private class Node {\n        int val;\n        int min;\n        Node next;\n        \n        private Node(int val, int min) {\n            this(val, min, null);\n        }\n        \n        private Node(int val, int min, Node next) {\n            this.val = val;\n            this.min = min;\n            this.next = next;\n        }\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"算法学习_设计hash集合、hash映射","url":"/2021/10/03/2021-10-03-算法学习_设计hash集合、hash映射/","content":"\n# 设计hash集合、hash映射\n\n## 题目1\n[lettcode-705题](https://leetcode-cn.com/problems/design-hashset/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/40b4bcb17c130bf0.png )\n\n\n## 解题思路\n既然说是一个HashSet，所以他就是一个不可重复的集合，就意味着在该集合中每个元素只能出现一次。\n\n所以说我们就可以用boolean类型的数组来模拟出这样的一个集合\n\n数组的索引就对应了set的key，数组所对应的布尔值就是set的value，当其为true1时就说明存在，否则就是不存在\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass MyHashSet {\n\n    //创建一个boolean类型的数组\n    boolean[] map=null;\n    public MyHashSet() {\n        map=new boolean[1000001];\n    }\n\n    public void add(int key) {\n        map[key]=true;\n    }\n\n    public void remove(int key) {\n        map[key]=false;\n    }\n\n    public boolean contains(int key) {\n        if (map[key]==true){\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n```\n\n## 题目2\n[lettcode-706题](https://leetcode-cn.com/problems/design-hashmap/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/6d0c43c3b85e5903.png )\n\n\n## 解题思路\n从题目中我们可以看出来跟上一题差不多，无非是一个set一个map的差别\n\n阅读题目要求我们可以知道对应的`key`和`value` 都是`int` 类型的，所以我们可以定义一个int类型的数组来存储数据\n\n取值的时候如果取值为空就返回一个`-1` ，所以我做了一个判断，判断是否有值\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass MyHashMap {\n\n    // 创建一个int类型的数组\n    Integer[] map=null;\n    public MyHashMap() {\n        map=new Integer[1000001];\n    }\n\n    public void put(int key, int value) {\n        map[key]=value;\n    }\n\n    public int get(int key) {\n        if (map[key]!=null){\n            int value=map[key];\n            return value;\n        }else{\n            return -1;\n        }\n    }\n\n    public void remove(int key) {\n        map[key]=null;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"SpringCloud微服务入门","url":"/2021/10/03/2021-10-03-SpringCloud微服务入门/","content":"\n# SpringCloud微服务入门\n\n##  1、微服务的发展历程\n\n### 1.1、单体结构\n简介：将业务的所有功能集中在一个项目中开发，打成一个包部署。我们之前所做的学生管理系统基本都是单体结构\n优点：结构简单、部署成本低\n缺点：耦合度高\n\n### 1.2、分布式结构\n简介：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。\n优点：降低服务耦合、有利于服务升级拓展\n分布式架构的要考虑的问题：\n服务拆分粒度如何？\n服务集群地址如何维护？\n服务之间如何实现远程调用？\n服务健康状态如何感知？\n\n### 1.3、微服务架构\n简介：微服务是一种经过良好架构设计的分布式架构方案。\n优点：拆分粒度更小、服务更独立、耦合度更低\n缺点：架构非常复杂，运维、监控、部署难度提高\n微服务架构的特征：\n- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发\n- 面向服务：微服务对外暴露业务接口\n- 自治：团队独立、技术独立、数据独立、部署独立\n- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n## 2、使用SpringCloud\n\nSpringCloud并不是一个全新的框架，其实他是一个将其他开源的框架集合的一个大篮子\n得益于SpringBoot框架方便的使用，我们也能很轻松地在SpringBoot上整合SpriongCloud的模块\n以下是SpringBoot和SpringCloud的版本匹配表，如果不按照这个规则，就有可能出现很多奇怪的问题![](https://bu.dusays.com/2021/10/03/9337d5a6f9ca0.png)\n\n### 2.1、服务拆分\n\n当我们使用微服务时，实际上就是相当于把原本在一起的模块拆分成一个一个的小的模块，所以我们在进行服务拆分时必须注意以下几点：\n1. 单一职责：不同微服务，不要重复开发相同业务\n2. 数据独立：不要访问其它微服务的数据库\n3. 面向服务：将自己的业务暴露为接口，供其它微服务调用\n\n### 2.2、服务调用\n\n当我们成功拆分出两个服务的时候，在使用时，肯定会出现A调用B，B调用C的情况出现，而此时我们想到的第一个方法就是根据服务的IP地址和端口进行调用。![](https://bu.dusays.com/2021/10/03/3cfda9ed84286.png)\n\n但是此时会出现一个问题，实际情况中我们一个服务肯定不只是只有一个地址，可能会有多个一样的服务，作为负载均衡。但是如果每个服务我们都需要通过IP+端口的方式来连接，那么当我们修改一个服务的端口时，就要相应地修改很多个调用他的端口的服务，显然是很麻烦的，而且也不能实现真正的负载均衡。所以我们需要一个注册中心来统一管理我们的所有服务。\n所以就有了eureka\n\n### 2.3、eureka注册中心\n\n消费者该如何获取服务提供者具体信息？\n- 服务提供者启动时向eureka注册自己的信息\n- eureka保存这些信息\n- 消费者根据服务名称向eureka拉取提供者信息\n\n如果有多个服务提供者，消费者该如何选择？\n- 服务消费者利用负载均衡算法，从服务列表中挑选一个\n\n消费者如何感知服务提供者健康状态？\n- 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态\n- eureka会更新记录服务列表信息，心跳不正常会被剔除\n- 消费者就可以拉取到最新的信息\n\n现在我们来创建一个eureka注册中心：\n1. 我们需要创建一个普通的maven项目，然后在其中引入依赖：\n```shell\n<dependency>    \n\t<groupId>org.springframework.cloud</groupId>    \n\t<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n2. 在启动类上添加`@EnableEurekaServer`注解\n3. 然后创建一个配置文件`Application.yml`,在其中添加以下内容\n```yaml\nserver: \n\tport: 10086 #端口\nspring:  \n\tapplication:    \n\t\tname: eurekaserver\u000b#服务名称\neureka: \n\tclient:    \n\t\tservice-url:       \n\t\t\tdefaultZone: http://127.0.0.1:10086/eureka/ # eureka的地址，将自己注册到eureka中\n```\n\n以上就成功创建了一个eureka注册中心，运行打开端口，就可以看到我们创建好的注册中心![](https://bu.dusays.com/2021/10/03/aee959c4bd69a.png)\n\n注册成功的服务会显示在`Instances currently registered with Eureka`处\n\n\n\n接下来我们将客户端注册到注册中心去\n\n1. 我们在需要加入的服务中添加以下依赖：\n```shell\n<dependency>    \n\t<groupId>org.springframework.cloud</groupId>    \n\t<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n2. 然后再配置文件中添加以下内容\n```yaml\nspring: \n\tapplication:\n    name: orderservice\neureka:\n\tclient:\n\t\tservice-url:\n\t\t\tdefaultZone: http://127.0.0.1:10086/eureka/\n```\n与上面一样，将自己注册到了注册中心中![](https://bu.dusays.com/2021/10/03/28ced8e089410.png)\n\n### 2.4、eureka服务调用\n\n在成功将服务注册到eureka中之后，我们就可以使用服务名来替代端口地址对服务进行调用了\n```java\nString url = \"http://userservice/user/\" + order.getUserId();\n```\n但这不是一个真实有效的地址，是不能直接进行访问的，只能通过eureka进行访问\n\n## 3、负载均衡\n\n### 3.1、认识负载均衡\n以下是负载均衡的一个流程图（此流程图也解释了如何通过服务名调用对应的服务）![](https://bu.dusays.com/2021/10/03/7165d0dd07c93.png)\n\n负载均衡简单来说就是我们有多个同名的服务，他们做的是一样的事情，我们希望所有的请求给他们所有人一起分担，而不是一个人抗下所有的请求，所以这个时候负载均衡就起到了作用，根据不同的规则，负载均衡可以以不同的策略对请求的服务进行管理，可以极大减小服务器的压力。\n\n### 3.2、负载均衡策略\n以下就是负载均衡的策略规则\n![](https://bu.dusays.com/2021/10/03/c6326bca1dd7c.png)\n\n![](https://bu.dusays.com/2021/10/03/eb43a6d5349a9.png)\n\n**饥饿加载**\nRibbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n\n在yml配置文件中加入以下内容，就可以开启饥饿加载模式：\n```yaml\nribbon:\n\teager-load:\n\t\tenabled: true # 开启饥饿加载 \n\t\t\tclients: userservice # 指定对userservice这个服务饥饿加载\n```\n\n## 4、SpringCloud Alibaba\nSpring Cloud Alibaba 是阿里巴巴提供的微服务开发一站式解决方案，是阿里巴巴开源中间件与 Spring Cloud 体系的融合。\n\nSpring Cloud Alibaba在自身有很多新的组件之外，还可以兼容SpringCloudNetflix的部分组件，如eureka、zuul等等\n\n### 4.1、注册中心Nacos\n\nNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高\n\n**在使用之前我们得先进行安装**\n首先得去Github上下载Nacos的压缩包,[点击跳转](https://github.com/alibaba/nacos/releases)\n下载完成后放到一个没有中文的路径\n在`bin`路径处打开cmd，输入以下命令，即可运行Nacos\n```shell\nstartup.cmd -m standalone\n```\n以下是运行成功的标志![]( https://i.bmp.ovh/imgs/2021/10/f421f5312ec052f6.png )\n然后我们在浏览器输入地址和端口就可以进入到nacos里面去\n\n**可能报错**\n在启动的时候碰到以下错误\n\n```markdown\n 在启动时碰见这个提示：此时不应有 \\nacos\"\\logs\\java_heapdump.hprof -XX:-UseLargePages\"\n```\n此时我们打开自带的编译器，将下面的语句注释掉\n```shell\nREM if %MODE% == \"cluster\" (    REM echo \"nacos is starting with cluster\"\t  REM if %EMBEDDED_STORAGE% == \"embedded\" (\t      REM set \"NACOS_OPTS=-DembeddedStorage=true\"\t  REM )    REM set \"NACOS_JVM_OPTS=-server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=%BASE_DIR%\\logs\\java_heapdump.hprof -XX:-UseLargePages\"REM )\n```\n再次运行即可通过\n\n### 4.2、将服务注册到Nacos\n\n1. 在微服务的父工程文件中添加以下内容\n```shell\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-alibaba-dependencies</artifactId>    \t\t\t<version>2.2.6.RELEASE</version>\n\t<type>pom</type>\n\t<scope>import</scope>\n</dependency>\n```\n2. 注释掉所有的eureka依赖文件\n3. 添加Nacos依赖\n```shell\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n4. 然后修改yml文件，注释掉eureka的地址，添加上Nacos的地址\n```yaml\nspring:\n\tcloud:\n    \tnacos:\n      \t\tserver-addr: localhost:8848 # nacos服务地址\n```\n启动服务就可以注册到Nacos中了![]( https://i.bmp.ovh/imgs/2021/10/72e709e90cb38267.png )\n\n### 4.3、服务集群\n\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高\n本地集群不可访问时，再去访问其它集群\n\n**现在我们来设置服务的集群**\n1. 首先我们在yml文件中添加以下的内容\n```yaml\nspring:\n  cloud:\n    nacos:\n      discovery:\n        cluster-name: SH #cluster-name就是集群的名称\n```\n2. 然后重新运行就可以看到变化![](https://i.bmp.ovh/imgs/2021/10/d5fd108812f6fef4.png)\n\n3. 然后在order-service中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务\n```ymal\nuserservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule  # 负载均衡规则\n```\n当本地集群正常运行时，服务就会优先调用本地集群的服务，而随后再考虑远程集群\n\n### 4.4、环境隔离 - namespace\n\nNacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离\n\n1. 在nacos的控制太我们可以创建一个命名空间![](https://z3.ax1x.com/2021/10/04/4Oh4bR.png)\n\n2. 填写好命名空间的信息，然后复制命名空间的ID\n3. 然后修改yml文件，添加命名空间的配置(添加最后一句)\n```yaml\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos服务地址\n      discovery:\n        cluster-name: HZ\n        ephemeral: false\n        namespace: 4d6ce343-9e1b-44df-a90f-2cf2b6b3d177 # dev环境\n```\n\n4. 启动服务就会看到相应的变化\n5. 此时不同空间中的服务是不能相互访问的\n\n## 5、Nacos配置管理\n\n### 5.1、Nacos实现配置的管理\n\nNacos有一个功能，就是可以将为服务的配置管理到自己的注册中心去，然后我们就可以通过远程调用，来使用这些配置在远端的配置文件。\n但是这又有什么用处呢？\n用处就是当我们有一些需要修改的开关型配置文件，我们希望修改时不影响到程序的运行，只要我们对程序进行了更改，就会自动进行配置，也叫做热部署。\n所以Nacos的配置管理就可以实现这样的一个功能。\n那么要怎么实现呢？\n\n1. 首先我们进入到Nacos的配置管理界面，打开配置列表，点击右上角的`+` 创建新的配置![](https://z3.ax1x.com/2021/10/04/4XiLA1.png)\n\n2. 如下图一样配置好文件，然后可以在下面的黑色输入框以`yml` 文件的格式输入你想要的配置内容，完成之后点击发布即可![](https://z3.ax1x.com/2021/10/04/4XkuRK.png)\n\n3. 现在我们就可以去java代码中进行配置的拉取了\n\n### 5.2、配置的拉取\n\n创建好了配置文件，我们现在需要去java代码中对其进行拉取。\n而以往我们运行微服务时直接就会读取 `application.yml` 这个配置文件，如何在读取他之前先读取Nacos上的配置文件呢？\n这时，我们就可以添加一个优先级更高的配置文件`bootstrap.yml` ，在里面编写读取Nacos配置的配置。\n\n![](https://z3.ax1x.com/2021/10/04/4XA3lT.png)\n\n\n1. 首先引入Nacos配置文件的依赖\n```shell\n<!--<nacos配置依赖-->\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n```\n2. 然后我们创建一个 `bootstrap.yml` ，里面写的是拉取远程配置的代码\n```yaml\nspring:\n  application:\n    name: userservice\n  profiles:\n    active: dev # 环境\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n```\n比如这里我们读取了 `userservice-dev.yaml` 文件的内容\n\n3. 然后我们检验一下是否能拿到远程的配置，以下是我们的远程配置文件中所包含的内容\n```yaml\npattern:\n    dateformat: yyyy/MM/dd HH:mm:ss\n```\n然后我们在Controller文件中获取一下配置文件，然后输出到屏幕上\n```java\n@Value(\"${pattern.dateformat}\")\nprivate String dateformat;\n\n@GetMapping(\"now\")\npublic String now(){\n\treturn LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n}\n```\n如果读取成功屏幕上就会按照前面的格式输出时间![](https://z3.ax1x.com/2021/10/04/4XEA41.png)\n\n### 5.3、配置热更新\n\n有了配置文件之后，我们现在要来配置热更新了。\n最简单的方法就是通过注解的方式来进行添加，就是以下的这种方法\n\n在 `@Value` 注入的变量所在类上添加注解 `@RefreshScope`\n\n另一种方法就是使用 `@ConfigurationProperties` 注解来实现。\n\n首先我们创建一个 `PatternProperties ` 类，然后在上面标上 `@ConfigurationProperties(prefix = \"pattern\")` ,`@Component` ,`@Data` 等注解。\n然后在类中创建一个私有成员变量`private String dateformat;` ，然后其他的控制器中对其进行注入并调用，就可以实现热更新。\n\n### 5.4、多环境配置共享\n\n![](https://z3.ax1x.com/2021/10/04/4XZMtA.png)\n\n而在不同微服务之间可以共享配置文件，可以通过下面的两种方式来指定：\n\n1. 方式一\n```yaml\nspring:\n\tapplication:\n\t\tname: userservice # 服务名称\n\tprofiles:\n\t\tactive: dev # 环境，\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # Nacos地址\n\t\t\tconfig: \n\t\t\t\tfile-extension: yaml # 文件后缀名\n\t\t\t\tshared-configs: # 多微服务间共享的配置列表\n\t\t\t\t\t- dataId: common.yaml # 要共享的配置文件id\n```\n2. 方式二\n```yaml\nspring:\n\tapplication:\n\t\tname: userservice # 服务名称\n\tprofiles:\n\t\tactive: dev # 环境，\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # Nacos地址\n\t\t\tconfig: \n            \tfile-extension: yaml # 文件后缀名\n\t\t\t\textends-configs: # 多微服务间共享的配置列表\n\t\t\t\t\t- dataId: extend.yaml # 要共享的配置文件id\n\n```\n\n### 5.5、Nacos集群搭建\n\n以下是教程中所要搭建的集群结构\n\n![](https://z3.ax1x.com/2021/10/04/4Xe2Kf.png)\n\n三个nacos节点的地址：\n\n| 节点   | ip            | port |\n| ------ | ------------- | ---- |\n| nacos1 | 192.168.150.1 | 8845 |\n| nacos2 | 192.168.150.1 | 8846 |\n| nacos3 | 192.168.150.1 | 8847 |\n\n**然后我们现在开始搭建我们的集群**\n\n搭建集群的基本步骤：\n\n- 搭建数据库，初始化数据库表结构\n- 下载nacos安装包\n- 配置nacos\n- 启动nacos集群\n- nginx反向代理\n\n1. 初始化数据库\n\n   我们在我们的数据库中创建好一个我们所需要的数据库\n\n2. 然后安装包我们已经下载过了，就可以直接跳过，然后配置一下nacos\n\n   进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：\n   ![](https://z3.ax1x.com/2021/10/04/4Xeva4.png)\n\n   然后添加以下三个地址\n\n   ![](https://z3.ax1x.com/2021/10/04/4XmfQx.png)\n\n   然后修改application.properties文件，添加数据库配置\n\n``` properties \n   spring.datasource.platform=mysql\n   db.num=1\n   db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\n   db.user.0=root\n   db.password.0=123\n```\n\n3. 启动\n\n   将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\n\n   然后分别修改三个文件夹中的 `application.properties` ，\n\n   nacos1:\n\n```properties\n   server.port=8845\n```\n\n   nacos2:\n\n```properties\n   server.port=8846\n```\n\n   nacos3:\n\n```properties\n   server.port=8847\n```\n\n   然后分别启动三个nacos节点：\n```\nstartup.cmd\n```\n\n4. Nginx反向代理\n\n安装好nginx之后，打开文件夹。修改conf/nginx.conf文件，配置如下：\n\n```nginx\nupstream nacos-cluster {\n    server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location /nacos {\n        proxy_pass http://nacos-cluster;\n    }\n}\n```\n\n然后在浏览器访问：http://localhost/nacos即可。\n\n代码中application.yml文件配置如下：\n\n```yaml\n spring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n```\n\n## 6、客户端Feign\n\nFeign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现http请求的发送\n\n![](https://z3.ax1x.com/2021/10/04/4Xtf4x.png)\n\n### 6.1、使用\n\n1. 引入依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-openfeign</artifactId>\n </dependency>\n```\n2. 在order-service的启动类添加注解开启Feign的功能：![](https://z3.ax1x.com/2021/10/04/4XNUMD.png)\n\n3. 编写feign客户端\n```java\n@FeignClient(\"userservice\")\npublic interface UserClient {\n\t@GetMapping(\"/user/{id}\") \n\tUser findById(@PathVariable(\"id\") Long id);\n}\n```\n主要是基于SpringMVC的注解来声明远程调用的信息，比如：\n- 服务名称：userservice\n- 请求方式：GET\n- 请求路径：/user/{id}\n- 请求参数：Long id\n- 返回值类型：User\n\n使用这种方式就可以很方便地代替之前的url的调用方式，代码变得更加清晰简洁。\n以下就是调用的内容\n\n4. 调用\n![](https://z3.ax1x.com/2021/10/04/4XUSF1.png)\n\n### 6.2、自定义Feign的配置\n\nFeign运行自定义配置来覆盖默认配置，可以修改的配置如下：![](https://z3.ax1x.com/2021/10/04/4XUiQO.png)\n\n一般情况下我们会修改日志级别,最好用basic或none\n\n### 6.3、配置Feign的日志\n\n配置日志时我们也有两种方式，一种是配置文件的方式，另一种是java代码的方式\n\n1. 配置文件方式\n\n```yaml\nfeign:\n\tclient:\n\t\tconfig:\n\t\t\tdefault: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n\t\t\t\tloggerLevel: FULL #  日志级别\n```\n\n2. java代码方式\n\n首先我们声明一个Bean\n```java\npublic class FeignClientConfiguration {\n\t@Bean\n\tpublic Logger.Level feignLogLevel(){\n\t\treturn Logger.Level.BASIC; \n\t}\n}\n```\n然后如果是全局配置，我们就放到 `@EnableFeignClients` 这个注解中\n```java\n@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) \n```\n如果是局部配置，我们就放到 `@FeignClient` 这个注解中\n```java\n@FeignClient(value = \"userservice\", configuration = FeignClientConfiguration.class) \n```\n\n### 6.4、性能优化\n\nFeign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：\n\n- URLConnection：默认实现，不支持连接池\n- Apache HttpClient ：支持连接池\n- OKHttp：支持连接池\n\n因此提高Feign的性能主要手段就是使用**连接池**代替默认的URLConnection。\n这里我们用Apache的HttpClient来演示。\n1. 引入依赖\n在order-service的pom文件中引入Apache的HttpClient依赖：\n```xml\n<!--httpClient的依赖 -->\n<dependency>\n    <groupId>io.github.openfeign</groupId>\n    <artifactId>feign-httpclient</artifactId>\n</dependency>\n```\n2. 配置连接池\n```yaml\nfeign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n```\n3. 优化总结\n总结，Feign的优化：\n\n1.日志级别尽量用basic\n2.使用HttpClient或OKHttp代替URLConnection\n①  引入feign-httpClient依赖\n②  配置文件开启httpClient功能，设置连接池参数\n\n### 6.5、最佳实践\n\n所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。\n自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：\nfeign客户端：![](https://z3.ax1x.com/2021/10/04/4X0pHe.png)\nUserController：![](https://z3.ax1x.com/2021/10/04/4X0k9I.png)\n\n我们有两种方法来优化重复的代码编写\n1. 继承方式\n2. 抽取方式\n\n首先来说一下**继承方式**：\n一样的代码可以通过继承来共享：\n1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。\n2）Feign客户端和Controller都集成这个接口![](https://z3.ax1x.com/2021/10/04/4X0EgP.png)\n\n优点：\n- 简单\n- 实现了代码共享\n\n缺点：\n- 服务提供方、服务消费方紧耦合\n- 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解\n\n然后是**抽取的方式**\n将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。\n例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用\n![](https://z3.ax1x.com/2021/10/04/4X0dUJ.png)\n\n### 6.6、基于抽取的最佳实践\n\n1. 首先创建一个公共类 `feign-api`\n2. 在这个类中引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n3. 然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中\n![](https://z3.ax1x.com/2021/10/04/4X0RVe.png)\n4. 在order-service中使用feign-api（引入api的依赖）\n```xml\n<dependency>\n    <groupId>cn.itcast.demo</groupId>\n    <artifactId>feign-api</artifactId>\n    <version>1.0</version>\n</dependency>\n```\n5. 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包\n6. 此时当我们重启测试的时候，就会发现出错了，出错内容如下\n![](https://z3.ax1x.com/2021/10/04/4X07Kf.png)\n\n这是因为UserClient现在在cn.itcast.feign.clients包下，\n而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。\n7. 解决扫描包问题\n\n有两种方法，一种是：指定Feign应该扫描的包\n```java\n@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\")\n```\n一种是指定要加载的Client的接口\n```java\n@EnableFeignClients(clients = {UserClient.class})\n```\n\n8. 至此，就设置完毕了\n\n\n\n## 7、Gateway网关\n\n为什么需要网关？网关用来干嘛\n网关可以用于：\n\n- 身份认证和权限校验\n- 服务路由、负载均衡\n- 请求限流\n\n在SpringCloud中有两种网关服务，一种是Gateway，另一种是Zuul\n而两者的差别是：Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。\n\n### 7.1、搭建一个Gateway网关\n\n我们需要创建一个网关的类来搭建一个网关，具体步骤如下：\n1. 创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖\n```xml\n<!--网关依赖-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<!--nacos服务发现依赖-->\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n2. 然后在网关的yml文件中编写路由配置及nacos地址\n```yaml\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n```\n此时，如果我们在控制台输入nacos的地址，以及加上断言中配置好的路径进行访问，就会被网关带到制定好的位置。\n比如说我访问`localhost:8848/user/now`，就会被带到userservice的now方法去，这就是网关的服务路由功能，是使用断言来实现的。\n\n### 7.2、断言工厂\n\n在yml文件中有这样一个配置：\n```\npredicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地\n```\n我们在配置文件中写的断言规则只是字符串，这些字符串会被`Predicate Factory`读取并处理，转变为路由判断的条件\n例如 `Path=/user/**`\n是按照路径匹配，这个规则是由`org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory` 类来处理的\n像这样的断言工厂在`SpringCloudGateway`还有十几个\n\nSpring给我们提供了很多种Predicate工厂\n![](https://z3.ax1x.com/2021/10/05/4j49G6.png)\n但是我们一般用的比较多的还是 `Path` 这种方式.\n\n### 7.3、路由过滤器/过滤器工厂\n\nGatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n![](https://z3.ax1x.com/2021/10/05/4j41sg.png)\n\nSpring提供了31种不同的路由过滤器工厂,例如：\n![](https://z3.ax1x.com/2021/10/05/4j4yw9.png)\n\n现在我们通过一个简单的例子，实际应用一下这个功能：\n给所有的userservice添加一个请求头\n```yaml\nspring:\n\tcloud:\n\t\tgateway:\n\t\t\troutes: # 网关路由配置\n\t\t\t\t- id: user-service\n\t\t\t\t  uri: lb://userservice\n\t\t\t\t  predicates:\n\t\t\t\t\t- Path=/user/**\n\t\t\t\t  filters: # 过滤器\n\t\t\t\t\t- AddRequestHeader=Truth, GUET is freaking awesome! # 添加请求头\n```\n此时所有的userservice的请求都加上了`Truth, GUET is freaking awesome!`这个请求头。\n\n而此时其他的不受影响，那么怎么样才能修改所有的请求头呢？\n有一个简单的方法，就是使用 `default-filters` \n例子如下：\n```yaml\nspring:\n\tapplication:\n\t\tname: gateway # 服务名称\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # nacos地址\n\tgateway:\n\t\troutes: # 网关路由配置\n\t\t\t- id: user-service \n\t\t \t  uri: lb://userservice \n\t\t\t  predicates: \n\t\t\t\t- Path=/user/**\n\t\t\t- id: order-service\n\t\t\t  uri: lb://orderservice\n\t\t\t  predicates:\n\t\t\t\t- Path=/order/**\n\t\tdefault-filters: # 默认过滤器，会对所有的路由请求都生效\n\t\t\t- AddRequestHeader=Truth, GUET is freaking awesome! # 添加请求头\n```\n此时，过滤器并没有指定加载哪一个服务上面，而是加在了`routes`的同一级上，包括了所有的service服务，所以他的含义就是为所有的服务都统一添加了这样的一个请求头\n\n### 7.4、全局过滤器\n\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与`GatewayFilter`的作用一样。\n区别在于`GatewayFilter`通过配置定义，处理逻辑是固定的。而`GlobalFilter`的逻辑需要自己写代码实现。\n定义方式是实现`GlobalFilter`接口。\n![](https://z3.ax1x.com/2021/10/05/4j5I3V.png)\n\n下面我们以一个案例来说明：\n\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n- 参数中是否有 `authorization`，\n- `authorization` 参数值是否为admin\n\n如果同时满足则放行，否则拦截.\n我们现在自定义一个类，实现FlobalFilter接口\n```java\n@Order(-1)\n@Component\npublic class AuthorizeFilter implements GlobalFilter {\n\t@Override\n\tpublic Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n\t\t// 1.获取请求参数\n\t\tMultiValueMap<String, String> params = exchange.getRequest().getQueryParams();\n\t\t// 2.获取authorization参数\n\t\tString auth = params.getFirst(\"authorization\");\n\t\t// 3.校验\n\t\tif (\"admin\".equals(auth)) {\n\t\t\t// 放行\n\t\t\treturn chain.filter(exchange);\n\t\t}\n\t\t// 4.拦截\n\t\t// 4.1.禁止访问\n\t\texchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);\n\t\t// 4.2.结束处理\n\t\treturn exchange.getResponse().setComplete();\n\t}\n}\n\n```\n注意一点，**在Order注解中，包含的值越小，优先级越高**\n\n**接下来我们看看过滤器的执行顺序：**\n\n- 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。\n- GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定\n- 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。\n- 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。\n\n\n### 7.5、Cors跨域\n\n跨域：域名不一致就是跨域，主要包括：\n域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com\n域名相同，端口不同：localhost:8080和localhost8081\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题\n解决方案：CORS\n\n只需要简单配置即可实现，如下所示：\n```yaml\nspring:\n\tcloud:\n\t\tgateway:\n\t\t\tglobalcors: # 全局的跨域处理\n\t\t\t\tadd-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n\t\t\t\tcorsConfigurations:\n\t\t\t\t'[/**]':\n\t\t\t\t\tallowedOrigins: # 允许哪些网站的跨域请求 \n\t\t\t\t\t  - \"http://localhost:8090\"\n\t\t\t\t\t  - \"http://www.leyou.com\"\n\t\t\t\t\tallowedMethods: # 允许的跨域ajax的请求方式\n\t\t\t\t\t  - \"GET\"\n\t\t\t\t\t  - \"POST\"\n\t\t\t\t\t  - \"DELETE\"\n\t\t\t\t\t  - \"PUT\"\n\t\t\t\t\t  - \"OPTIONS\"\n\t\t\t\t\tallowedHeaders: \"*\" # 允许在请求中携带的头信息\n\t\t\t\t\t\tallowCredentials: true # 是否允许携带cookie\n\t\t\t\t\tmaxAge: 360000 # 这次跨域检测的有效期\n```\njava代码就会根据上面配置的内容执行跨域的请求。","tags":["java","SpringCloud"],"categories":["java","SpringCloud"]},{"title":"算法学习_栈实现队列、队列实现栈","url":"/2021/10/01/2021-10-01-算法学习_栈实现队列、队列实现栈/","content":"\n# 栈实现队列、队列实现栈\n\n## 题目1、用栈来实现队列\n[lettcode-232题](https://leetcode-cn.com/problems/implement-queue-using-stacks/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/10/0e1d526ab12c4731.png )\n\n\n### 1.1、 解题思路\n栈是一个先进后出的数据结构，而队列是一个先进先出的数据结构，所以我们想要用栈来实现队列，就必须要用到两个栈，第一个栈出栈到第二个栈中，第二个栈再进行出栈，就可以实现队列先进先出的功能。\n\n具体代码如下\n\n\n### 1.2、具体代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> a;\n    private Stack<Integer> b;\n\n    public MyQueue() {\n        a=new Stack<>();\n        b=new Stack<>();\n    }\n\n    /**\n     * 入栈\n     * @param x\n     */\n    public void push(int x) {\n        a.push(x);\n    }\n\n    /**\n     * 出栈\n     * @return\n     */\n    public int pop() {\n        if(b.isEmpty()){\n            while (!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n\n    /**\n     * 返回栈顶元素\n     * @return\n     */\n    public int peek() {\n        if(b.isEmpty()){\n            while (!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n\n    /**\n     * 判断栈空\n     * @return\n     */\n    public boolean empty() {\n        return a.isEmpty()&&b.isEmpty();\n    }\n}\n```\n\n## 题目2、用队列来实现栈\n\n[lettcode-225题](https://leetcode-cn.com/problems/implement-stack-using-queues/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/10/69ec1eaccdf3cbb8.png )\n\n### 2.1、解题思路\n\n与上一题相同，我们需要用两个队列来实现一个栈\n\n利用队列中的基本方法们就可以实现栈的先进后出的操作\n\n代码如下：\n\n### 2.2、具体代码\n\n```java\nclass MyStack {\n\n    private Queue<Integer> a;\n    private Queue<Integer> b;\n\n    public MyStack() {\n        a=new LinkedList<>();\n        b=new LinkedList<>();\n    }\n\n    /**\n     * 入栈\n     * @param x\n     */\n    public void push(int x) {\n        a.offer(x);\n        // 将b队列中元素全部转给a队列\n        while(!b.isEmpty()) {\n            a.offer(b.poll());\n        }\n        // 交换a和b,使得a队列没有在push()的时候始终为空队列\n        Queue temp = a;\n        a = b;\n        b = temp;\n    }\n\n    /**\n     * 出栈\n     * @return\n     */\n    public int pop() {\n        return b.poll();\n    }\n\n    /**\n     * 返回栈顶元素\n     * @return\n     */\n    public int top() {\n        return b.peek();\n    }\n\n    /**\n     * 判断栈是否为空\n     * @return\n     */\n    public boolean empty() {\n        return b.isEmpty();\n    }\n}\n```\n\n","tags":["算法"],"categories":["算法"]},{"title":"算法学习_最近的请求次数","url":"/2021/10/01/2021-10-01-算法学习_最近的请求次数/","content":"\n# 最近的请求次数\n\n## 题目\n[lettcode-933题](https://leetcode-cn.com/problems/number-of-recent-calls/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/19b9897eff6dedb1.png )\n\n\n## 解题思路\n从题目上来看，一时半会看不出来是什么意思。\n\n其实所输入的数字t就是一个毫秒数，根据这个数来判断3000毫秒之前的数，如果小于3000毫秒之前的就删除小于的那个。\n\n所以当我们输入3002时，3000-3000=2，而1小于2，所以1就会被删除。\n\n所以说这个题是一个先进先出的方式，所以我们可以使用队列来实现。\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass RecentCounter {\n\n    //构造一个队列，LinkedList的队列\n    Queue<Integer> queue;\n    public RecentCounter() {\n        queue=new LinkedList<>();\n    }\n\n    public int ping(int t) {\n        //将输入的数值入队\n        queue.add(t);\n        //判断栈顶元素是否小于t-3000\n        //如果小于t-3000，将其出队\n        while (queue.peek()<t-3000){\n            queue.poll();\n        }\n        //返回队列的长度\n        return queue.size();\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"Redis使用注解实现二级缓存","url":"/2021/09/29/2021-09-29-Redis使用注解实现二级缓存/","content":"\n# Redis使用注解实现二级缓存\n\n## 1、介绍\n\n上一篇文章中，我们实现二级缓存的方式是通过java代码判断Redis是否存在缓存，然后决定从何处取数据，但是这种方法在我们有大量的需要用到缓存的地方的时候，会产生大量的冗余代码，而且有大量的判断语句，让我们的代码不能够专注于业务上面，这样子是不太好的。\n\n所以在Spring的3.1版本之后就引入了对注解的支持，我们可以通过在类上、方法上标记注解来实现二级缓存的存取\n\n其三个注解分别为：`Cacheable` ，`CacheEvict`，`CachePut`\n\n下面我会将三个注解分别展开进行简单解释\n\n## 2、Cacheable注解\n\n- @Cacheable可以标记在一个方法上，也可以标记在一个类上。\n- 对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。\n- Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果。\n- 至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。\n- 需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。\n- @Cacheable可以指定三个属性，value、key和condition。\n\n### 2.1、value属性\n\nvalue属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。\n如下例子所示：\n```java\n@RequestMapping(\"selectForAll\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper::AllStudent\")\npublic List<Student> selectStudentForAll() {\n    List<Student> studentList = studentService.selectStudentForAll();\n    return studentList;\n}\n```\n\n### 2.2、key属性\n\n- key属性是用来指定Spring缓存方法的返回结果时对应的key的。\n- 该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。\n- 定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n此时，如果我查询了一个sId为1800710318的学生\n那么上面的方法中最后缓存的键为：`MYBATIS:com.chen.mysqlredisdemo.StudentMapper::1800710318`\n\n### 2.3、condition属性\n\n- condition属性可以用于指定缓存发生的条件。\n- 有的时候我们可能并不希望缓存一个方法所有的返回结果，这时候通过condition属性可以实现这一功能。\n- condition属性默认为空，表示将缓存所有的调用情形。\n- 其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\",condition = \"#sId>1800710301\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n上面的例子就表示当查询的sId大于1800710318的时候才会执行缓存的操作\n\n## 3、CachePut注解\n\n- 在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。\n- @CachePut也可以声明一个方法支持缓存功能。\n- 与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。\n- @CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。\n\n简而言之就是CachePut只会往缓存中写数据，不会从缓存中拿数据\n\n## 4、CacheEvict注解\n\n- @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。\n- @CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。\n- 其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。\n- 与前面不同的不同的是有了两个多出来的属性：`allEntries`和`beforeInvocation`\n\n### 4.1、allEntries属性\n- allEntries是boolean类型，表示是否需要清除缓存中的所有元素。\n- 默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。\n- 有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。\n\n### 4.2、beforeInvocation属性\n\n- 清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。\n- 使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。\n\n## 5、Caching注解\n\n@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。\n其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。\n\n其例子如下\n```java\n @Caching(cacheable = @Cacheable(\"users\"), evict = { @CacheEvict(\"cache2\"), @CacheEvict(value = \"cache3\", allEntries = true) })\npublic User find(Integer id) {\n\treturnnull;\n}\n```\n上面的例子通过一个Caching注解，实现了三种注解同事的配置，相当于一个大集合\n\n\n## 6、总结\n\nSpringBoot中大量使用了注解、替代了原有的配置文件。\n大大减少了冗余代码，方便地实现了注解中所设置好的功能。\n使得我们的代码简洁易懂。\n除了官方默认的注解，同时我们还可以自定义很多注解，极大方便了我们的使用。","tags":["java","redis"],"categories":["java","redis"]},{"title":"Redis入门使用","url":"/2021/09/29/2021-09-29-Redis的入门使用/","content":"\n# Redis入门使用\n\n## 1、Redis简介\n1. 简介\nRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\n    - Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n    - Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n    - Redis支持数据的备份，即master-slave模式的数据备份。\n\n2. 优势\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n## 2、Redis安装\n### 2.1、window安装\n下载地址：https://github.com/tporadowski/redis/releases。\n** 根据自己电脑是32位或者64位的下载相对应得版本，就可以进行安装使用 **\n解压文件夹之后进入文件夹得目录下打开cmd\n输入以下命令，就可以运行redis\n`redis-server.exe redis.windows.conf`\n重新打开一个cmd，输入以下命令就可以进行数据库操作\n`redis-cli.exe -h 127.0.0.1 -p 6379`\n\n### 2.2、Linux安装\n下载地址：http://redis.io/download 下载最新稳定版本。\n在linux中对压缩包进行解压之后\n进入解压后的文件夹\n进行make操作\n```shell\n# wget http://download.redis.io/releases/redis-6.0.8.tar.gz\n# tar xzf redis-6.0.8.tar.gz\n# cd redis-6.0.8\n# make\n```\nmake之后，src目录下面就会出现一个`redis-server`的文件，可以用来启动Redis，如下\n```shell\n# cd src\n# ./redis-server\n```\n除此之外，Redis还给我们提供了一个配置文件，可以修改Redis的配置文件，并运行，如下\n```shell\n# cd src\n# ./redis-server ../redis.conf\n```\n### 2.3、Ubuntu apt 命令安装\nUbuntu系统不像其他的linux系统，它可以通过命令来在线安装\n在 Ubuntu 系统安装 Redis 可以使用以下命令:\n```shell\n# sudo apt update\n# sudo apt install redis-server\n```\n然后可以启动\n```shell\n# redis-server\n```\n\n## 3、Redis的数据类型\n### 3.1、String类型\n\n字符串类型，是一种我们平常最常见到的一种数据类型之一\n我们使用set和get存取数据时，一般就是String的类型，如下\n```shell\nredis 127.0.0.1:6379> SET name \"陈益财\"\nOK\nredis 127.0.0.1:6379> GET name\n\"陈益财\"\n```\n其中，name就是key，\"陈益财\"就是所对应的值\n\n### 3.2、Hash类型\n\nRedis hash 是一个键值(key=>value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象\n例子如下：\n```shell\nredis 127.0.0.1:6379> HMSET names name1 \"chenyicai\" name1 \"George\"\n\"OK\"\nredis 127.0.0.1:6379> HGET names name1\n\"Hello\"\nredis 127.0.0.1:6379> HGET names name1\n\"World\"\n```\n\n### 3.3、List类型\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n例子如下：\n```shell\nredis 127.0.0.1:6379> lpush chen redis\n(integer) 1\nredis 127.0.0.1:6379> lpush chen mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush chen rabbitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange chen 0 10\n1) \"rabbitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n其中lpush表示存数据，而lrange表示取数据\n\n### 3.4、set类型\n\nRedis 的 Set 是 string 类型的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n例子如下：\n```shell\nredis 127.0.0.1:6379> sadd chen redis\n(integer) 1\nredis 127.0.0.1:6379> sadd chen mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers chen\n\n1) \"redis\"\n2) \"rabbitmq\"\n3) \"mongodb\"\n```\n其中sadd表示添加数据，smembers表示取出数据\n**注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略**\n\n### 3.5、zset类型\n\nRedis zset 和 set 一样也是string类型元素的集合,**且不允许重复的成员**。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n例子·如下：\n```shell\nredis 127.0.0.1:6379> zadd chen 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE chen 0 1000\n1) \"mongodb\"\n2) \"rabbitmq\"\n3) \"redis\"\n```\n其中zadd表示存数据，ZRANGEBYSCORE表示取数据\n且虽然存了两次相同的字符，但是也是只会保留一个\n\n## 4、在java中使用Redis\n\n使用Redis更多的情况是在java环境下面使用，所以需要掌握如何在java中对Redis进行操作\nRedis官方给我们提供了很方便的工具来进行Redis的操作：Jedis\n\n首先你需要下载驱动包 [下载 jedis.jar](https://mvnrepository.com/artifact/redis.clients/jedis)，确保下载最新驱动包。\n\n### 4.1、连接到Redis\n配置完成之后我们就可以连接到Redis了。\n例子如下：\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        // 如果 Redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth(\"123456\"); \n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \"+jedis.ping());\n    }\n}\n```\n如果是可以连接成功的，就会返回一个PONG表示回应\n\n### 4.2、String类型的存储\n\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisStringJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //设置 redis 字符串数据\n        jedis.set(\"name\", \"chenyicai\");\n        // 获取存储的数据并输出\n        System.out.println(\"redis 存储的字符串为: \"+ jedis.get(\"name\"));\n    }\n}\n```\n成功之后控制台就会显示name所对应的值：chenyicai\n\n### 4.3、List类型的存储\n\n```java\nimport java.util.List;\nimport redis.clients.jedis.Jedis;\n \npublic class RedisListJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //存储数据到列表中\n        jedis.lpush(\"site-list\", \"Baidu\");\n        jedis.lpush(\"site-list\", \"Google\");\n        jedis.lpush(\"site-list\", \"Taobao\");\n        // 获取存储的数据并输出\n        List<String> list = jedis.lrange(\"site-list\", 0 ,2);\n        for(int i=0; i<list.size(); i++) {\n            System.out.println(\"列表项为: \"+list.get(i));\n        }\n    }\n}\n```\n成功之后控制台就会返回信息\n```\n列表项为: Taobao\n列表项为: Google\n列表项为: Baidu\n```\n\n## 5、在SpringBoot中使用Redis\n\n一般在SpringBoot中使用Redis时我们会用来做Mysql数据库的二级缓存，这样子在我们获取数据的时候就不需要每次都到数据库进行查询，如果缓存中有数据就可以直接从缓存中拿，大大提高了查询的效率。\n\n1. 首先我们需要在maven中引入我们所需要的依赖\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n2. 然后在yml配置文件中，配置Redis的相关配置文件\n```java\nspring:\n  redis:\n    database: 0\n    host: localhost\n    port: 6379\n    password:\n    timeout: 500\n    pool:\n      max-active: 8\n      max-idle: 8\n      min-idle: 0\n      max-wait: -1\n```\n3. 我们还需要一个Config类来处理数据的序列化，否则双方可能会出现乱码的情况\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    private RedisConnectionFactory redisConnectionFactory;\n\n    public RedisConfig(RedisConnectionFactory redisConnectionFactory) {\n        this.redisConnectionFactory = redisConnectionFactory;\n    }\n\n    /**\n     * redisTemplate 序列化使用的jdkSerializeable, 存储二进制字节码, 所以自定义序列化类\n     *\n     * @return\n     */\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate() {\n        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        // 使用Jackson2JsonRedisSerialize 替换默认序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n\n        // 设置value的序列化规则和 key的序列化规则\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n\n}\n```\n\n4. 创建一个cache的实现类用于将查出来的数据添加到缓存中，并设置一些缓存的配置,里面包括了一些有关增删改的配置方法。\n```java\npublic class MybatisRedisCache implements Cache {\n    private Object key;\n    private String id;\n\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private RedisTemplate<Object, Object> redisTemplate;\n\n    private final String COMMON_CACHE_KEY = \"MYBATIS:\";\n\n    /**\n     * 默认缓存对象的缓存时间为 1 分钟\n     **/\n    private static final long EXPRIRE_TIME_IN_MINUT = 30;\n\n    public MybatisRedisCache(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"缓存对象id是不能为空的\");\n        }\n        this.id = id;\n    }\n\n    private RedisTemplate<Object, Object> getRedisTemplate() {\n        if (redisTemplate == null) {\n            redisTemplate = ApplicationContextHolder.getBean(\"redisTemplate\");\n        }\n        return redisTemplate;\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public void putObject(Object key, Object value) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            //使用redisTemplate得到值操作对象\n            ValueOperations operation = redisTemplate.opsForValue();\n            //使用值操作对象operation设置缓存对象\n            operation.set(getKey(key), value, EXPRIRE_TIME_IN_MINUT, TimeUnit.MINUTES);\n//            System.out.println(\"缓存对象保存成功\");\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象保存失败\" + t);\n        }\n    }\n\n    public Object getKey() {\n        return key;\n    }\n\n    public void setKey(Object key) {\n        this.key = key;\n    }\n\n    @Override\n    public Object getObject(Object key) {\n        try {\n            setKey(key);\n            RedisTemplate redisTemplate = getRedisTemplate();\n            ValueOperations operations = redisTemplate.opsForValue();\n            Object result = operations.get(getKey(key));\n//            System.out.println(\"获取缓存对象成功\");\n            return result;\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象获取失败\" + t);\n            return null;\n        }\n    }\n\n    @Override\n    public Object removeObject(Object key) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            redisTemplate.delete(getKey(key));\n//            System.out.println(\"删除缓存对象成功！\"+key);\n        } catch (Throwable t) {\n            System.err.println(\"删除缓存对象失败！\" + t);\n        }\n        return null;\n    }\n\n    @Override\n    public void clear() {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            Set<String> keys = redisTemplate.keys(getKeys());\n            redisTemplate.delete(keys);\n            System.out.println(\"出现新增、修改、删除操作，清空对应Mapper缓存======>\" + keys.size());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 按照一定规则标识key\n     */\n    private String getKey(Object key) {\n        String k=COMMON_CACHE_KEY + this.id + \":\" + DigestUtils.md5DigestAsHex(String.valueOf(key).getBytes());\n        return k;\n    }\n\n    /**\n     * 所有key\n     */\n    private String getKeys() {\n        return COMMON_CACHE_KEY + this.id + \":*\";\n    }\n\n    @Override\n    public int getSize() {\n        Long size = getRedisTemplate().boundHashOps(getId()).size();\n        return size == null ? 0 : size.intValue();\n    }\n\n    @Override\n    public ReadWriteLock getReadWriteLock() {\n        return readWriteLock;\n    }\n}\n```\n\n5. 然后我们在数据库查询的`mapper.xml`上添加上以下的配置，表示开启了数据库的二级缓存\n```xml\n<cache type=\"com.chen.mysqlredisdemo.cache.MybatisRedisCache\"></cache>\n```\n\n6. 然后在Controller文件中注入刚才写好的方法\n```java\n@Autowired\nStringRedisTemplate stringRedisTemplate;\n@Autowired\nRedisTemplate redisTemplate;\n```\n\n7. 最后在方法中判断Redis中是否有缓存，如果有就从Redis中取数据，否则就到数据库进行查找\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n    public Student selectStudentForOne(@PathVariable int sId){\n        String key = \"MYBATIS:\" + \"com.chen.mysqlredisdemo.StudentMapper:\"+sId;\n        ValueOperations<String, Student> operations = redisTemplate.opsForValue();\n        boolean hasKey = redisTemplate.hasKey(key);\n        if (hasKey) {\n            System.out.println(\"缓存输出\");\n            Student student = operations.get(key);\n            return student;\n        }else {\n            Student student = studentService.selectStudentForOne(sId);\n            operations.set(key, student);//把数据放入缓存\n            return student;\n        }\n    }\n```","tags":["java","redis"],"categories":["java","redis"]},{"title":"算法学习_设计有序流","url":"/2021/09/26/2021-09-26-算法学习_设计有序流/","content":"\n# 设计有序流\n\n## 题目\n[lettcode-1656题](https://leetcode-cn.com/problems/design-an-ordered-stream/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/09/3e508439a8f7dbe3.png)\n\n\n## 解题思路\n既然是一个有序流，那么我们就可以将其存储到一个数组中，然后通过数组下标对所在的值进行访问。所以我们首先创建一个长度为n+1的数组，将value的值存在其中。\n将下标指针的值设置为1，然后在执行时进行循环加1\n\n接下来就是循环读取的过程：\n当我们在数组中插入一个数据的时候，就判断一个数组下标是否小于n，以及当前下标处的value值是否不为空，如果不为空我们就进入循环，将其存到一个新的集合中，并将其输出。\n如果为空的时候就不执行方法，继续往数组中添加value\n直到下标不小于n为止\n\n## 具体代码\n```java\nclass OrderedStream {\n\n    private String[] arr;\n    private int n;\n    private int ptr;\n\n    // 构造函数\n    public OrderedStream(int n) {\n    \t//因为数组的下标n从0开始，所以数组的长度为n+1\n        this.arr=new String[n+1];\n        this.n=n;\n        this.ptr=1;\n    }\n\n    public List<String> insert(int idKey, String value) {\n        //将value存到数组中\n        arr[idKey]=value;\n\n        //创建一个新的数组\n        List<String> res=new ArrayList<>();\n        //循环读取arr数组，将其中的值写到res数组中\n        //当arr[]为null时，不进入循环\n        while (ptr<=n&&arr[ptr]!=null){\n            res.add(arr[ptr]);\n            ptr++;\n        }\n        return res;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"算法学习_设计停车系统","url":"/2021/09/26/2021-09-26-算法学习_设计停车系统/","content":"\n# 设计停车系统\n\n## 题目\n[lettcode-1603题](https://leetcode-cn.com/problems/design-parking-system/) \n难度：简单![]( https://s3.bmp.ovh/imgs/2021/09/a5c6d4d87d542ba7.png )\n\n\n## 解题思路\n每种车都有每种车所对应的一个车位，而且不能停到其他车的车位上面去，所以说我们需要三个变量将每种车的车位数量存起来。\n然后在有新车进来时，判断车辆的类型，然后查找相应的停车位，如果有车位就返回一个true，相当于停车成功，然后该类型的车位减去一个，如果车位为0，则不允许停车，返回false\n\n## 具体代码\n```java\nclass ParkingSystem {\n\n    int big;\n    int medium;\n    int small;\n    // 构造函数\n    public ParkingSystem(int big, int medium, int small) {\n        this.big=big;\n        this.medium=medium;\n        this.small=small;\n    }\n\n    public boolean addCar(int carType) {\n        if (carType==1){\n            if (this.big>0){\n                this.big--;\n                return true;\n            }\n        }else if (carType==2){\n            if (this.medium>0){\n                this.medium--;\n                return true;\n            }\n        }else if (carType==3){\n            if (this.small>0){\n                this.small--;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"java栈","url":"/2021/09/25/2021-09-25-java栈/","content":"\n# java栈\n\n栈是一个先进后出的数据结构，想要自己实现一个栈，要求这个栈具有push()，pop()——返回栈顶并出栈，peek()——返回栈顶不出栈，isEmpty()等方法。\n\n## 1.1、手动实现一个栈的多种方式\n1. 采用数组来实现栈\n```java\nimport java.util.Arrays;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/25 19:59\n * @since 1.0\n */\nclass Stack1<T> {\n\n    // 实现栈的数组\n    private Object[] stack;\n    // 数组大小\n    private int size;\n\n    Stack1(){\n        stack=new Object[10];\n    }\n\n    // 判断数组是否为空\n    public boolean isEmpty(){\n        if (size==0){\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    // 返回栈顶元素\n     public T peek(){\n        T t=null;\n        if (size>0){\n            t= (T) stack[size-1];\n        }\n        return t;\n     }\n\n     // 返回栈顶并出栈\n     public T pop(){\n        T t=peek();\n        if(size>0){\n            stack[size-1]=null;\n            size--;\n        }\n        return t;\n     }\n\n     // 扩容\n    public void expandCapacity(int size){\n        int len=stack.length;\n        if (size>len){\n            size=size*3/2+1;\n            stack= Arrays.copyOf(stack,size);\n        }\n    }\n\n    public void push(T t){\n        expandCapacity(size+1);\n        stack[size]=t;\n        size++;\n    }\n}\n\npublic class ArrayStack {\n    public static void main(String[] args) {\n        Stack1<String> stringStack1=new Stack1<>();\n        System.out.println(stringStack1.peek());\n        System.out.println(stringStack1.isEmpty());\n        stringStack1.push(\"java\");\n        stringStack1.push(\"chenyc2021@qq.com\");\n        stringStack1.push(\"gogogo\");\n        System.out.println(stringStack1.pop());\n        System.out.println(stringStack1.isEmpty());\n        System.out.println(stringStack1.peek());\n    }\n}\n```\n\n2. 采用链表来实现\n```java\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 0:49\n * @since 1.0\n */\nclass Stack2<T> {\n    // 定义一个链表\n    class Node<T> {\n        private T t;\n        private Node next;\n    }\n\n    private Node<T> head;\n\n    // 构造函数\n    Stack2() {\n        head = null;\n    }\n\n    // 入栈\n    public void push(T t) {\n        if (t == null) {\n            throw new NullPointerException(\"参数不能为空\");\n        }\n        if (head == null) {\n            head = new Node<T>();\n            head.t = t;\n            head.next = null;\n        } else {\n            Node<T> temp = head;\n            head = new Node<T>();\n            head.t = t;\n            head.next = temp;\n        }\n    }\n\n    // 出栈\n    public T pop() {\n        T t = head.t;\n        head = head.next;\n        return t;\n    }\n\n    // 栈顶元素\n    public T peek() {\n        T t = head.t;\n        return t;\n    }\n\n    //判断栈是否为空\n    public boolean isEmpty() {\n        if (head == null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\npublic class LinkStack {\n    public static void main(String[] args) {\n        Stack2 stack = new Stack2();\n        System.out.println(stack.isEmpty());\n        stack.push(\"Java\");\n        stack.push(\"is\");\n        stack.push(\"beautiful\");\n        System.out.println(stack.peek());\n        System.out.println(stack.peek());\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n    }\n}\n```\n\n3. 采用LinkedList实现栈\n```java\n import java.util.LinkedList;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 9:39\n * @since 1.0\n */\n\nclass Stack3<T>{\n    // 构建一个linkedLIst集合\n    private LinkedList<T> ll=new LinkedList<>();\n\n    // 判断栈是否为空\n    public boolean isEmpty(){\n        return ll.isEmpty();\n    }\n\n    // 入栈\n    public void push(T t){\n        ll.addFirst(t);\n    }\n\n    //出栈\n    public T pop(){\n        return ll.removeFirst();\n    }\n\n    // 栈顶元素\n    public T peek(){\n        T t=null;\n        if (!ll.isEmpty()){\n            t=ll.getFirst();\n        }\n        return t;\n    }\n\n}\npublic class LinkedStack {\n    public static void main(String[] args) {\n        Stack3<String> stringStack3=new Stack3<>();\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n        stringStack3.push(\"java\");\n        stringStack3.push(\"is\");\n        stringStack3.push(\"beautiful\");\n        System.out.println(stringStack3.peek());\n        System.out.println(stringStack3.pop());\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n    }\n}\n```\n\n## 1.2、栈的应用\n\n在java中，栈是一种很重要的数据结构，如以下的很多场景都应用到了栈\n- 符号匹配\n- 中缀表达式变为后缀表达式\n- 计算后缀表达式\n- 实现函数的嵌套调用\n- HTML和XML中的标签匹配\n- 网页浏览器中以访问界面的历史记录\n\n例如：\n\n1. 符号匹配\n在编写程序的过程中，我们经常会遇到诸如圆括号“()”与花括号“{}”，这些符号都必须是左右匹配的，这就是我们所说的符合匹配类型，当然符合不仅需要个数相等，而且需要先左后右的依次出现，否则就不符合匹配规则，如“)(”，明显是错误的匹配，而“()”才是正确的匹配。有时候符合如括号还会嵌套出现，如“9-(5+(5+1))”,而嵌套的匹配原则是一个右括号与其前面最近的一个括号匹配，事实上编译器帮我检查语法错误是也是执行一样的匹配原理，而这一系列操作都需要借助栈来完成，接下来我们使用栈来实现括号”()”是否匹配的检测。\n判断原则如下（str=”((5-3)*8-2)”）：\n\na.设置str是一个表达式字符串，从左到右依次对字符串str中的每个字符char进行语法检测，如果char是，左括号则入栈，如果char是右括号则出栈(有一对匹配就可以去匹配一个左括号，因此可以出栈)，若此时出栈的字符char为左括号，则说明这一对括号匹配正常，如果此时栈为空或者出栈字符不为左括号，则表示缺少与char匹配的左括号，即目前不完整。\n\nb.重复执行a操作，直到str检测结束，如果此时栈为空，则全部括号匹配，如果栈中还有左括号，是说明缺少右括号。\n\n实现代码如下：\n```java\npublic class CheckExpression {\n\n  public static String isValid(String expstr)\n  {\n      //创建栈\n      LinkedStack<String> stack = new LinkedStack<>();\n\n      int i=0;\n      while(i<expstr.length())\n      {\n          char ch=expstr.charAt(i);\n          i++;\n          switch(ch)\n          {\n              case '(': stack.push(ch+\"\");//左括号直接入栈\n                  break;\n              case ')': if (stack.isEmpty() || !stack.pop().equals(\"(\")) //遇见右括号左括号直接出栈\n                  return \"(\";\n          }\n      }\n      //最后检测是否为空,为空则检测通过\n      if(stack.isEmpty())\n          return \"check pass!\";\n      else\n          return \"check exception!\";\n  }\n\n  public static void main(String args[])\n  {\n      String expstr=\"((5-3)*8-2)\";\n      System.out.println(expstr+\"  \"+isValid(expstr));\n  }\n}\n```\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"准备阅读小米十年纪念《一往无前》","url":"/2021/08/27/2021-08-27-准备阅读小米十年纪念《一往无前》/","content":"\n# 准备阅读小米十年纪念《一往无前》\n\n作为一个不太资深的老米粉，自从小米发布新书《一往无前》以来一直想阅读一下，感受一下大厂发展的心路历程，但是一直都没有提上日程，而今天决定正式开始阅读此书，但是可能耗时会较长，现在这里做一个标记，阅读完毕务必完成一篇读后感。\n\n---\n\n2021.09.21 因为一直都在面试，所以阅读计划得往后推迟一点了。","tags":["随笔"],"categories":["随笔"]},{"title":"对SpringIOC的理解","url":"/2021/08/26/2021-08-26-对SpringIOC的理解/","content":"\n# 对SpringIOC的理解\n\n## 1、何为IOC\n​\tIOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好IOC呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来分析一下\n\n### 1.1 谁控制谁，控制什么\n\n​\t传统Java程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）\n\n### 1.2 为何是反转，哪些方面反转了\n\n​\t有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n### 1.3 图例说明\n\n传统程序设计下图，都是主动去创建相关对象然后再组合起来：\t\n\n![]( https://s3.bmp.ovh/imgs/2021/08/38929d2b7cf05cd7.jpg )\n\n当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示：\n\n![]( https://s3.bmp.ovh/imgs/2021/08/c7705f5db3bbd643.png )\n\n## 2、IOC能做什么\n\n​\tIOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n　　其实IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC/DI思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。\n　　IOC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n## 3、IOC和DI\n\n​\tDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来分析一下：\n\n- 谁依赖于谁：当然是应用程序依赖于IOC容器；\n- 为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；\n- 谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；\n- 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\tIOC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。\n\t\n## 4、对IOC和DI的理解\n\n### 4.1、IoC(控制反转)\n　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。\n　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\n\n### 4.2、DI(依赖注入)\n　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。\n　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。\n　　\n　　\n## 5、原文地址\nhttps://www.iteye.com/blog/jinnianshilongnian-1413846","tags":["java"],"categories":["java"]},{"title":"最近一段时间的学习总结","url":"/2021/08/20/2021-08-20-最近一段时间的学习总结/","content":"\n# 最近一段时间的学习总结\n\n## 项目部分\n\n1. 完成了学生宿舍系统的答辩\n2. 成功将学生宿舍为系统部署到了服务器上\n3. 准备进行学生宿舍系统的小程序的设计，但是实在是没有时间\n4. 完成了国医堂小程序的开发(React+Taro+Taro UI)\n5. 完成了小程序API的开发(Vue+SpringBoot+MyBatis-Plus)\n6. 国医堂小程序后台开发完毕(VUE+SpringBoot+MyBatis-Plus+Element-UI)\n7. 准备进行中医药门户或者桂林医学院报修系统开发环境的搭建\n\n## 框架部分\n\n1. 学习了SpringSecurity，并完成了Session以及Token两种情况下的应用Demo\n2. MyBatis-Plus逆向工程(代码生成器)\n3. Shiro的基本使用\n4. 入门Activiti(工作流)\n5. 准备学些RabbitMQ、\n6. MyBatis-Plus逆向工程3.5.0版本之之前是setting模式，之后是building模式\n7. 入门了React以及Vue两个有名的前端框架的使用\n8. ElementUI，LayUI，Bootstrap等UI的使用\n\n## 基础知识\n\n1. 复习了下AOP思想，并准备使用到日志中\n2. HashMap和HashTable的区别\n\n## 服务器\n\n1. 手动将web项目部署到阿里云服务器上\n2. 复习了Linux的指令\n\n## 备注\n\n看到同学面试京东所回答的问题，以及其他同学所总结的知识点，感觉自己和别人相比有很大的进步空间","tags":["学习总结"],"categories":["随笔","学习总结"]},{"title":"shiro安全框架","url":"/2021/08/01/2021-08-01-shiro安全框架/","content":"\n# shiro安全框架\n\n## 1、简述\nshiro是apache公司所出品的开源安全框架\n其可以用于：\n1. 处理身份认证\n2. 授权\n3. 企业会话管理和加密\n\n相对于Spring security来说更加简单，使用也更加灵活\n\n在使用shiro的时候可以不依赖于任何容器，既可以在javaSE下使用，同样可以在JavaEE下使用\n\n## 2、架构\n\n1. 使用用户的登录信息构建令牌\n```java\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n```\ntoken可以理解为一个用户令牌，等于的过程可以理解为shiro检验用户令牌是否具有合法的身份以及相关的权限\n2. 执行登录\n\n```java\nSecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager\nSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象\nsubject.login(token); // 执行登录\n```\nshiro中最核心的部分就是securityManger，它主要负责安全认证和授权。当我们在使用这个框架的时候，shiro已经将一切的操作封装成一个盒子了，我们在使用的时候可以把它当成一个黑盒来进行使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject，翻译过来就是项目的意思，他是一个需要通过shiro保护的一个抽象概念。\n通过1令牌和项目的登录关系，保证了我们的安全。\n\n3. 判断用户\n\n这一步中的内容shiro无法帮我们进行实现，我们只有通过最原始的手段来实现登录用户的判断，就是查询数据库。\n\n例如：\n```java\nif (!token.getUsername().equals(name)) {\n  //shiro底层会抛出一个异常\n    return null;\n}\n//判断密码\nreturn new SimpleAuthenticationInfo(\"\", password, \"\");\n```\n第一个if语句中首先会判断数据库中查到的name于输入的用户名2是否一致，如果不一致，则会抛出一个异常\n然后SimpleAuthenticationInfo中可以用于判断密码的正确性，同样是从数据库查出来的数据做对比。\n\n## 3、实现Realm\n\n1. 创建一个Realm\n\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息，但是Realm并不止局限于数据的存取，其中还有很多认证授权校验相关的代码  \n我们可以自定义一个MyRealm，用于我们的项目之中，但是前提是这个类必须继承于AuthorizingRealm父类，然后实现两个方法  \nAuthorizationInfo doGetAuthorizationInfo以及AuthenticationInfo doGetAuthenticationInfo  \nAuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。\n\n我们也可以简单看作：  \n**doGetAuthenticationInfo()** 方法：用来验证当前登录的用户，获取认证信息。  \n**doGetAuthorizationInfo()** 方法：为当前登录成功的用户授予权限和分配角色。\n\n2. 从数据库查询数据\n\n在数据库中查询登陆人信息的时候，仅仅需要查询用户的id，这时还未涉及到密码，也就是说即使用户输入的密码不正确，照样可以查询出该用户。\n然后，将该用户的相关信息封装到authcInfo中并返回给Shiro接下来就该Shiro上场了，将封装的用户信息与用户的输入信息（用户名、密码）进行对比、校验（注意，这里对密码也要进行校验）。校验通过则允许用户登录，否则跳转到指定页面。\n\n## 4、Shiro配置\n\n1. 在ShiroConfig中配置Realm\n\n```java\n@Bean(name=\"MyRealm\")\n  public MyRealm myRealm() {\n    return new MyRealm();\n  }\n```\n2. 配置安全管理器SecurityManager\n\n```java\n@Bean(name=\"securityManager\")\n  public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"MyRealm\") MyRealm myRealm) {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    //关联Realm\n    securityManager.setRealm(myRealm);\n    return securityManager;\n  }\n```\n当我们配置安全管理器的时候，需要将前面的Realm添加进来，这样子才可以访问到Realm\n\n3. 配置Shiro过滤器\n\nshiro中自带好了配置的过滤器，我们在使用之前需要将其进行导入\n\n```java\nShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n//设置安全管理器\nshiroFilterFactoryBean.setSecurityManager(securityManager);\n//添加Shiro内置过滤器\n/*\nShiro内置过滤器，可以实现权限相关的拦截器\n常用的有：\nanon：无需认证就能访问\nauthc：必须认证才能访问\nuser：必须拥有 “记住我” 功能才能使用\nperms：拥有对某个资源的权限才能访问\nrole： 拥有对某个角色权限才能访问\n*/\nLinkedHashMap<String, String> filterMap = new LinkedHashMap<String,String>();\n//这里我们要将不进行拦截的放在前面\nfilterMap.put(\"/login\", \"anon\");\nfilterMap.put(\"/*\", \"authc\");\n\n//最后设置验证失败的时候所跳转的界面\nshiroFilterFactoryBean.setLoginUrl(\"/toLogin\");\n```\n此时当我们未登陆的时候，点击被拦截的模块，就会跳到我们所指定的网页，而没有拦截的网页则可以正常显示。","tags":["shiro"],"categories":["shiro"]},{"title":"springboot+mybatis整合支付宝支付","url":"/2021/07/22/2021-07-22-springboot+mybatis整合支付宝支付/","content":"\n# springboot+mybatis整合支付宝支付\n\n## 准备支付宝沙箱环境\n\n---\n需要三个网站来准备支付宝的沙箱环境：\n1. [支付宝开放平台](https://opendocs.alipay.com/open/54/104506)\n2. [开放平台-沙箱环境](https://openhome.alipay.com/platform/appDaily.htm?tab=info)\n3. [miniU研发工作室](https://openhome.alipay.com/platform/appDaily.htm?tab=info)\n\n具体配置过程百度即可\n---\n\n## bean类\n\n```\npackage cn.edu.guet.bean;\n\n/**\n * @author George\n * @project DormitorySystem\n * @package cn.edu.guet.bean\n * @date 2021/7/22 11:35\n * @since 1.0\n */\npublic class AlipayBean {\n    /**\n     * 商户订单号，必填\n     *\n     */\n    private String out_trade_no;\n    /**\n     * 订单名称，必填\n     */\n    private String subject;\n    /**\n     * 付款金额，必填\n     * 根据支付宝接口协议，必须使用下划线\n     */\n    private String total_amount;\n    /**\n     * 商品描述，可空\n     */\n    private String body;\n    /**\n     * 超时时间参数\n     */\n    private String timeout_express= \"10m\";\n    /**\n     * 产品编号\n     */\n    private String product_code= \"FAST_INSTANT_TRADE_PAY\";\n\n    public String getOut_trade_no() {\n        return out_trade_no;\n    }\n\n    public void setOut_trade_no(String out_trade_no) {\n        this.out_trade_no = out_trade_no;\n    }\n\n    public String getSubject() {\n        return subject;\n    }\n\n    public void setSubject(String subject) {\n        this.subject = subject;\n    }\n\n    public String getTotal_amount() {\n        return total_amount;\n    }\n\n    public void setTotal_amount(String total_amount) {\n        this.total_amount = total_amount;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public void setBody(String body) {\n        this.body = body;\n    }\n\n    public String getTimeout_express() {\n        return timeout_express;\n    }\n\n    public void setTimeout_express(String timeout_express) {\n        this.timeout_express = timeout_express;\n    }\n\n    public String getProduct_code() {\n        return product_code;\n    }\n\n    public void setProduct_code(String product_code) {\n        this.product_code = product_code;\n    }\n}\n```\n\n## alipayConfig类\n\n```\npackage cn.edu.guet.config;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n/**\n * @author George\n * @project DormitorySystem\n * @package cn.edu.guet.config\n * @date 2021/7/22 13:16\n * @since 1.0\n */\n\npublic class AlipayConfig {\n\n//↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n    // 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号\n    public static String app_id = \"2021000117643373\";\n    // 商户私钥，您的PKCS8格式RSA2私钥\n    public static String merchant_private_key = \"\";\n    // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。\n    public static String alipay_public_key = \"\";\n    // 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问\n    public static String notify_url = \"http://localhost:8082\";\n    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问\n    public static String return_url = \"http://localhost:8082\";\n    // 签名方式\n    public static String sign_type = \"RSA2\";\n    // 字符编码格式\n    public static String charset = \"utf-8\";\n    // 支付宝网关\n    public static String gatewayUrl = \"https://openapi.alipaydev.com/gateway.do\";\n    // 支付宝网关\n    public static String log_path = \"C:\\\\\";\n\n//↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n    /**\n     * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库）\n     * @param sWord 要写入日志里的文本内容\n     */\n    public static void logResult(String sWord) {\n        FileWriter writer = null;\n        try {\n            writer = new FileWriter(log_path + \"alipay_log_\" + System.currentTimeMillis()+\".txt\");\n            writer.write(sWord);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n## controller控制器\n\n**支付**\n```\n@Controller\npublic class AlipayController {\n\n    @RequestMapping(\"/pay\")\n    @ResponseBody\n    public void payController(HttpServletRequest request, HttpServletResponse response) throws IOException, AlipayApiException {\n        // 获取初始化的AliPayClient\n        AlipayClient alipayClient = new DefaultAlipayClient(\n                AlipayConfig.gatewayUrl,\n                AlipayConfig.app_id,\n                AlipayConfig.merchant_private_key,\n                \"json\",\n                AlipayConfig.charset,\n                AlipayConfig.alipay_public_key,\n                AlipayConfig.sign_type);\n        // 设置请求参数\n        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();\n        alipayRequest.setReturnUrl(AlipayConfig.return_url);\n        alipayRequest.setNotifyUrl(AlipayConfig.notify_url);\n        //商户订单号，商户网站订单系统中唯一订单号，必填\n        String out_trade_no = new String(request.getParameter(\"WIDout_trade_no\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //付款金额，必填\n        String total_amount = new String(request.getParameter(\"WIDtotal_amount\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //订单名称，必填\n        String subject = new String(request.getParameter(\"WIDsubject\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //商品描述，可空\n        String body = new String(request.getParameter(\"WIDbody\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        alipayRequest.setBizContent(\"{\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\"\n                + \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\"\n                + \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\"\n                + \"\\\"body\\\":\\\"\"+ body +\"\\\",\"\n                + \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"}\");\n        //若想给BizContent增加其他可选请求参数，以增加自定义超时时间参数timeout_express来举例说明\n        //alipayRequest.setBizContent(\"{\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\"\n        //\t\t+ \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\"\n        //\t\t+ \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\"\n        //\t\t+ \"\\\"body\\\":\\\"\"+ body +\"\\\",\"\n        //\t\t+ \"\\\"timeout_express\\\":\\\"10m\\\",\"\n        //\t\t+ \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"}\");\n        //请求参数可查阅【电脑网站支付的API文档-alipay.trade.page.pay-请求参数】章节\n\n        //请求\n        String result = alipayClient.pageExecute(alipayRequest).getBody();\n\n        //输出\n        response.setContentType(\"text/html;charset=\"+AlipayConfig.charset);\n        response.getWriter().write(result);\n        response.getWriter().flush();\n        response.getWriter().close();\n    }\n}\n```\n\n","tags":["java","SpringBoot","MyBatis"],"categories":["java","SpringBoot","MyBatis"]},{"title":"SpringBoot将图片存储到数据库","url":"/2021/07/21/2021-07-21-Springboot存储图片到数据库/","content":"\n# SpringBoot将图片存储到数据库\n\n## 存储方式\n将图片转化为blob的二进制格式，然后存储到数据库即可，从数据中取出时，将blob格式的二进制文字从数据库中取出，用Object的方式来获取，然后转化为图片的格式，即可在屏幕上显示\n\n## 上传图片\n\n**Controller层**\n\n```\n@PostMapping(\"/add/image\")\n@ResponseBody\npublic String addImage(@RequestParam(\"file\") MultipartFile file,@RequestParam(\"id\") Integer id) throws Exception{\n    if(!file.isEmpty()){\n        BASE64Encoder encoder = new BASE64Encoder();\n        String image = encoder.encode(file.getBytes());\n        TestPo testPo = new TestPo();\n        testPo.setId(id);\n        testPo.setImage(image);\n        testService.addImage(testPo);\n    }\n    return \"ok\";\n}\n```\nControoler层主要对上传的图片文件进行处理，当上传的图片不为空的时候，定义一个字符串加密算法，然后将文件的字节编码进行加密，再定义一个实体类对象，将id以及加密之后的文件发送给业务层。\n\n**Service层**\n\n```\npublic String addImage(TestPo testPo){\n    testMapper.insertImage(testPo);\n    return \"ok\";\n}\n```\n接受Controller的请求并返回对应的类型\n\n**Mapper接口**\n\n```\n@Mapper\npublic interface TestMapper {\n    void insertImage(TestPo testPo);\n}\n```\n\n**Mapper.xml**\n\n```\n<insert id = \"insertImage\" parameterType=\"cn.edu.guet.bean.TestPo\">\n    insert into image(id,image) values(#{id},#{image})\n</insert>\n```\n执行sql语句，进行文件的存储，存储为BLOB格式。\n\n**html页面**\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"http://localhost:8081/add/image\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"text\" name=\"id\" /><br/>\n    <input type=\"file\" name=\"file\" /><br/>\n    <input type=\"submit\" name=\"\" id=\"\" value=\"提交\" />\n</form>\n</body>\n</html>\n```\n![image](https://i.bmp.ovh/imgs/2021/07/f2e9299cb07318f4.png)\n\n## 读取图片\n\n**Controller层**\n\n```\n@GetMapping(\"/get/image\")\n@ResponseBody\npublic void getImage(@RequestParam(\"id\") Integer id, HttpServletResponse response) throws Exception{\n    testService.getImage(id,response);\n}\n```\n主要是接收url请求，根据id给servce层发送请求\n\n**Service层**\n\n```\npublic String getImage(Integer id, HttpServletResponse response){\n    try {\n        TestPo testPo = testMapper.selectImageById(id);\n        byte[] image = (byte[])testPo.getImage();\n        String value = new String(image,\"UTF-8\");\n        BASE64Decoder decoder = new BASE64Decoder();\n        byte[] bytes = decoder.decodeBuffer(value);\n        for(int i=0;i<bytes.length;i++){\n            if(bytes[i]<0){\n                bytes[i]+=256;\n            }\n        }\n        response.setContentType(\"image/jpeg\");\n        ServletOutputStream out = response.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n    }catch (Exception e){\n        e.printStackTrace();\n    }\n\n    return \"ok\";\n}\n```\nservice层对读取出来的二进制进行处理，用byte[]数据类型存储，然后将其转码成UTF-8的格式，此时我们可以得到想要的BASe64字节码，接着将其解码成为byte[]格式，只有这样才能生成图片，setContentType用于设置生成的图片的格式，然后通过流操作，将图片发送到Controller层，最后在前端显示出来\n\n**Maoopper接口**\n\n```\n@Mapper\npublic interface TestMapper {\n    TestPo selectImageById(Integer id);\n}\n```\n\n**Mapper.xml**\n\n```\n<select id=\"selectImageById\" parameterType=\"Integer\" resultType=\"cn.edu.guet.bean.TestPo\">\n    select * from image where id = #{id}\n</select>\n```\n\n**html界面**\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<img src=\"http://localhost:8081/get/image?id=2\" alt=\"Responsive image\">\n</body>\n</html>\n```\n![image](https://i.bmp.ovh/imgs/2021/07/c01afbdf281ae7d2.png)","tags":["java","SpringBoot"],"categories":["java","SpringBoot"]},{"title":"过滤器(Filter)在Web中的应用","url":"/2021/07/01/2021-07-01-过滤器(Filter)在Web中的应用/","content":"\n# Java Web之过滤器(Filter)\n\n## 过滤器(Filter)\n\n过滤器，从字面意思上理解，就是用于过滤作用的工具。\n在Java web中，过滤器的作用是对Web资源进行拦截，经过处理之后，再交给下一步进行处理；而下一步可以是一个新的过滤器，也可以是一个service\n\n","tags":["java"],"categories":["java"]},{"title":"算法学习_罗马数字转整数","url":"/2021/06/28/2021-06-28-算法学习_罗马数字转整数/","content":"\n# 罗马数字转整数\n\n## 题目\n[lettcode-13题](https://leetcode-cn.com/problems/roman-to-integer/) \n难度：简单\n![]( https://i.bmp.ovh/imgs/2021/06/ed551dd42d8355cf.png )\n\n## 解题思路\n对于每个罗马符号所对应的数值，我们可以将其用一个HashMap存起来，将其字符作为key，以及数值为相应的value\n\n在方法中对输入的字符串的所有字符进行遍历，get到所对应的值，并拿到它的后一位数的值，如果当前符号的值大于后一位符号的值，则进行＋运算，否则-运算。\n\n## 具体代码\n```java\n//leetcode项目\nclass Solution {\n    Map<Character,Integer> map=new HashMap<Character,Integer>();\n    public int romanToInt(String s) {\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int ans = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int value = map.get(s.charAt(i));\n            if (i < n - 1 && value < map.get(s.charAt(i + 1))) {\n                ans -= value;\n            } else {\n                ans += value;\n            }\n        }\n        return ans;\n    }\n}\n```","tags":["算法","HashMap"],"categories":["算法","HashMap"]},{"title":"记录博客主页的搭建(二)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(二)/","content":"\n# 记录博客主页的搭建(二)\n\n## 完成上篇文章的所有步骤\n主题是个性化个人博客的很重要的一个模块，当然hexo默认也有一个主题，但是我们可以到[hexo的主题商城](https://hexo.io/themes/)中下载更多我们喜欢的主题。\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/e2ca448dcc957f2e.jpg )\n\n## 选择想要的主题\n\n点击大图可以进行预览，点击名称就可以进入主题的GitHub仓库，就可以进行clone了\n\n然后在本地clone主题的仓库，放到hexo目录的themes文件夹中，再去修改_config.yml文件，就可以应用这个主题了\n\n将theme后面的名称改为刚才clone的文件夹名称，就可以应用主题了\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-aircloud\n```\n\n## 创建标签以及存档\n\n默认的主题是不带有标签和介绍的，这时候需要在博客根目录的source文件夹下建立tags文件夹和about文件夹。\n\n*注：建议不要直接新建文件，而是采用 hexo 的 hexo new page tags 和 hexo new page about 的方式新建文件，这样可以被 hexo 索引到。*\n\n创建好之后在两个文件夹的index.md中分别输入以下内容\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n再次打开主页就会看到生成了两个新的列表\n\n## 更换头像以及网站logo\n\n在博客根目录的 source 文件夹下建立 img 文件夹\n*采用 hexo 的 hexo new page img *\n\n然后并将头像文件命名为avatar.jpg，logo文件命名为favicon.ico\n\n然后修改_config.yml文件，增加以下内容\n```\nsidebar-avatar: img/avatar.jpg\n```\n就可以了\n\n## 网站标题\n在 _config.yml 文件中，增加以下内容\n```\nSEOTitle: George'blog\n```\n冒号后面修改成你想要的名字就可以了\n\n## 签名\n比如最顶端的签名，我们同样可以自定义\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/89d7894724475826.jpg )\n\n只要在_config.yml文件，修改以下内容即可\n```\nsubtitle: 你想要的签名\n```\n\n## 搜索功能\n\n搜索功能同样是不自带的，我们在安装搜索功能之前，首先要安装一个插件\n在git中输入以下命令进行安装\n```\nnpm i hexo-generator-search --save\n```\n\n然后在_config.yml文件中增加以下内容即可\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n## 社交网络\n底部的社交网络我们可以自行修改，但是只能在官方限制的范围内进行修改\n编辑根目录的 _config.yml 文件，增加：\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     5676314204\nzhihu_username:     swaggy-chen\ngithub_username:    chenyicai0819\ntwitter_username:   George chan\n```\n*还有一些其他的社交网络可以参考官方文档*\n\n## 赞赏功能\n\n我们同样可以在我们的博客中添加一个赞赏功能\n只要在img文件夹中增加收款码图片，并命名为donate.jpg\n然后在 _config.yml 文件中增加以下内容，即可在在每篇文章下面增加一个赞赏功能\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n## 修改用户名\n只需修改 _config.yml 文件，中以下内容，即可修改用户名\n```\nauthor: 你的用户名\n```\n\n## 完成主题更换\n\n至此，基本的冤死就已经设置完毕了，基本上只要修改 _config.yml 文件，就可以控制网站中所有的元素了，而官方的帮助文档也写的很清楚如何对各个模块进行设置\n\n我的这篇文章只是针对我的设置进行了一个记录，所以需要更多资料的可以去参考官方的文档，基本上是写的非常明白了\n\n## 部署到GitHub\n\n跟之前一样，完成修改之后要部署到github，只需要以下几行命令\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n\n部署完成之后稍等一会，就可以看到修改之后的内容了\n\n## 相关链接\n\n[官方文档](https://hexo.io/zh-cn/docs/)\n\n[主题商城](https://hexo.io/themes/)\n\n","tags":["Hexo","记录"],"categories":["博客","Hexo"]},{"title":"记录博客主页的搭建(一)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(一)/","content":"\n# 记录博客主页的搭建(一)\n\n## 1.心血来潮\n有一个自己的网站，是我心中一直存在的一个想法，因最近学业压力不是很大，碰巧看到阿里云的域名首年特惠只要一元，就顺便买了一个域名，准备着手搭建个人网站，在此之前，我对博客网站几乎是没有过了解，所以在查阅了一些资料之后，以Hexo+Github Page的方式进行我的网站的搭建，以下就是具体的过程。\n\n## 2.搭建过程\n\n**相关的搭建过程网上随便一找就有很多，我这里只是对我建站的过程进行记录，具有一定参考价值。**\n\n### 2.1 下载node.js以及git并安装\n在使用[Hexo](https://hexo.io/zh-cn/)框架进行搭建网站之前，首先要下载安装[node.js](https://nodejs.org/zh-cn/)和[git](https://git-scm.com/)，以便于安装Hexo以及代码的管理。\n\n*具体的安装注意事项*\n1. Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本\n2. 使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）\n3. 对于中国大陆地区用户，可以前往官网或者淘宝Git for Windows镜像下载 git 安装包（仅针对Windows）\n4. 安装完毕以上两个软件之后就可以进行Hexo的安装了\n### 2.2 安装Hexo\n在想要安装Hexo的位置右键打开**Git Bash Here**通过命令行来进行安装，输入以下命令\n```\nnpm install -g hexo-cli\n```\n点击回车即可进行安装，然后安装完成之后进行一下初始化\n```\nhexo init\nnpm install\n```\n分别输入以上两句并回车，就会生成初始的菜单，大概的目录是这样子的\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n下面是各个目录的具体功能：\n\n**config.yml**\n网站的配置信息，可以在此配置大部分的参数。后面发布到github上面时，有用到这个文件；\n**package.json**\n应用程序的信息\n**source**\n是网站中一下资源的文件夹，博客内容也都放在这里\n**themes**\n网站主题的放置的位置\n\n*其他更具体的介绍可以参考[官方文档](https://hexo.io/zh-cn/docs/)*\n\n### 2.3 预览Hexo博客\n此时就可以预览自己搭建的博客了，但是所有东西都是初始的，输入以下的命令即可\n```\nnpm install hexo-server --save\nhexo server\n```\n*以上命令同样是在Git Bash Here中输入*\n然后在浏览器网址栏输入**localhost:4000**\n如果以上项目能启动就说明成功了，接下来将项目搭建到GitHub上面\n\n### 2.4 将项目部署到GitHub\n1. 在GitHub中新建一个仓库，然后命名为**用户名.github.io**，只有这样子GitHub才会将其设置为用户的博客![]( https://ftp.bmp.ovh/imgs/2021/06/bd90f51e057bd717.jpg )\n\n*因为我已经有一个库了，所以显示错误*\n\n2. **将本地搭建好的hexo发布到github上**\n\n首先输入以下代码安装一个插件\n```\nnpm install hexo-deployer-git --save\n```\n\n修改网站配置文件_config.yml,添加deploy信息\n\n```\ndeploy:\n  type: git \n  repo: git@github.com:用户名/用户名.github.io.git \n  branch: master(也就是想要上传的分支)\n```\n\n3. **生成SSH key**\n\n在git中输入以下命令\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n然后会提示输入passphrase（本步骤可以跳过），相当于设置一个密码，之后跟github进行操作时都会要求输入密码，避免误操作\n然后将新生成的key添加到ssh-agent中\n```\nssh-add ~/.ssh/id_rsa\n```\n就可以在上面的路径下找到ssh的文件了![]( https://ftp.bmp.ovh/imgs/2021/06/1536b7e2cd20e1b1.jpg )\n\n4. **将ssh添加到GitHub中**\n\n打开id_rsa.pub文件将一整串公钥拷贝下来\n打开GitHub的个人设置界面，按照以下图片的步骤进行添加ssh\n![]( https://ftp.bmp.ovh/imgs/2021/06/f27d25e0e14f55ce.jpg )\n\ntitle随意，key填id_rsa.pub文件中内容，然后保存即可。\n至此，就成功将ssh添加到github中了\n\n5. **测试是否连接成功**\n\n输入以下命令\n```\nssh -T git@github.com\n```\n如果出现以下文字就说明连接成功了\n```\nHi wispyoureyes! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n6. 上传静态文件\n\n成功与GitHub建立连接之后，就可以生成静态文件上传到github中了\n\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n然后再网址栏输入GitHub仓库的名称就可以访问了\n\n## 3.绑定域名\n\n1. 首先到阿里云或者其他的云服务商购买一个域名\n2. 然后进行域名解析\n3. 登陆阿里云控制台，选择域名选项，添加两条CNAME解析\n4. 然后在GitHub的仓库设置中，下滑找到Github Pages ，点击进去，在Custom domain里填入你的域名，然后点击Save，稍等一会就好了。\n5. 然后就可以通过你的域名来进入博客了\n\n*关于备案，如果要部署到国内的服务器上面需要进行备案，从哪里买的域名就从哪里备案GitHub属于国外的服务器，是不用进行备案的*\n\n\n\n## 4.相关链接\n\n[生成ssh](https://www.jianshu.com/p/31cbbbc5f9fa/)\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\n[阿里云](https://www.aliyun.com/?spm=5176.12901015.0.i12901015.ba0e525c2qLtLM)\n\n[淘宝git for windows 镜像](https://npm.taobao.org/mirrors/git-for-windows/)\n\n[淘宝node.js镜像](https://npm.taobao.org/mirrors/node)","tags":["Hexo","记录"],"categories":["博客","Hexo"]},{"title":"基于Swing的简易点餐系统","url":"/2021/06/21/2021-06-21-基于Swing的简易点餐系统/","content":"\n# 基于Swing的建议点餐系统\n\n## 1. 应用技术\n```\nSwing、JDBC、Oracle数据库、Java基础\n```\n## 2.项目功能\n```\n工作人员：菜品的增删改查、工作人员点餐、为顾客进行排号叫号、利润查询、结账。\n顾客：顾客点餐、查看积分、查看菜单、自助结账。\n```\n## 3.项目历程\n### 3.1 项目准备\n\n总所周知，Swing对于Java来说已经是一个不再使用的技术了，相对于微软的C#语言，Java的优势更在于Web端的应用，但是应教学的要求，主要是为了练习JDBC以及PL/SQL的使用，我们使用了Swing技术配合数据库使用，制作了一个简易的点餐系统，旨在熟悉一个项目的制作流程，从项目需求分析到项目开发到最后的维护发布，我作为小组长，带领了团队一共7位队员在老师的指导之下，完成了项目的开发。\n\n### 3.2 项目开发背景\n\n据了解，学校周围部分餐馆仍处于人工点餐、手工记账的阶段，这样子不仅容易在点餐时出现错记误记的情况，在最后记录时大量的数据也会十分繁琐，计算机软件统一的处理方式可以将以上的过程全都自动化一站式地完成，大大提高了效率；除此之外，使用计算机系统还大大减少了成本。\n发展点餐系统，是一种必然趋势，可以说点餐系统的出现，只是用现在较为成熟的计算机技术去改造传统行业的一个小小例子。这样的系统，将会不断地出现，而且会有力地推动传统行业的不断发展。\n\n### 3.3 项目开发\n\n在开始项目的开发之后，由于队员基础的参差不齐，所以在任务分配时对队员的能力分配了不同的任务，并针对队员能力进行了不同知识点的针对，由于是首次进行团队项目开发，并没有使用到GitHub进行协作开发，所以在最后整合代码时，碰到了较大的问题，jdk版本不统一，代码不能兼容等等问题，最后整合的代码也还有着大量的冗余，开发过程总体来说比较顺利，但是还是有很大的改进，在开发前进行数据库设计时，虽然说没有太多的表，但是对于项目小白的我们还是花费了一点时间。\n\n\n### 3.4 项目源码\n```\nhttps://github.com/chenyicai0819/2020_java_study/tree/main/OrderSystemToSix\n```","tags":["Swing"],"categories":["java","Swing"]},{"title":"我的第一条博客","url":"/2021/06/21/2021-06-21-我的第一条博客/","content":"\n# 这是我的第一条博客\n\n**1.初次接触**\n\n今天是2021年6月21日。我搭建了我的第一个个人博客网站，并发布了我的第一条个人博客，今后我会在上面发布一些自己的学习经历，个人感想等内容。\n","tags":["随笔"],"categories":["随笔"]}]