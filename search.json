[{"title":"Redis进阶学习","url":"/2022/06/18/2022-06-18-Redis进阶/","content":"\n# Redis进阶学习\n\n## 1、Redis事务\n\n### 1.1、事务的概念\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；但是队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。也就是说 Redis 的事务具有**隔离性**，但是它没有**隔离级别**的概念。\n\n其次，Redis 事务不保证原子性。在 Redis 中，单条命令是原子性执行的，但是事务不保证原子性，且没有回滚。如：事务在执行 EXEC 之前，入队的命令可能会出错。命令可能在 EXEC 调用后失败。\n\n以下是 Redis 事务从开始到执行会经历的三个阶段：\n1. 开始事务。\n2. 命令入队。\n3. 执行事务。\n\n### 1.2、事务中的几个重要命令\n\n1. 开启事务：`multi`\n2. 执行所有事务：`exec`\n3. 取消事务，放弃执行所有事务：`discard`\n4. 监视一个或多个 key ，如果在事务执行之前 key 被其他命令改动，则终止事务：`watch`\n5. 取消对 key 的监视：`unwatch`\n\n------\n\n如何执行？如下：\n从执行 `Multi` 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入完成\n执行 `exec` 后，Redis 会将之前的命令队列中的命令依次执行。\n组队的过程中可以通过 `discard` 来放弃组队。\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226170944.png)\n\n从执行 `multi` 命令到执行 `exec` 这段过程中，如果某一个命令出现了错误，那么整个队列都会取消。而当执行了 `exec` 命令之后，如果有命令出现了错误，那么只有出现错误的命令不会被执行，其他的命令不会被影响。\n\n**示例如下：**\n\n执行事务：\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226171736.png)\n放弃事务：\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226171704.png)\n若在事务队列中存在命令性错误（类似于 java 编译性错误），则执行 EXEC 命令时，所有命令都不会执行:\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226171748.png)\n若在事务队列中存在语法性错误（类似于 java 的 1/0 的运行时异常），则执行 EXEC 命令时，其他正确命令会被执行，错误命令抛出异常:\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226171708.png)\n\n## 2、锁\n### 2.1、悲观锁\n悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，认为这个世界是黑暗的，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226172953.png)\n\n### 2.2、乐观锁\n乐观锁(Optimistic Lock)，顾名思义，就是很乐观，认为这个世界是光明的，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis 就是利用这种 check-and-set 机制实现事务的。\n\n而 Redis 中默认使用的就是乐观锁。\n通过上一章中的命令 `watch`，我们可以实现乐观锁。\n```sh\nwatch key [key] ...\n```\n\n例如：很多人同时对一个值进行操作，一旦这个值被修改，且被其他人监听，则其他人无法修改这个值。\n\n通过 `unwatch`，可以取消乐观锁。\n```sh\nunwatch key [key] ...\n```\n\n缺点：如果单纯使用 watch，可能导致 key 的值无法完全被修改。\n\n场景：假设库存有 500 个商品，2000 个人进行秒杀购买(2000 个程序监听商品的 key)，假设 1999 人同时购买，其内部程序监听的商品数量为 500，最后一个人却已经购买成功，商品数量变为499，则前面的事务被打断(监听的 500 数量)，导致 1999 人会购买失败，库存还有 499 个商品。\n\n\n## 3、持久化\n\nRedis 提供了以下 2 个不同形式的持久化方式：\n1. RDB（Redis DataBase）\n2. AOF（Append Of File）\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/62012015313f478fa67559d0aa9105a9.png)\n\n我们分成两个部分进行学习。\n### 3.1、RDB持久化\nRedis 中默认使用的就是 RDB 的持久化方式。\n该种方式在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是 Snapshot 快照，它恢复时是将快照文件直接读到内存里。\n\n#### 3.1.1、备份的执行过程\nRedis会单独创建fork一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化都结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主进程是不进行任何IO操作的。这就确保了级高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式就要比AOF方式更加的高效。\n<u>RDB 的缺点是最后一次持久化之后的数据可能丢失</u>\n\n我们在生产环境会将 `dump.rdb` 这个文件进行备份。\n\n以下是 RDB 持久化的一个执行流程：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/b4caafff95b841debb86bc82157d5f8b.png)\n\nRDB 所保存的文件就是 `dump.rdb` 文件。他的好处就是：效率高。\n\n#### 3.1.4、RDB 的备份策略\n对于 RDB 的备份策略，如下所示：\n```\nsave 3600 1     -- 如果 1 个 key 发生改变（增删改），则 1 个小时后备份一次\nsave 300 100    -- 如果 100 个 key 发生改变（增删改），则 5 分钟后备份一次\nsave 60 10000\t-- 如果 10000 个 key 发生改变（增删改），则 1 分钟后备份一次\n\n# save <秒钟> <写操作次数>\n```\n除此之外，还可以手动执行命令生成 RDB 快照，进入 redis 客户端执行命令 `save` 或`bgsave`可以生成 `dump.rdb` 文件。\n每次命令执行都会将所有 redis 内存快照到一个新的 `.rdb` 文件里，并覆盖原有 `.rdb` 快照文件。\n\n其中：\n\n|                  | save             | bgsave                   |\n| ---------------- | ---------------- | ------------------------ |\n| IO类型           | 同步             | 异步                     |\n| 是否阻塞其他命令 | 是               | 否(fork的时候会短暂阻塞) |\n| 复杂度           | O(n)             | O(n)                     |\n| 优点             | 不会消耗额外内存 | 不阻塞操作               |\n| 缺点             | 阻塞操作         | 会消耗额外内存           |\n\n- save：save 时只管保存，其它不管，全部阻塞。手动保存。**不建议**\n- bgsave：Redis 会在后台异步进行快照操作，快照同时还可以响应客户端请求。**推荐**\n\n**配置自动生成rdb文件后台使用的是bgsave方式。**\n\n#### 3.1.4、RDB 持久化方式的优缺点\n**优点：**\n\t因为dump.rdb文件是二进制文件，所以当redis服务崩溃恢复的时候，能很快的将文件数据恢复到内存之中。\n\t适合大规模的数据恢复\n\t对数据完整性和一致性要求不高更适合使用\n\t节省磁盘空间\n**缺点：**\n\tRDB每次持久化需要将所有内存数据写入文件，然后替换原有文件，当内存数据量很大的时候，频繁的生成快照会很耗性能。\n\t如果将生成快照的策略设置的时间间隔很大，会导致redis宕机的时候丢失过的的数据。\n\tFork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑\n\n### 3.2、AOF持久化\n为解决RDB方式丢失数据的问题，从1.1版本开始，redis 增加了一种更加可靠的方式：AOF 持久化方式。\n在使用AOF方式时，redis 每执行一次修改数据命令，都会将该命令追加到 appendonly.aof 文件中（先写入 os cache，然后通过 sync 刷盘）。\n\n#### 3.2.1、AOF 的持久化流程\n\n1. 客户端的请求写命令会被 append 追加到 AOF 缓冲区内；\n2. AOF 缓冲区根据 AOF 持久化策略[always,everysec,no]将操作 sync 同步到磁盘的 AOF 文件中；\n3. AOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩 AOF 文件容量；\n4. Redis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的；\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226200544.png)\n\n#### 3.2.2、开启 AOF 持久化\n由于 Redis 默认使用的是 RDB 持久化方式，所以我们需要手动开启 AOF 持久化。\n默认情况下，配置文件如下：\n```\nappendonly no\n```\n如果需要开启，所以通过将 `no` 修改成 `yes` 即可开启。\nredis重启的时候，会重放 appendonly.aof 中的命令恢复数据。\n\n如果两者同时开启，Redis 所使用的是 AOF 的持久化。\n\n对于 AOF，有三种同步频率可供配置：\n```\nappendfsync always：每次执行写命令都会刷盘，非常慢，也非常安全。\nappendfsync everysec：每秒刷盘一次，兼顾性能和安全。\nappendfsync no：将刷盘操作交给系统，很快，不安全。\n```\n推荐使用 `everysec`，该策略下，最多会丢1秒的数据。\n\n#### 3.2.3、AOF重写\n因为 `appendonly.aof` 文件中存储的是执行命令，所以会产生很多没用的命令，因此，redis 会定期根据最新的内存数据生成新的 `.aof` 文件。\n\n**<u>如何使用重写？命令如下：</u>**\n\n```\nno-appendfsync-on-rewrite yes\n```\n\n如果 `no-appendfsync-on-rewrite` 改为 `yes`，代表不写入 AOF 文件，只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高 性能）\n如果 `no-appendfsync-on-rewrite` 改为 `no`，还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）\n\n**<u>那么怎么样才会触发重写呢？如下：</u>**\n\nRedis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发。\n重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定 Redis 要满足一定条件才会进行重写。\n下面两个配置可以控制`.aof` 文件重写的频率：\n```\n auto‐aof‐rewrite‐min‐size 64mb：\t-- aof文件至少达到了64m才会触发重写\n auto‐aof‐rewrite‐percentage 100：\t-- 距离上次重写增长了100%才会再次触发重写\n```\n\nAOF 重写的流程：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226203142.png)\n1. bgrewriteaof 触发重写，判断是否当前有 bgsave 或 bgrewriteaof 在运行，如果有，则等待该命令结束后再继续执行\n2. 主进程 fork 出子进程执行重写操作，保证主进程不会阻塞\n3. 子进程遍历 redis 内存中数据到临时文件，客户端的写请求同时写入 aof_buf 缓冲区和 aof_rewrite_buf 重写缓冲区保证原 AOF 文件完整以及新 AOF 文件生成期间的 新的数据修改动作不会丢失\n4. 子进程写完新的 AOF 文件后，向主进程发信号，父进程更新统计信息\n5. 主进程把 aof_rewrite_buf 中的数据写入到新的 AOF 文件。\n6. 使用新的 AOF 文件覆盖旧的 AOF 文件，完成 AOF 重写\n\n#### 3.2.4、AOF 的优缺点\n优点：\n\t备份机制更稳健，丢失数据概率更低\n\t可读的日志文本，通过操作 AOF 稳健，可以处理误操作\n缺点：\n\t比起 RDB 占用更多的磁盘空间\n\t恢复备份速度要慢\n\t每次读写都同步的话，有一定的性能压力\n\t存在个别 Bug，造成恢复不能\n\n### 3.3、RDB和AOF对比\n\n| 命令       | RDB        | AOF                      |\n| ---------- | ---------- | ------------------------ |\n| 启动优先级 | 低         | 高                       |\n| 体积       | 小         | 大                       |\n| 恢复速度   | 快         | 慢                       |\n| 数据安全性 | 容易丢数据 | 根据策略而定，相对不容易 |\n\n## 4、主从复制\n\n### 4.1、什么是主从复制\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226205002.png)\n主从复制是指将一台 Redis 服务的数据，复制到其他 Redis 服务器上。前者称为主节点（master），后者称为从节点（slave）。数据的复制是单向的，只能从主节点到从节点。\n其中 Master 以写为主，Slave 以读为主。\n默认情况下，每一台 Redis 服务都是主节点，一个主节点可以有多个从节点（也可以没有），但一个从节点只能有一个主节点。\n\n**为什么要有主从复制呢？**\n假设只有一台 Redis 服务，这时候是单机模式。首先会出现第一个问题：如果 Redis 服务宕机了，就会造成数据的丢失，会造成很大的损失。\n第二个问题：一台服务器的内存是有限的，尽管内存可以升级，但是终究是有限的，所以通过多台服务器可以减轻服务器的压力。\n\n针对上述问题，我们需要准备多台服务器，配置主从复制。将数据保存在多台服务器上，并且保证每台服务器的数据是同步的。即使有一台服务器宕机，也不影响用户的使用。redis 可以继续实现高可用，同时实现数据的冗余备份。\n\n所以就要有主从复制，那么**主从复制的具体作用**是什么呢？\n\n1. 数据冗余，实现数据的热备份，这也是持久化实现的另一种方式。\n2. 针对单机故障问题，一个节点故障，其他节点可以提供服务，不影响用户使用。实现了快速恢复故障，这也是服务冗余。\n3. 读写分离，master 服务主要用来写，slave 服务主要用来读数据。可以提高服务器的负载能力，可以根据需求的变化，添加从节点的数量。\n4. 负载均衡，同时配合读写分离，由主节点提供写服务，从节点提供读服务，分担服务器的负载。在写少读多的情况下，通过多个从节点分担读负载，能够大大提高 Redis 服务的并发量和负载。\n5. 高可用的基石，主从复制是哨兵和集群模式能够实施的基础。\n\n### 4.2、主从复制的实现原理\n\nRedis 的主从复制分为以下两个阶段：`sync` 阶段和 `command propagate` 阶段。\n\n#### 4.2.1、sync(同步)阶段\n\n当从节点启动之后，会发送 `sync` 指令给主节点，要求全量同步数据，具体的步骤如下图所示：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/rZEJmRMT6Gpxgiz.png)\n1. Slave 节点向 Master 节点发送 sync 指令，以请求数据同步\n2. Master 节点在接收到 sync 指令后，会执行一次 BGSAVE 指令，将当前 Master 节点中的数据保存到对应的 RDB 文件中。当 Master 节点完成 RDB 文件的导出后，再将导出的 RBD 文件发送给 Slave 节点。由于在这个过程中 Master 节点依旧有可能发生数据写入操作，在这种情况下 Master 节点会将执行的指令放入到对应的缓冲区\n3. Slave 节点在接受到 Master 节点导出的 RDB 文件之后，会删除现有节点的所有数据，然后加载这个 RDB 文件的内容到 Slave 节点\n4. 当 Slave 节点数据加载完成之后，Master 会将缓冲区中暂存的指令发送到 Slave 节点\n5. Slave 执行收到的指令，完成数据的同步\n\n#### 4.2.2、Command Propagate(命令传播)阶段\n\n数据同步完成之后，如果后续 Master 节点继续收到了新的写入操作的指令，那么也需要将该命令传播到 Slave 节点以完成数据的同步。这个过程就被称为 “命令传播”。\n\n主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。\n后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。\n而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。\n上面的这个过程被称为基于长连接的命令传播，通过这种方式来保证第一次同步后的主从服务器的数据一致性。\n\n### 4.3、配置主从复制\n\n首先在本地启动三个 Redis 服务，用来模拟不同服务器上面的 Redis 服务。\n\n**一主二从**\n主服务器：\n```shell\ninclude /etc/redis.conf    # 核心配置文件\npidfile /var/run/redis_6379.pid   # 固定\nport 6379    #端口\ndbfilename dump6379.rdb   # 持久化备份文件\ndaemonize yes\nprotected-mode no\ndir \"/myredis\"  # 备份文件路径，自定义\n```\n\n从服务器：\n```shell\ninclude /etc/redis.conf    # 核心配置文件\npidfile /var/run/redis_6380.pid   # 固定\nport 6380    #端口\ndbfilename dump6380.rdb   # 持久化备份文件\ndaemonize yes   \nprotected-mode no\ndir \"/myredis\"  # 备份文件路径，自定义\n\n################################################### \n\ninclude /etc/redis.conf    # 核心配置文件\npidfile /var/run/redis_6381.pid   # 固定\nport 6381    #端口\ndbfilename dump6381.rdb   # 持久化备份文件\ndaemonize yes\nprotected-mode no\ndir \"/myredis\"  # 备份文件路径，自定义\n```\n\n如果重新配置了文件内容，则需要重启 Redis 服务。\n启动好 3 个不同端口服务后，我们再分别开启 Redis 连接:\n```shell\nredis-cli -p 6379\nredis-cli -p 6380\nredis-cli -p 6381\n```\n通过 `info replication` 指令查看信息:\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226205444.png)\n可以发现，默认情况下，开启的每个 Redis 服务器都是主节点。\n\n所以，现在我们要配置为一个 Master 和 两个 Slave（即一主二从）\t\n6379 为主，6380、6381 为从，分别在 6380、6381 的 Redis 上执行如下指令：\n```shell\nslaveof 127.0.0.1 6379\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226205520.png)\n然后，6080和6381就变成了从机，在主机设置值，在从机都可以取到，但是从机不能写值。\n\n但是我们这里是使用命令搭建，是「暂时的」，如果重启三个 Redis 服务，则又恢复到三主的地位。\n如果想配置「永久的」，则去配置里进行修改，找到 `slaveof <ip> <port>` 指令进行配置：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226205703.png)\n\n当主机断电宕机后，默认情况下从机的角色不会发生变化，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。\n\n当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。\n\n**薪火相传**\n上一个 Slave 可以是下一个 Slave 和 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master，可以有效减轻 Master 的写压力，去中心化降低风险。\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226210451.png)\n在一个从机用 `slaveof <ip> <port>` 指令连接另一个从机。\n![](https://fastly.jsdelivr.net/gh/Kele-Bingtang/static/img/Redis/20211226210356.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226210314.png)\n\n**反客为主**\n当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何修改。\n有两种方式可以产生新的主机：\n1. 从机手动执行命令 `slaveof no one`，这样执行以后从机会独立出来成为一个主机\n2. 使用哨兵模式（自动选举）\n\n### 4.4、哨兵模式\n\n#### 4.4.1、什么是哨兵模式？\n主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis 从 2.8 开始正式提供了 Sentinel（哨兵）架构来解决这个问题。\n\n哨兵模式就是自动实现反客为主的一种形式，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n\n哨兵模式是一种特殊的模式，首先 Redis 提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是 哨兵通过发送命令，等待 Redis 服务器响应，从而监控运行的多个 Redis 实例。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226211059.png)\n\n这里的哨兵有两个作用：\n\n1. 通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器。\n2. 当哨兵监测到 Master 宕机，会自动将 Slave 切换成 Master，然后通过 发布订阅模式 通知其他的从服务器，修改配置文件，让它们切换主机。\n\n然而一个哨兵进程对 Redis 服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226211245.png)\n\n假设主服务器宕机，哨兵 1 先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵 1 主观的认为主服务器不可用，这个现象成为 主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover [故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线。\n\n#### 4.4.2、配置哨兵模式\n\n配置哨兵配置文件 `sentinel.conf`：\n```shell\n#sentinel monitor 主机名称 host port 1\nsentinel monitor myredis 127.0.0.1 6379 1\n\n# 最后面的1，代表主机挂了，Slave投票看谁接替成为主机，票数最多的，就会成为主机\n```\n启动哨兵：\n```shell\nredis-sentinel myredis/sentinel.conf\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226211701.png)\n此时哨兵监视着我们的主机 6379，当我们断开主机后：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211226211710.png)\n哪个从机会被选举为主机呢？根据优先级别：`slave-priority`，这个指令需要去每个从机的配置文件进行配置，默认都是 100。\n\n建议每个从机都配置不同的 `slave-priority`，这样可以避免复制延时。\n\n**需要注意的是：值越小优先级越高。**\n\n复制延时：由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。\n\n**哨兵模式的优缺点：**\n优点：\n\t哨兵集群，基于主从复制模式，所有主从复制的优点，它都有\n\t主从可以切换，故障可以转移，系统的可用性更好\n\t哨兵模式是主从模式的升级，手动到自动，更加健壮\n缺点：\n\tRedis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦\n\t实现哨兵模式的配置其实是很麻烦的，里面有很多配置项\n\n**以下是哨兵模式的完整配置：**\n\n```shell\n# Example sentinel.conf\n \n# 哨兵 sentinel 实例运行的端口 默认 26379\nport 26379\n \n# 哨兵 sentinel 的工作目录\ndir /tmp\n \n# 哨兵 sentinel 监控的 redis 主节点的 ip port \n# master-name：可以自己命名的主节点名字 只能由字母 A-z、数字 0-9 、这三个字符 \".-_\" 组成。\n# quorum：当这些 quorum 个数 sentinel 哨兵认为 Master 主节点失联 那么这时客观上认为主节点失联了\n# sentinel monitor <master-name> <ip> <redis-port> <quorum>\nsentinel monitor mymaster 127.0.0.1 6379 1\n \n# 当在 Redis 实例中开启了 requirepass foobared 授权密码 这样所有连接 Redis 实例的客户端都要提供密码\n# 设置哨兵 sentinel 连接主从的密码 注意必须为主从设置一样的验证密码\n# sentinel auth-pass <master-name> <password>\nsentinel auth-pass mymaster MySUPER--secret-0123passw0rd\n \n# 指定多少毫秒之后 主节点没有应答哨兵 sentinel 此时 哨兵主观上认为主节点下线 默认 30 秒\n# sentinel down-after-milliseconds <master-name> <milliseconds>\nsentinel down-after-milliseconds mymaster 30000\n \n# 这个配置项指定了在发生 failover 主备切换时最多可以有多少个 Slave 同时对新的 Master 进行同步，\n# 这个数字越小，完成 failover 所需的时间就越长，\n# 但是如果这个数字越大，就意味着越 多的 Slave 因为 replication 而不可用。\n# 可以通过将这个值设为 1 来保证每次只有一个 Slave 处于不能处理命令请求的状态。\n# sentinel parallel-syncs <master-name> <numslaves>\nsentinel parallel-syncs mymaster 1\n \n# 故障转移的超时时间 failover-timeout 可以用在以下这些方面： \n#1. 同一个 sentinel 对同一个 Master 两次 failover 之间的间隔时间。\n#2. 当一个 Slave 从一个错误的 Master 那里同步数据开始计算时间。直到 Slave 被纠正为向正确的 Master 那里同步数据时。\n#3. 当想要取消一个正在进行的 failover 所需要的时间。  \n#4. 当进行 failover 时，配置所有 Slaves 指向新的 Master 所需的最大时间。不过，即使过了这个超时，Slaves 依然会被正确配置为指向Master，但是就不按 parallel-syncs 所配置的规则来了\n# 默认三分钟\n# sentinel failover-timeout <master-name> <milliseconds>\nsentinel failover-timeout mymaster 180000\n \n# SCRIPTS EXECUTION\n \n# 配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。\n# 对于脚本的运行结果有以下规则：\n# 若脚本执行后返回 1，那么该脚本稍后将会被再次执行，重复次数目前默认为 10\n# 若脚本执行后返回 2，或者比 2 更高的一个返回值，脚本将不会重复执行。\n# 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。\n# 一个脚本的最大执行时间为 60s，如果超过这个时间，脚本将会被一个 SIGKILL 信号终止，之后重新执行。\n \n# 通知型脚本:当 sentinel 有任何警告级别的事件发生时（比如说 Redis 实例的主观失效和客观失效等等），将会去调用这个脚本，\n# 这时这个脚本应该通过邮件，SMS 等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，\n# 一个是事件的类型，\n# 一个是事件的描述。\n# 如果 sentinel.conf 配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则 sentinel 无法正常启动成功。\n# 通知脚本\n# sentinel notification-script <master-name> <script-path>\nsentinel notification-script mymaster /var/redis/notify.sh\n \n# 客户端重新配置主节点参数脚本\n# 当一个 Master 由于 failover 而发生改变时，这个脚本将会被调用，通知相关的客户端关于 Master 地址已经发生改变的信息。\n# 以下参数将会在调用脚本时传给脚本:\n# <master-name> <role> <state> <from-ip> <from-port> <to-ip> <to-port>\n# 目前 <state> 总是「failover」,\n# <role> 是「leader」或者「observer」中的一个。 \n# 参数 from-ip, from-port, to-ip, to-port 是用来和旧的 Master 和新的 Master(即旧的 Slave)通信的\n# 这个脚本应该是通用的，能被多次调用，不是针对性的。\n# sentinel client-reconfig-script <master-name> <script-path>\nsentinel client-reconfig-script mymaster /var/redis/reconfig.sh\n```","tags":["数据库","redis"],"categories":["数据库","redis"]},{"title":"算法学习—二分查找","url":"/2022/06/16/2022-06-16-算法学习—二分查找/","content":"\n# 算法学习—二分查找\n\n## 1、二分查找的概念\n当我们碰到需要获取数列中的元素或者利用数列中的元素时，最快想到的方法就是通过顺序查找，一个一个找下去，这种查找方式基本上市从头开始到末尾，将所有的元素都找一遍，直到找到了想要的元素。\n这种方法因为是需要查找所有的元素，所以当元素数量太多的时候，就会出现超时的情况出现，效率十分低下，所以一般实际的情况下我们不是用顺序查找。\n取而代之的，是二分查找。二分查找顾名思义，就是将一个数列分成两个部分，分别查找元素。虽然说该种方法比较高效，但是这种方法是建立在数列有序的基础上的，所以对于一些不能排序的数列，可能不适用二分查找；除此之外，二分查找的结果只能是一个，不能是多个。\n\n## 2、基本思想\n\n二分查找的基本思想是：我们首先定义两个首尾元素，一般一开始默认是在数列的第一位以及最后一位。然后我们找到两个首尾元素的中间点元素 mid ，将该元素与我们作为比较的元素相对比，然后决定我们下一步所取的数列的区间范围。而在所取范围之外的另一半的元素我们自然就不用再查找了，效率就大大地提高了。\n\n## 3、解题步骤\n\n1.将数列排序\n2.通过首尾节点确定中间点元素 mid\n3.将mid与比较的元素相对比，判断下一次所取的区间\n4.最后只剩下一个结果时，结束\n\n## 4、二分查找的模板\n### 4.1、第一类：数据无重复查找数据\n\n所要查找的数据如下所示：\n\n位置：0 1 2 3 4 5 6 7 8 9\n数据：1 2 3 4 5 <u>**6**</u> 7 8 9 10\n\n代码：\n```java\npublic int binarySearch(int[] numbers, int target) {\n    int left = 0;\n    int right = numbers.length - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (numbers[middle] == target) {\n            return middle;\n        }else if (numbers[middle] > target) {\n            right = middle - 1;\n        }else {\n            left = middle + 1;\n        }\n    }\n    return -1;\n}\n```\n\n### 4.2、第二类：数据有重复查找小于该数的最后一个数字的位置\n\n位置：0 1 2 3 4 5 6 7 8 9\n数据：1 1 2 <u>**2**</u> 3 3 3 3 4 4\n\n在本类型中，我们查找小于3的最后一个数据的位置。\n\n代码：\n```java\npublic int binarySearch(int[] numbers, int target) {\n    int left = 0;\n    int right = numbers.length - 1;\n    while (left < right) {\n        int middle = left + (right - left + 1) / 2;\n        if (numbers[middle] == target) {\n            right = middle - 1;\n        }else if (numbers[middle] > target) {\n            right = middle - 1;\n        }else {\n            left = middle;\n        }\n    }\n    return left;\n}\n```\n\n### 4.3、第三类：数据有重复查找该数字第一次出现的位置\n\n位置：0 1 2 3 4 5 6 7 8 9\n数据：1 1 2 2 <u>**3**</u> 3 3 3 4 4\n\n在本类中，我们查找数字3第一次出现的位置。\n\n```java\npublic int binarySearch(int[] numbers, int target) {\n    int left = 0;\n    int right = numbers.length - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (numbers[middle] == target) {\n            right = middle;\n        }else if (numbers[middle] > target) {\n            right = middle;\n        }else {\n            left = middle + 1;\n        }\n    }\n    return left;\n}\n```\n\n### 4.4、第四类：数据有重复查找该数字最后一次出现的位置\n\n位置：0 1 2 3 4 5 6 7 8 9\n数据：1 1 2 2 3 3 3 <u>**3**</u> 4 4\n\n在本类中，我们查找数字3最后一次出现的位置。\n\n```java\npublic int binarySearch(int[] numbers, int target) {\n    int left = 0;\n    int right = numbers.length - 1;\n    while (left < right) {\n        int middle = left + (right - left + 1) / 2;\n        if (numbers[middle] == target) {\n            left = middle;\n        }else if (numbers[middle] > target) {\n            right = middle - 1;\n        }else {\n            left = middle;\n        }\n    }\n    return left;\n}\n```\n\n### 4.5、第五类：数据有重复查找第一个大于该数的数字的位置\n\n位置：0 1 2 3 4 5 6 7 8 9\n数据：1 1 2 2 3 3 3 3 <u>**4**</u> 4\n\n在本类中，我们查找第一个大于数字3的数字的位置。\n\n```java\npublic int binarySearch(int[] numbers, int target) {\n    int left = 0;\n    int right = numbers.length - 1;\n    while (left < right) {\n        int middle = left + (right - left ) / 2;\n        if (numbers[middle] == target) {\n            left = middle + 1;\n        }else if (numbers[middle] > target) {\n            right = middle;\n        }else {\n            left = middle + 1;\n        }\n    }\n    return left;\n}\n```\n\n## 5、实际例子\n\n### 5.1、搜索插入位置\n\n[leetcode-35](https://leetcode.cn/problems/search-insert-position/)\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n示例1：\n```\n输入: nums = [1,3,5,6], target = 5\n输出: 2\n```\n\n示例2：\n```\n输入: nums = [1,3,5,6], target = 2\n输出: 1\n```\n\n提示：\n```\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums 为 无重复元素 的 升序 排列数组\n-104 <= target <= 104\n```\n\n解题思路：\n\n该题目的意思是在数列中找到一个目标值，并返回其索引，所以该题符合 类型一 的情况。\n我们假设该位置为 pos ，所以有成立的条件为：\n$$\nnums[pos−1]<target≤nums[pos]\n$$\n其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。\n\n完整代码：\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left=0,right=nums.length;\n        while(left<right){\n            int mid=left+(right-left)/2;\n            if(nums[mid]>=target){\n                right=mid;\n            }else{\n                left=mid+1;\n            }\n        }\n        return left;\n    }\n}\n```\n\n### 5.2、x 的平方根 \n\n[leetcode-69](https://leetcode.cn/problems/sqrtx/)\n\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n\n示例1：\n```\n输入：x = 4\n输出：2\n```\n\n示例2：\n```\n输入：x = 8\n输出：2\n解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n```\n\n提示：\n```\n0 <= x <= 231 - 1\n```\n\n解题思路：\n由于 x 平方根的整数部分 ans 是满足`k的平方小于等于x`的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。\n\n二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 xx 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。\n\n完整代码：\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int left=0;\n        int right=x;\n        int num=-1;\n        while (left<=right){\n            int mid=(left+right)/2;\n            if ((long)mid*mid<=x){\n                num=mid;\n                left=mid+1;\n            }else {\n                right=mid-1;\n            }\n        }\n        return num;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"算法学习—回溯法","url":"/2022/06/15/2022-06-15-算法学习—回溯法/","content":"\n# 算法学习—回溯法\n\n## 1、回溯法的概念\n\n回溯法，顾名思义就是不断地重复枚举结果集，直到找到我们所要的结果。这种思想类似于暴力搜索，但是又与暴力搜索有着不同，回溯法使用了剪枝函数，除去了一些错误的解法。\n回溯法在搜索的过程中，如果发现这一步的结果不符合结果的要求，则会放弃下面的查找，回溯到上一步，更换一种新的查找方式，它其实是一种选优搜索，根据选优条件逐步搜索，以达到目标。回溯法中满足回溯条件的点我们称为 “回溯点”。\n在一些复杂问题，或者是比较大规模的问题中，我们都可以使用回溯法来解决，所以回溯法也有着“通用解题方法”的美称。\n\n## 2、基本思想\n\n回溯法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条新的路尝试。回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。\n\n## 3、解题步骤\n\n1.定义一个解空间，它包含问题的解；\n2.利用适于搜索的方法组织解空间；\n3.利用深度优先法搜索解空间；\n4.利用限界函数避免移动到不可能产生解的子空间。\n\n## 4、实际例子\n\n### 4.1、全排列问题\n\n[leetcode-46](https://leetcode.cn/problems/permutations/)\n\n题目：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 **按任意顺序** 返回答案。\n\n示例1：\t\n```\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n示例2：\t\n```\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n```\n\n提示：\n```\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n```\n\n解题思路：\n\n这个全排列问题是一个典型的回溯法问题。从左到右，我们不断尝试所有可能的结果，如果有出现重复的结果就除去，\n\n我们定义递归函数 backtrack(first,output) 表示从左往右填到第 first 个位置，当前排列为  output。 那么整个递归函数分为两个情况：\n\n1. 如果 first=n，说明我们已经填完了 n 个位置（注意下标从 0 开始），找到了一个可行的解，我们将 output 放入答案数组中，递归结束。\n2. 如果 first<n，我们要考虑这第 first 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 vis 来标记已经填过的数，那么在填第 first 个数的时候我们遍历题目给定的 n 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数 backtrack(first+1,output)。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。\n\n示例图：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220616005347.png)\n\n完整代码：\n```java\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n    \t// 首先建立一个返回的集合\n        List<List<Integer>> list=new ArrayList<>();\n        List<Integer> output = new ArrayList<Integer>();\n        // 将输入的数组变成集合\n        for (int num:nums){\n            output.add(num);\n        }\n        int n=nums.length;\n        // 进入回溯\n        backtrack(n,output,list,0);\n        return list;\n    }\n\n    public void backtrack(int n,List<Integer> output,List<List<Integer>> list,int first){\n    // 如果已经到了最后一个，就终止，将当前的数组结构加到集合中\n        if (first==n){\n            list.add(new ArrayList<Integer>(output));\n        }\n        for (int i = first; i < n; i++) {\n            // 动态维护数组(交换两个集合中任意两个元素（first和i）的位置)\n            Collections.swap(output, first, i);\n            // 继续递归填下一个数\n            backtrack(n, output, list, first + 1);\n            // 撤销操作（即撤销上一步中交换的操作）\n            Collections.swap(output, first, i);\n        }\n    }\n}\n```\n\n### 4.2、括号生成问题\n\n[leetcode-22](https://leetcode.cn/problems/generate-parentheses/)\n\n题目：数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n示例1：\t\n```\n输入：n = 3\n输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\n示例2：\t\n```\n输入：n = 1\n输出：[\"()\"]\n```\n\n提示：\n```\n1 <= n <= 8\n```\n\n解题思路：\n我们可以生成所有 2的2n次方个 ‘(’ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。\n如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。\n\n完整代码：\n```java\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> list=new ArrayList<String>();\n        backtrack(list,new StringBuilder(),0,0,n);\n        return list;\n    }\n\n// open左括号 close右括号\n    // max是n的长度\n    public void backtrack(List<String> list,StringBuilder sb,int open,int close,int max){\n\n        if (sb.length()==max*2){\n            list.add(sb.toString());\n            return;\n        }\n\n        // 左括号\n        if (open<max){\n            sb.append('(');\n            backtrack(list,sb,open+1,close,max);\n            sb.deleteCharAt(sb.length()-1);\n        }\n        // 右括号\n        if (close<open){\n            sb.append(')');\n            backtrack(list,sb,open,close+1,max);\n            sb.deleteCharAt(sb.length()-1);\n        }\n    }\n}\n```\n\n### 4.3、子集问题\n\n[leetcode-78](https://leetcode.cn/problems/subsets/)\n\n题目：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n示例1：\t\n```\n输入：nums = [1,2,3]\n输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n示例2：\t\n```\n输入：nums = [0]\n输出：[[],[0]]\n```\n\n提示：\n```\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nnums 中的所有元素 互不相同\n```\n\n解题思路：\n类似于全排列问题。\n\n完整代码：\n```java\nclass Solution {\n    List<List<Integer>> list=new ArrayList<>();\n    List<Integer> a=new ArrayList<>();\n\n    public List<List<Integer>> subsets(int[] nums) {\n        backtrack(nums,0);\n        return list;\n    }\n\n    public void backtrack(int[] nums,int cur){\n        if (cur==nums.length){\n            list.add(new ArrayList<Integer>(a));\n            return;\n        }\n        a.add(nums[cur]);\n        backtrack(nums,cur+1);\n        a.remove(a.size() - 1);\n        backtrack(nums,cur + 1);\n\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"SpringBoot通过SSH连接服务器数据库","url":"/2022/06/14/2022-06-14-SpringBoot通过SSH连接服务器数据库/","content":"\n# SpringBoot通过SSH连接服务器数据库\n\n有一些情况下，数据库为了安全起见，往往只允许一些特定的 IP 进行连接，而此时我们其他的服务区想对其进行连接，一种方法是使得该数据库允许我们的服务器对其进行连接，一种是将数据库设置成所有人可连接，还有一种方法就是本文我们所讲的方法：通过 SSH 连接到被允许链接的服务器 IP ，将此服务器作为一个支点，然后再连接到数据库中。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220614215252.png)\n\n以 Mysql 数据库为例，我们通过以下的步骤以及对其进行连接。\n\n## 1、实现方法\n\n### 1.1、引入依赖\n\n新建一个 SpringBoot 项目，引入以下的依赖：\n该依赖是 Mysql 数据库进行 SSH 连接所必需的一个依赖，不能缺少。\n\n```xml\n<dependency>\n      <groupId>com.jcraft</groupId>\n      <artifactId>jsch</artifactId>\n      <version>0.1.55</version>\n</dependency>\n```\n\n### 1.2、创建连接\n\n然后新建一个工具类`SSHConnection`，里面编写的是SSH连接服务器的代码：\n\n```java\npublic class SSHConnection {\n\n\t/**\n\t * linux服务器登录名\n\t */\n\tprivate final static String SSH_USER = \"root\";\n\t/**\n\t * linux登陆密码\n\t */\n\tprivate final static String SSH_PASSWORD = \"123456\";\n\t/**\n\t *linux服务器公网IP\n\t */\n\tprivate final static String SSH_REMOTE_SERVER = \"xxx.xxx.xxx.xxx\";\n\t/**\n\t *跳板机ssh开放的接口,ssh通道端口   默认端口 22\n\t */\n\tprivate final static int SSH_REMOTE_PORT = 22;\n\t/**\n\t *服务器上数据库端口号\n\t */\n\tprivate final static int REMOTE_PORT = 3306;\n\t/**\n\t *这个是本地的端口，选取一个没有占用的port即可\n\t */\n\tprivate final static int LOCAL_PORT = 3307;\n\t/**\n\t *要访问的mysql所在的ip \n\t */\n\tprivate final static String MYSQL_REMOTE_SERVER = \"xxx.xxx.xxx.xxx\";\n\n\tprivate Session session = null;\n\t/**\n\t *    建立SSH连接\n\t */\n\tpublic SSHConnection() throws Throwable{\n\t\tJSch jsch = new JSch();\n\n\t\tsession = jsch.getSession(SSH_USER, SSH_REMOTE_SERVER, SSH_REMOTE_PORT);\n\t\tsession.setPassword(SSH_PASSWORD);\n\t\tProperties config = new Properties();\n\t\tconfig.put(\"StrictHostKeyChecking\", \"no\");\n\t\tsession.setConfig(config);\n\t\tsession.connect();\n\t\tsession.setPortForwardingL(LOCAL_PORT, MYSQL_REMOTE_SERVER, REMOTE_PORT);\n\t}\n\t/**\n\t *    断开SSH连接\n\t */\n\tpublic void closeSSH (){\n\t\tthis.session.disconnect();\n\t}\n}\n```\n\n### 1.3、java监听类，监听SSH连接情况\n\n创建一个监听类`MyContextListener`，在 SSH 连接和断开时提供监听和反馈的作用\n\n```java\n@WebListener\n@Component\npublic class MyContextListener implements ServletContextListener {\n    private SSHConnection conexionssh;\n    public MyContextListener() {\n        super();\n    }\n    \n    @Override\n    public void contextInitialized(ServletContextEvent arg0) {\n        // 建立连接\n        try {\n            conexionssh = new SSHConnection();\n            conexionssh.SSHConnection();\n            System.out.println(\"成功建立SSH连接！\");\n        } catch (Throwable e) {\n            System.out.println(\"SSH连接失败！\");\n            e.printStackTrace();\n        }\n    }\n  \n    @Override\n    public void contextDestroyed(ServletContextEvent arg0) {\n        // 断开连接\n        System.out.println(\"Context destroyed ... !\\n\\n\\n\");\n        try {\n            conexionssh.closeSSH(); // disconnect\n            System.out.println(\"成功断开SSH连接！\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"断开SSH连接出错！\");\n        }\n    }\n}\n```\n\n### 1.4、编写配置文件\n\n在最后编写 SpringBoot的配置文件，即可运行使用\n\n```yml\nspring.datasource.url=jdbc:mysql://127.0.0.1:3307/数据库名称?useUnicode=true&characterEncoding=UTF-8&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC\nspring.datasource.username=数据库名\nspring.datasource.password=数据库密码\nspring.datasource.druid.test-on-borrow=true\nspring.datasource.druid.test-while-idle=true\n#127.0.0.1:3307 本机的3307端口，不需改动，和ssh工具类的local_port对应起来\n\n```\n","tags":["java","数据库","SpringBoot"],"categories":["java","数据库","SpringBoot","SSH连接"]},{"title":"通过gunicorn+docker部署flask项目","url":"/2022/05/09/2022-05-09-通过gunicorn+docker部署flask项目/","content":"\n# 通过gunicorn+docker部署flask项目\n\n由于学习上的原因，有幸接触到了 Python 项目部署到服务器的知识点，经过查找资料了解到，通过 flask 框架编写 Python 项目，并通过 gunicorn 运行项目以及 docker容器化服务，即可实现将其部署到服务器。\n\n## 1、准备\n首先我们需要准备一个完整的能在运行的 flask 项目，并且需要在服务器上安装好 docker 容器。\n以下我使用一个基础的 flask Hello World 项目进行配置，项目的基本结构如下：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510141015.png)\n其中`app.py`是程序的启动类文件，`Dockerfile`是docker的配置文件，可以用来创建docker的镜像文件，`requirements.txt`是所有依赖的名称，docker 会根据这些名称来下载你所需要的依赖，`gunicorn.conf.py`是 gunicorn 服务器的配置文件，其中有线程以及端口等内容。\n\n## 2、配置文件编辑\n\n1. 首先是启动类的内容\n\n启动类是 flask 框架的必备内容，其内容如下：\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():  # put application's code here\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    app.run()\n```\n\n2. requirements.txt文件内容\n\n里头写上所有我们所需要的依赖，如下：\n```txt\nflask\ngunicorn\ngevent\n```\n\n3. gunicorn.conf.py\n\n里头写上 gunicorn 启动的时候的配置文件，如下：\n```python\nworkers = 4        # 定义同时开启的处理请求的进程数量，根据网站流量适当调整\nworker_class = \"gevent\"  # 采用gevent库，支持异步处理请求，提高吞吐量\nbind = \"0.0.0.0:8080\"   # 这里8080可以随便调整\n```\n\n4. Dockerfile\n\n该文件是 docker 创建镜像的时候比较重要的文件，通过读取其中的内容创建一个镜像，内容如下：\n```dockerfile\n# FROM:所构建镜像基于什么镜像\nFROM python:3.7\n# WORKDIR:之后的shell语句是运行在哪个目录下\n# 写到你运行的文件的位置\n# 写的是要部署到服务器上的路径，如果这个镜像没有这个文件就会自动创建这个文件\nWORKDIR /home/chen/ff\n# COPY:将当前宿主机的文件拷贝到镜像里面去\n# 这里我们是把python安装的依赖requirements.txt拷贝到镜像里面去\n# requirements.txt是依赖包的名字，里面写上要下载的依赖\nCOPY requirements.txt ./\n# RUN 执行shell命令，在构建的时候就会运行\n# 这里是安装python依赖 配置镜像源\nRUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/\n# 复制当前目录到项目中的WorkDir中\nCOPY . .\n# 第一个app是我们的flask的python文件名 第二个app为flask的应用名\nCMD [\"gunicorn\", \"app:app\", \"-c\", \"./gunicorn.conf.py\"]\n```\n\n## 3、构建docker镜像并运行\n\n将以上文件打包上传到服务器上，然后在该目录下即可创建 docker 的镜像文件。\n通过以下的命令即可创建：\n```shell\ndocker build -t 'myflask_app2' .\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510143219.png)\n注意：此处由于我之前已经创建过一次了，所以直接成功，首次创建回=会遍历你的配置文件然后下载。\n\n完成之后就会显示出已经创建的镜像文件\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510143558.png)\n\n随后运行该镜像文件，通过以下的命令：\n```shell\ndocker run -p 8087:8086 --name myflask2 myflask_app2\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510143701.png)\n\n运行成功之后通过访问服务器的8087端口，即可访问我们的内容\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510143851.png)\n\n随后通过`docker ps`可以查看现在正在运行的镜像\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220510143920.png)\n\n至此就算是部署成功了。","tags":["docker","Linux","flask","gunicorn","Python"],"categories":["Linux","部署","Python","flask"]},{"title":"数据结构之树","url":"/2022/05/04/2022-05-04-数据结构之树/","content":"\n# 数据结构之树\n\n## 1、基本理论术语\n\n节点深度：对任意节点x，x节点的深度表示为根节点到x节点的路径长度。所以根节点深度为0，第二层节点深度为1，以此类推\n节点高度：对任意节点x，叶子节点到x节点的路径长度就是节点x的高度\n树的深度：一棵树中节点的最大深度就是树的深度，也称为高度\n父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点\n子节点：一个节点含有的子树的根节点称为该节点的子节点\n节点的层次：从根节点开始，根节点为第一层，根的子节点为第二层，以此类推\n兄弟节点：拥有共同父节点的节点互称为兄弟节点\n度：节点的子树数目就是节点的度\n叶子节点：度为零的节点就是叶子节点\n祖先：对任意节点x，从根节点到节点x的所有节点都是x的祖先（节点x也是自己的祖先）\n后代：对任意节点x，从节点x到叶子节点的所有节点都是x的后代（节点x也是自己的后代）\n森林：m颗互不相交的树构成的集合就是森林\n\n## 2、树的种类\n\n1. 无序树\n    树的任意节点的子节点没有顺序关系。 \n2. 有序树\n    树的任意节点的子节点有顺序关系。 \n3. 二叉树\n    树的任意节点至多包含两棵子树。 \n4. 满二叉树\n    叶子节点都在同一层并且除叶子节点外的所有节点都有两个子节点。 \n5. 完全二叉树\n    对于一颗二叉树，假设其深度为d（d>1）。除第d层外的所有节点构成满二叉树，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； \n6. 平衡二叉树\n    它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树，同时，平衡二叉树必定是二叉搜索树。 \n7. 二叉查找树\n   又称为二叉搜索树\n   若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n   若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n   任意节点的左、右子树也分别为二叉查找树；\n   没有键值相等的节点。 \n8. 线索二叉树\n\t遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点(第一个和最后一个结点除外)都有一个直接前驱和直接后继。\n9. 霍夫曼树\n\t带权路径最短的二叉树称为哈夫曼树或最优二叉树。\n10. 红黑树\n\t红黑树是一颗特殊的二叉查找树，除了二叉查找树的要求外，它还具有以下特性：\n\t- 每个节点或者是黑色，或者是红色。\n\t- 根节点是黑色。\n\t- 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n\t- 如果一个节点是红色的，则它的子节点必须是黑色的。\n\t- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。\n\t图示如下：\n\t![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20180121021159244)\n11. B树\n\t一颗m阶B树的特性：\n\t- 根结点至少有两个子女（如果B树只有一个根节点，这个根节点的key的数量可以为[1~m-1])\n\t- 每个非根节点所包含的关键字个数 j 满足：⌈m/2⌉ - 1 <= j <= m - 1，节点的值按非降序方式存放，即从左到右依次增加\n\t- 除根结点以及叶子节点以外的所有结点的度数正好是关键字总数加1，故内部节点的子树个数 k 满足：⌈m/2⌉ <= k <= m\n\t- 所有的叶子结点都位于同一层\n12. B+树\n\tm阶B+树是m阶B树的变体，它的定义大致跟B-tree一致，不过有以下几点不同：\n\t- 有n棵子树的结点中含有n个关键字，每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点，其中⌈m/2⌉ <= n <= m\n\t- 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接\n\t- 所有的非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字\n\t- 通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点\n13. B * 树\n\tB * 树是B+树的变体，除了B+树的要求之外，还有以下特性：\n\t- ⌈m * 2/3⌉ <= n <=m 这里的n是除根节点之外的内部节点的键\n\t- 增加内部节点中兄弟节点的指针，由左边指向右边\n\n## 3、二叉树\n### 3.1、二叉树的定义\n\n二叉树，顾名思义是一种每个节点中至多有两棵子树的一种树结构，并且有左右的分别，其次序也不能颠倒。\n二叉树的两棵子树分别称为左子树以及右子树，而对于两棵子树而言，同样是一个二叉树，同样存在两棵子树。\n综上所述，如果交换二叉树的左右节点，就会变成另外一棵二叉树，即使只有一个子树，同样也要区分左右子树。\n以下是二叉树的几个形态：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223141038540.png)\n\n### 3.2、特殊的二叉树\n1. 斜二叉树\n\t所有子节点在左边的叫左斜二叉树，所有节点在右边的叫做右斜二叉树。\n2. 满二叉树\n\t一颗高度为h的二叉树，且含有2h-1个节点的二叉树称为满二叉树，也就是说在每个节点上都存在数量最多的子节点。\n\t![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223141540595.png)\n3. 完全二叉树\n\t一颗高度为h的二叉树，有n个节点，当且仅当每一个节点都与高度为h的满二叉树中编号为1~n的节点一一对应的时候，称为完全二叉树。\n\t![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223141920389.png)\n\t- 若i ≤ n / 2 i≤n/2i≤n/2, 则结点i ii为分支结点，否则为叶子结点。\n\t- 叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。\n\t- 若有度为1 11的结点，则只可能有一个，且该结点只有左孩子而无右孩子(重要特征)。\n\t- 按层序编号后，一旦出现某结点(编号为i ii)为叶子结点或只有左孩子，则编号大于i ii的结点均为叶子结点。\n\t- 若n nn为奇数，则每个分支结点都有左孩子和右孩子;若n nn为偶数，则编号最大的分支结点(编号为n / 2 n/2n/2)只有左孩子，没有右孩子，其余分支结点左、右孩子都有。\n4. 平衡二叉树\n\t一棵二叉树的左右节点的深度差别不大于1，就是平衡二叉树。\n5. 二叉排序树\n\t一棵二叉树的左节点上的所有的节点的值都比根节点小，并且所有右节点上的所有的节点的值都比根节点大，且每一个子节点又分别是一颗二叉排序树，这就是二叉排序树。\n\t\n### 3.3、二叉树的存储结构\n\n二叉树有两种存储结构，分别是顺序存储结构以及链式存储结构。\n\n1. 顺序存储结构\n\n二叉树的顺序存储结构是指用一组地址连续的存储单元自上到下，自左到右存储完全二叉树的节点元素，即将二叉树上编号为 i 的项存储在一维数组下标为 i-1 的位置上。\n\n依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。\n\n但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 h 且只有 h 个结点的单支树却需要占据近 2h−1 个存储单元。二叉树的顺序存储结构如图所示，其中0表示并不存在的空结点。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223145918502.png)\n\n2. 链式存储结构\n\n由于顺序存储结构的实用性不强，所以有了链式存储结构。\n二叉树有一个根节点，一个根节点又有两个子节点，所以我们设计一个链式存储结构的结构为一个数据域以及两个指针域。如下：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223150251730.png)\n其中data是数据域，lchild 和rchild都是指针域，分别存放指向左孩子和右孩子的指针。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223150652536.png)\n容易验证，在含有 n 个结点的二叉链表中，含有 n + 1 个空链域。\n\n### 3.4、遍历二叉树\n\n首先创建一个二叉树节点类，以便后面的遍历：\n```java\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\n```\n\n二叉树的遍历，是指从根节点出发，逐步查找访问每一个子节点，子节点的子节点的一个过程，其中每一个节点必须也只能被访问一次。\n\n遍历二叉树有多种方式，以下是一些基本的遍历方式：\n(1).先序遍历\n(2).中序遍历\n(3).后序遍历\n\n1. 先序遍历\n\n先序遍历的顺序为：根节点-左子树-右子树\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223151636759.png)\n其算法实现为：\n[leetcode-144](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list=new ArrayList<>();\n        preorder(root,list);\n        return list;\n    }\n    public void preorder(TreeNode root, List<Integer> list){\n        if (root==null){\n            return;\n        }\n        list.add(root.val);\n        preorder(root.left,list);\n        preorder(root.right,list);\n    }\n}\n```\n\n2. 中序遍历\n\n中序遍历的顺序为：左子树-根节点-右子树\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/2021022315230487.png)\n其算法实现为：\n[leetcode-94](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)\n\n```java\nclass Solution {\n    List<Integer> list=new ArrayList<Integer>();\n    public List<Integer> inorderTraversal(TreeNode root) {\n        inorder(root,list);\n        return list;\n    }\n    public void inorder(TreeNode root, List<Integer> res){\n        if (root==null){\n            return;\n        }\n        inorder(root.left,res);\n        res.add(root.val);\n        inorder(root.right,res);\n    }\n}\n```\n\n3. 后序遍历\n\n后序遍历的顺序为：左子树-右子树-根节点\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210223152835126.png)\n其算法实现为：\n[leetcode-145](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)\n\n```java\npublic List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list=new ArrayList<>();\n        dfs(root,list);\n        return list;\n    }\n    public void dfs(TreeNode root,List<Integer> list){\n        if (root==null){\n            return;\n        }\n        dfs(root.left,list);\n        dfs(root.right,list);\n        list.add(root.val);\n    }\n```\n\n### 3.5、层序遍历二叉树\n\n除了上一节中的三种常见的遍历二叉树的方式，还有一种层序遍历的方式，该遍历方式就是从根节点开始，依层遍历，先遍历完第二层，再遍历第二层，以此类推直到结束。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210225175155659.png)\n要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队;若它有右子树，则将右子树根结点入队。然后出队，访问出队结…如此反复，直至队列为空。\n\n其算法实现为：\n[leetcode-102](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> ret = new ArrayList<List<Integer>>();\n        if (root == null) {\n            return ret;\n        }\n\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            List<Integer> level = new ArrayList<Integer>();\n            int currentLevelSize = queue.size();\n            for (int i = 1; i <= currentLevelSize; ++i) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            ret.add(level);\n        }\n        \n        return ret;\n    }\n}\n```\n\n## 4、线索二叉树\n### 4.1、线索二叉树理论入门\n\n遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点(第一个和最后一个结点除外)都有一个直接前驱和直接后继。\n传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。\n\n为了区分二叉树的左孩子指针和右孩子指针是否为空，或者是否指向前驱节点或后继节点，我们将节点的结构改成5个域，在原二叉树的基础上添加左标志域Ltag和右标志域Rtag，他们是两个int型的数据域。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220505140613.png)\n\n- 如果节点有左孩子，那么Lchild依然指向他的左孩子，否则指向遍历序列中他的前驱节点。\n- 如果节点有右孩子，那么Rchild依然指向他的左孩子，否则指向遍历序列中他的后继节点。\n\nLtag和Rtag的定义如下:\n\n- Ltag : 等于0时，Lchild域指示节点的左孩子;等于1时，Lchild指示节点的遍历前驱。\n- Rtag : 等于0时，Rchild域指示节点的左孩子;等于1时，Rchild指示节点的遍历后继。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226110049774.png)\n\n### 4.2、二叉树的线索化\n\n二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树，线索化的过程就是在遍历的过程中修改空指针的过程。\n1. 当遍历到左孩子指针域为空的时候，我们应该填入该节点的遍历前驱节点的指针，这时候我们可以提前声明一个全局变量pre来记录刚刚访问过的节点，在遍历过程中如果遇到左孩子为空的节点，就将pre赋给他的左孩子域，并且将Ltag设置为1。pre的初值应该为NULL，因为便利的首节点的前驱节点一定为空。\n2. 当遍历过程中右孩子的指针域为空的时候，要填的节点应该为当前节点遍历序列的后继节点，但是我们现在无法确定，因此当前节点的右孩子指针域只能遍历到下一个节点的时候在填，并且当前节点就是pre节点的后继节点，所以我们只需要在遍历的过程中加上判断，回填pre的语句，若pre的右孩子节点为空，那么将当前的节点赋值给pre的右节点，同时pre节点的Rtag应该置为1\n\n\n以下是中序线索二叉树的代码：\n```java\nvoid Inthread(BiTree root) \n{\n//pre为全局变量，在函数外已经声明过\n\tif(root != null)\n\t{\n\t\tInthread(root.Lchild);//递归线索化root的左孩子\n\t\tif(root.Lchild == null) //置前置线索 \n\t\t{\n\t\t\troot.Lchild = pre;\n\t\t\troot.Ltag = 1;\n\t\t}\n\t\telse{\n\t\t\troot.Ltag = 0;\n\t\t}\n\t\tif(pre != null && pre.Rchlid == null)//置后置线索\n\t\t{\n\t\t\tpre.Rchlid = root;\n\t\t\tpre.Rtag = 1;\n\t\t} \n\t\tpre = root;\n\t\tInthread(root.Rchlid);//递归线索化root的右孩子\n\t}\n}\n\n```\n\n### 4.3、遍历线索二叉树\n\n## 5、树、森林以及二叉树的转换\n\n在讲树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的二叉链表也是相同的，只是解释不太一样而已。 因此，只要我们设定一定的规则，用二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。\n\n### 5.1、树转换为二叉树\n\n树转换为二义树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。\n\n以下是树转换为二叉树的画法：\n1. 在兄弟节点中加一连线\n2. 对每个节点，只保留它与第一个子节点的连线，而其他子节点的连线全都删掉\n3. 以根节点为中心，旋转45°\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226145948307.png)\n\n### 5.2、森林转换为二叉树\n\n森林是由若干棵树组成的，所以完全可以理解为,森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。\n\n以下是森林转换为二叉树的画法：\n1. 将森林中的每棵树都转换为单独的二叉树\n2. 每一颗单独的树的根节点都看作兄弟节点，在每棵树的下面加一条连线\n3. 以第一棵树为中心旋转45°\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226150421261.png)\n\n而二叉树转化为树或者森林即为将上述的过程倒推一遍即可。\n\n## 6、二叉排序树\n二叉排序树又称为二叉查找树。其可能是一颗空树，也有可能是具有以下性质的二叉树：\n1. 若左子树非空，那么左子树上的所有节点值均小于根节点的值\n2. 若右子树非空，那么右子树上的所有节点值均大于根节点的值\n3. 左右节点分别都是一颗二叉搜索树\n\n根据二叉排序树的定义，左子树结点值<根结点值<右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。例如，下图所示二叉排序树的中序遍历序列为123468。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309095505317.png)\n\n首先创建一个二叉排序树：\n```java\npublic class BinaryTreeNode {\n\tpublic int data; //数据域\n\tpublic BinaryTreeNode left, right; //指向左右子节点的指针\n\n\tpublic BinaryTreeNode(int data, BinaryTreeNode left, BinaryTreeNode right) {\n\t\tthis.data = data;\n\t\tthis.left = left;\n\t\tthis.right = right;\t\n\t}\n}\n```\n\n### 6.1、 初始化二叉排序树\n\n首先是在初始化的类中定义二叉查找树的根节点：\n```java\npublic BinaryTreeNode root;\n```\n然后即可初始化二叉排序树：\n```java\npublic void insertBinaryTree(int[] datas) {\n\n    if(datas.length < 1) {\n        System.out.println(\"the datas Array length small zero!\");\n        return;\n    }\n    this.root = new BinaryTreeNode(datas[0], null, null);\n\n    for (int i = 1; i < datas.length; i++) {\n        this.insert(this.root, datas[i]);\n    }\n}\n\nprivate void insert(BinaryTreeNode root, int data) {\n    if(data > root.data) {\n        if(root.right == null) \n            root.right = new BinaryTreeNode(data, null, null);\n        else \n            this.insert(root.right, data);\n    }\n    else {\n        if(root.left == null) \n            root.left = new BinaryTreeNode(data, null, null);\n        else \n            this.insert(root.left, data);\n    }\n}\n```\n通过传递给insertBinaryTree()存储二叉查找树值的数组来完成初始化。通过insert()方法递归的来完成对结点的初始化操作。\n\n### 6.2、 二叉排序树的中序遍历\n\n```java\npublic void inOrder(BinaryTreeNode root) {\n    if(root != null) {\n        this.inOrder(root.left);\n        System.out.print(root.data + \"-\");\n        this.inOrder(root.right);\n    }\n}\n```\n\n根据二叉排序树的特性我们知道如果根节点非空，则根节点的左子树上所有结点的值均小于根节点，右子树上的所有结点值均大于根节点。同理对任意子树都满足上面。所以对于二叉排序树的遍历是对二叉排序树的由小到大的升序输出。在这里前序和后序遍历与中序逻辑相似，不做展示。\n\n### 6.3、二叉排序树的查找\n\n```java\npublic boolean SearchBST(BinaryTreeNode root, int key) {\n    if(root == null) {\n        return false;\n    }\n    else if(key == root.data) {\n        return true;\n    }\n    else if(key < root.data) {\n        return this.SearchBST(root.left, key);\n    }\n    else {\n        return this.SearchBST(root.right, key);\n    }\n}\n```\n\n查询操作也基于递归，查询过程和节点结点值进行比较，若成功返回true。\n\n### 6.4、二叉排序树的插入\n\n```java\n\tpublic boolean InsertBST(BinaryTreeNode root, int key) {\n\t\tif(!this.SearchBST(root, key)) {\n\t\t\tthis.insert(root, key);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"the key existence in BinaryTree\");\n\t\t\treturn false;\n\t\t}\n\t}\n```\n\n该操作的思路是查询带插入的key是否已经在二叉排序树中，如果不在，执行insert()方法递归的将key插入到指定的位置，如果存在，返回错误信息并结束。\n\n### 6.5、二叉排序树的删除\n\n相对于其他的操作，二叉排序树的删除操作就显得不是特别容易，因为我们需要保证在删除了某一个元素之后，剩下的元素还保持二叉排序树的结构，所以在删除时就需要考虑多种情况。\n\n1. 当删除的为叶子节点的时候：\n\n可以直接删除该叶子结点的值，并将其父节点指向该节点的域置为null\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20190311194315480.png)\n删除x\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20190311194520105.png)\n\n2. 当删除的节点只有左子树或者只有右子树\n\n相对来说也好解决，那就是结点删除后，将它的左子树或右子树整个移动到删除结点的位置即可，可以理解为独子继承父业。\n比如要删除结点x，直接将父结点p指向待删除的结点x的指针直接指向x结点的唯一儿子结点(l或则是r)，然后删除x结点即可。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20190311195012724.png)\n删除x\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20190311195343646.png)\n\n3. 当删除的节点存在左右子树时\n\n这也是最麻烦的一种情况，通常的解决方式是用删除结点x的前驱(或后继)结点填补它的位置。因为x有一个左子结点，因此它的前驱结点就是左子树中的最大结点，这样替换就能保证有序性，因为x.data和它的前驱之间不存在其他的键值。\n操作如下：\n3.1 寻找到待删除的结点的前驱结点，并用s指向其前驱结点\n3.2 找到待删除结点的前驱结点的父结点，并用q来指向前驱结点的父节点。\n3.3 将x的前驱结点的值赋给x，完成替换操作。\n3.4 最后修改q的指向为s的子节点，并删除s。\n\n通过递归寻找要删除的节点：\n```java\npublic boolean DeleteBST(BinaryTreeNode root, int key) {\n\n    if(root == null) {\n        System.out.println(\"the root node is null\");\n        return false;\n    }\n    else {\n        if(key == root.data) {\n            return this.delete(root);\n        }\n        else if(key < root.data) {\n            return this.DeleteBST(root.left, key);\n        }\n        else {\n            return this.DeleteBST(root.right, key);\n        }\n    }\n}\n```\n删除找到的节点：\n```java\npublic boolean delete(BinaryTreeNode root) {\n    BinaryTreeNode q, s;\n    if(root.right == null) {\n        root = root.left;\t\n    }\n    else if(root.left == null) {\n        root = root.right;\n    }\n    else {\n        q = root;\n        s = root.left;\n        while(s.right != null) {\n            q = s;\n            s = s.right;\n        }\n        root.data = s.data;\n        if(q != root) {\n            q.right = s.left;\n        }\n        else {\n            q.left = s.left;\n        }\n    }\t\n    return true;\n}\n```\n## 7、平衡二叉树\n\n平衡二叉树(Self-Balancing Binary Search Tree 或 Height-Balanced Binary Search Tree)是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。\n\n它是一种高度平衡的二叉排序树。它要么是一棵空树， 要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF (Balance Factor) ， 那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309100347701.png)\n\n### 7.1、平衡二叉树的查找\n\n在平衡二叉树上进行查找的过程与二叉排序树的相同。\n\n### 7.2、平衡二叉树的插入\n\n二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入(或删除)一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A，再对以A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309101003723.png)\n平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。\n\n1. LL平衡旋转(右单旋转)\n\n由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子B向右上旋转代替A成为根结点，将A结点向右下旋转成为B的右子树的根结点，而B的原右子树则作为A结点的左子树。\n如下图所示，结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309101721760.png)\n\n2. RR平衡旋转(左单旋转)\n\n由于在结点A的右孩子®的右子树®上插入了 新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子B向左上旋转代替A成为根结点，将A结点向左下旋转成为B的左子树的根结点，而B的原左子树则作为A结点的右子树。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/2021030910190515.png)\n\n3. LR平衡旋转(先左后右双旋转)\n\n由于在A的左孩子(L)的右子树®上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将A结点的左孩子B的右子树的根结点C向左上旋转提升到B结点的位置（即进行一次RR平衡旋转(左单旋转)），然后再把该C结点向右上旋转提升到A结点的位置（即进行一次LL平衡旋转(右单旋转)）。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309101948801.png)\n\n4. RL平衡旋转(先右后左双旋转)\n\n由于在A的右孩子®的左子树(L)上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将A结点的右孩子B的左子树的根结点C向右上旋转提升到B结点的位置（即进行一次LL平衡旋转(右单旋转)），然后再把该C结点向左上旋转提升到A结点的位置（即进行一次RR平衡旋转(左单旋转)）。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309102558548.png)\n\n**注意: LR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树不影响旋转过程，而上图中是以插入C的左子树中为例。**\n\n### 7.2、平衡二叉树的插入——举例\n\n假设关键字序列为15 , 3 , 7 , 10 , 9 , 8通过该序列生成平衡二叉树的过程如下图所示。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210309103024879.png)\n\n## 8、哈夫曼树\n\n### 8.1、哈夫曼树的定义\n\n在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度(经过的边数)与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为\n$$\nWPL=\\sum_{i=1}^nw_il_i\n$$\n式中，wi是第i个叶结点所带的权值， li是该叶结点到根结点的路径长度。\n在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树。例如，下图中的3棵二叉树都有4个叶子结点a, b,c,d,分别带权7,5,2,4，它们的带权路径长度分别为\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226154517971.png)\n\na. WPL = 7x2 + 5x2 + 2x2 + 4x2 = 36。\nb. WPL = 4x2 + 7x3 + 5x3 + 2x1 = 46。\nc. WPL = 7x1 + 5x2 + 2x3 + 4x3 = 35。\n其中，图c树的WPL最小。可以验证，它恰好为哈夫曼树。\n\n### 8.2、构造哈夫曼树\n\n1. 先把有权值的叶子结点按照从大到小（从小到大也可以）的顺序排列成一个有序序列。\n2. 取最后两个最小权值的结点作为一个新节点的两个子结点，注意相对较小的是左孩子。\n3. 用第2步构造的新结点替掉它的两个子节点，插入有序序列中，保持从大到小排列。\n4. 重复步骤2到步骤3，直到根节点出现。\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226155839813.png)\n\n### 8.3、哈夫曼编码\n\n哈夫曼编码的研究，本质上是一种最优化问题的研究，其目的主要是为了解决远距离通信的数据传输问题。而哈夫曼编码被公认为是一种有效的数据压缩编码。\n\n比如我们有一段文字内容为“ BADCADFEED”要网络传输给别人，显然用二进制的数字(0和1)来表示是很自然的想法。我们现在这段文字只有六个字母ABCDEF，那么我们可以用相应的二进制数据表示，如下表所示：\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226160333919.png)\n\n这样按照固定长度编码编码后就是“001000011010000011101100100011”，对方接收时可以按照3位一分来译码。如果一篇文章很长，这样的二进制串也将非常的可怕。而且事实上，不管是英文、中文或是其他语言，字母或汉字的出现频率是不相同的。\n\n假设六个字母的频率为A 27,B 8,C 15,D 15,E 30,F 5,合起来正好是100%，那就意味着，我们完全可以重新按照赫夫曼树来规划它们。\n\n图左图为构造赫夫曼树的过程的权值显示。右图为将权值左分支改为0，右分支改为1后的赫夫曼树。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226161046918.png)\n这棵哈夫曼树的WPL为:\n$$\nWPL=2*(15+17+30)+3*15+4*(5+8)=241\n$$\n此时，我们对这六个字母用其从树根到叶子所经过路径的0或1来编码，可以得到如下表所示这样的定义。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20210226161554834.png)\n\n若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。\n我们将文字内容为“ BADCADFEED”再次编码，对比可以看到结果串变小了。\n\n- 原编码二进制串: 000011000011101100100011 (共 30个字符)\n- 新编码二进制串: 10100101010111100(共25个字符)\n\n也就是说，我们的数据被压缩了，节约了大约17%的存储或传输成本。\n\n需要注意的一点是：\n0和1究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且是最优的。","tags":["数据结构"],"categories":["数据结构"]},{"title":"docker基础","url":"/2022/03/20/2022-03-20-docker基础/","content":"\n# docker基础\n\n## 1、安装以及配置\n\n### 1.1、docker的基本组成\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220320151027.png)\n\n1. 镜像\n\n镜像就是一个只读的模板，可以通过这个模板创建容器服务，一个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中）。\n\n2. 容器\n\n- Docker利用容器技术，独立运行的一个或一组应用。容器是用镜像创建的运行实例。\n- 它可以被启用，开始，停止，删除。每个容器都是相互隔离的，保证安全的平台。\n- 可以把容器看作是一个简易版的Linux系统(包括root用户权限，进程空间，用户空间和网络空间等)和运行在其中的应用程序。\n- 容器的定义和镜像几乎一摸一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的\n\n3. 仓库\n\n- 仓库是集中存放镜像文件的场所。\n- 仓库和仓库注册服务器(Registry)是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签\n- 仓库分为公开仓库(public)和私有仓库(private)两种形式\n- 最大的开放仓库是国外的 Docker Hub，存放了数量庞大的镜像供用户下载。\n- 国内的公开仓库包括阿里云，网易云都有容器服务器（需要配置镜像加速）等\n\n### 1.2、准备安装环境\n\n需要准备一台系统为`Cent OS 7&8`的服务器，这里我所使用的是阿里云的服务器。\n\n### 1.3、安装\n\n1. 卸载旧版本\n\n直接通过`yum`来安装 docker 服务。\n如果在系统之中有旧版本的 docker ，需要首先卸载旧的版本\n```shell\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n2. 安装新版本\n```shell\nsudo yum install -y yum-utils\n```\n3. 设置镜像地址\n```shell\n# 默认是国外的\nsudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n    \n# 换成阿里云镜像地址\nsudo yum-config-manager \\\n    --add-repo \\\n    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n```\n4. 安装最新版Docker Engine和容器\n```shell\n# docker-ce社区版(docker-ee企业版)\nsudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n### 1.4、安装完成后启动\n\n```shell\nsudo systemctl start docker\n```\n\n查看是否安装成功并启动\n```shell\ndocker version\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220320153252.png)\n\n### 1.5、测试\n运行hello world测试\n```shell\nsudo docker run hello-world\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220320153514.png)\n\n查看刚才运行的镜像\n```shell\ndocker images\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220320153657.png)\n\n\n## 2、docker常用命令\n\n## 3、实战部署\n### 3.1、部署Nginx\n```shell\n# 1. 搜索镜像\ndocker search nginx\n# 2. 下载镜像\ndocker pull nginx\n# 3. 查看镜像是否下载成功\ndocker images\n# 4. 启动容器(-d:后台运行 --name:容器名 -p:暴露端口 宿主机端口3344:容器端口80)\ndocker run -d --name nginx01 -p 3344:80 nginx\n# 5. 查看容器是否启动\ndocker ps\n# 6. 本机测试\ncurl localhost:3344\n```\n\n### 3.2、部署Tomcat\n```shell\n# 官方使用\n# 之前我们都是后台启动,停止容器后,仍可以通过docker ps -a命令查到容器的使用记录\n# --rm表示用完就删除容器及历史记录,通过命令查不到;\ndocker run -it --rm tomcat:9.0\n\n```\n\n## 3、容器数据卷\n### 3.1、什么是容器数据卷\n\ndocker的理念：将应用和环境打包成一个镜像！通过镜像启动容器运行。\n\n而现在有这样一个问题：在容器中存储的程序数据是需要持久化的，不能容器删了数据也随之删除。比如，安装一个MySQL容器，在其中存储了大量数据，结果把容器删了数据也没了，就相当于删库跑路，这是不可能发生的\n\n而为了解决这个问题，就有了 容器数据卷 的概念：Docker容器所产生的数据会自动同步到本地，这样子即使将容器删除了，数据依然还在；同时，同一份数据还可以在多个容器中进行共享。\n类似于将容器的目录挂载到本地（本地指的是：服务器的本地）\n\n### 3.2、使用容器数据卷\n\n使用数据卷有两种方式，一种是通过命令行挂载的方式，一种是通过dockerfile的方式添加，首先进行第一种模式的介绍。\n```shell\ndocker run -it -v 主机目录:容器内目录\n```\n举例：\n```shell\ndocker run -it -v /home/test:/home centos /bin/bash\n```\n启动之后可以用docker inspect查看容器详细信息，可以看到挂载的信息。\n其中`-v`表示在容器中创建一个数据卷，通过该命令，会在docker以及宿主中分别创建一个相同的目录，两个目录相互共享，里面的文件也是一样。\n\n同时在创建容器数据卷的的时候还可以给它加上权限，如果我们想要给宿主机只能读取数据卷中的数据，但是不能修改，我们就可以通过以下的方式进行设置：\n```shell\ndocker run -it -v /主机目录 ： /容器内目录  ：ro 镜像名\n```\n而一般情况下，只写很少使用，同样通过docker inspect可以查看权限。\n下面我们介绍dockerfile的方式创建容器数据卷。\n\n### 3.3、初识Dockerfile\n\nDockerFile也就是用来创建docker镜像的构建文件，而dockerFile对于docker镜像而言就如同java中某个类的.class文件对应上该类的.java文件。\n\n首先在linux服务器根目录上新建docker文件夹并建立DockerFile文件，使用volume命令（出于可移植可分享的的考虑，用以上 -v /宿主机绝对路径目录 ：` /容器内目录` 的这种方式不能够直接在dockerFile中直接实现，因为宿主机目录是依赖于特定的宿主机的，并不能保证所有的宿主机都存在这样特定的目录）\n\n首先我们编写一个dockerfile文件：\n```shell\nFROM  镜像名\nVOLUME [\"/生成的目录路径\"]  -- privileged=true\nCMD echo \"success build\"\nCMD /bin/bash\n```\n以上的文件脚本相当于命令行：` docker run -it -v /主机目录 ： /容器内目录`\n\n然后通过`docker build`编译运行该脚本文件：\n```shell\ndocker build -f  /docker/DockerFile -t  命名空间/镜像名\n```\n\n执行后输入docker images就可以发现自己通过DockerFile所build的镜像，里面有挂载数据卷。","tags":["docker"]},{"title":"给个人网站加上天气插件","url":"/2022/03/09/2022-03-09-给个人网站加上天气插件/","content":"\n# 给个人网站加上天气插件\n\n## 1、前言\n\n在修改个人网站的时候，想加上一个天气的插件，以用于打开我的个人网站的时候就可以看到当前地区的天气，这个功能既可以给网站增添光彩，也可以给游客打开网站增加了一个理由。\n\n在看了多款天气插件之后，如：中国天气网、心知天气、彩云天气等等。\n最终还是选了[和风天气](https://www.qweather.com/)作为最终的插件\n\n## 2、API设置\n\n首先我们需要进入和风天气的[开发平台](https://dev.qweather.com/)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308232438.png)\n点开右上角的`控制台`登录进入\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308232654.png)\n然后打开应用管理中的创建新应用，创建一个 `Web API`类幸应用\n\n创建成功后，会得到这样的一个应用，重要的是这个KEY，后面再开发的时候会用到！\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308233225.png)\n\n## 3、插件设置\n\n除了上面的 API 的方式之外，可能更多使用的是插件，因为插件不用自己写样式，可以直接进行调用，而 API 仅仅是一堆数据，需要我们手写样式才能将其显示出来。\n所以说如果不是特别强调要匹配网站原始风格的，直接使用插件，会更加方便。\n\n### 3.1、配置插件设置\n\n首先我们打开和风天气的插件管理界面,点击左侧的开发文档\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309091452.png)\n然后选择插件开发文档，会显示以下的内容，根据自己的需要进行创建。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309091611.png)\n这里以网页标准插件作为例子\n\n\n\n此处在配置完成插件的内容之后，点击生成代码，即可完成制作\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309091801.png)\n\n**注意：此处的代码是不能直接在 vue 中进行使用的，所以我们需要对其进行一些处理**\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309091924.png)\n\n首先我们复制第二个 script 中的连接，在浏览器中打开\n记录下这些内容，这个就是这个连接所对应的源码\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309092119.png)\n\n\n\n### 3.2、vue代码编写\n\n首先我们需要创建一个 div 作为容器，并将其id设置为`he-plugin-standard`\n```vue\n<div id=\"he-plugin-standard\" ></div>\n```\n\n### 3.3、js部分代码\n\n接下来就是将刚刚我们在官网所配置的代码放到我们的 js 代码部分了\n\n我们需要在页面创建的时候就创建天气插件，所以我们将代码放到一个`created`代码块中。\n注意此处在`WIDGET`的前面要加上`window`才可以。\n其他的就是直接法制黏贴即可\n```js\ncreated() {\n    window.WIDGET = {\n      \"CONFIG\": {\n        \"layout\": \"1\",\n        \"width\": \"500\",\n        \"height\": \"200\",\n        \"background\": \"1\",\n        \"dataColor\": \"FFFFFF\",\n        \"borderRadius\": \"5\",\n        \"key\": \"94096c96a79b4e3d9bf421612639f9e9\"\n      }\n    };\n    (function (d) {\n      var c = d.createElement('link')\n      c.rel = 'stylesheet'\n      c.href = 'https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0'\n      var s = d.createElement('script')\n      s.src = 'https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0'\n      var sn = d.getElementsByTagName('script')[0]\n      sn.parentNode.insertBefore(c, sn)\n      sn.parentNode.insertBefore(s, sn)\n    })(document)\n  }\n}\n```\n\n在官方这些代码的基础上，我们可以进行一些修改，达到自己想要的一些效果。\n以下就是最终的结果\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220309093544.png)","tags":["记录"],"categories":["博客","个人网站"]},{"title":"给个人网站加上高德地图插件","url":"/2022/03/08/2022-03-08-给个人网站加上高德地图插件/","content":"\n# 给个人网站加上高德地图插件\n\n## 1、前言\n\n在修改个人网站的关于界面的时候，突然想起之前有看过高德地图的插件，而关于界面刚好可以将个人地址设置为地图图层的形式，所以找到了[高德地图](https://lbs.amap.com/)的插件，进行设置。\n\n## 2、API设置\n\n首先我们要进入[高德开放平台](https://lbs.amap.com/)的地址\n然后会显示以下的选项\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308222155.png)\n选择左上角的`地图 JS API`\n即出现以下内容：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308223043.png)\n\n这是官方文档所写的方式，大家可以根据官方的文档进行操作，基本都能很简单实现。\n\n### 2.1、安装Loader\n官方的方式，首先我们要下载Loader\n`npm i @amap/amap-jsapi-loader --save`\n\n### 2.2、编辑vue文件\n首先我们可以创建一个vue文件，单独放置我们的地图插件。\n然后创建一个`div`组件，并设置地图容器的 id 属性为 container。\n```html\n<template>\n     <div id=\"container\"></div>\n</template>\n```\n\n然后可以设置地图的css格式：\n```css\n<style  scoped>\n    #container{\n        padding:0px;\n        margin: 0px;\n        width: 100%;\n        height: 800px;\n    }\n</style>\n```\n\n最后我们在这个vue组件中引入 amap-jsapi-loader \n```js\nimport AMapLoader from '@amap/amap-jsapi-loader';\n```\n\n### 2.3、初始化map对象\n\n本次我所使用的是 vue3，和 vue2 还是有语法上的一些差异的，这里我们先介绍 vue3 的用法。\n首先需要引入 Vue3 的 shallowRef 方法（使用 shallowRef 进行非深度监听，因为在 Vue3 所使用的 Proxy 拦截操作会改变 JSAPI 原生对象，所以此处需要区别 Vue2 使用方式对地图对象行非深度监听，否则会出现问题，建议 JS API 相关对象采用非响应式的普通对象来存储）\n```js\nimport { shallowRef } from '@vue/reactivity'\n```\n\n然后我们在 setup 中声明 map 对象：\n```js\nsetup(){\n  const map = shallowRef(null);\n    return{\n       map,\n    }\n},\n```\n\n**vue2中初始化map对象**\n仅需要以下这一句\n```js\ndata(){\n      return{\n        map:null,\n     } \n },\n```\n\n### 2.4、初始化函数 initMap\n```js\nmethods:{\n    initMap(){\n        AMapLoader.load({\n            key:\"\",             // 申请好的Web端开发者Key，首次调用 load 时必填\n            version:\"2.0\",      // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15\n            plugins:[''],       // 需要使用的的插件列表，如比例尺'AMap.Scale'等\n        }).then((AMap)=>{\n            this.map = new AMap.Map(\"container\",{  //设置地图容器id\n                viewMode:\"3D\",    //是否为3D地图模式\n                zoom:5,           //初始化地图级别\n                center:[105.602725,37.076636], //初始化地图中心点位置\n            });\n        }).catch(e=>{\n            console.log(e);\n        })\n    },\n},\n```\n\n最后就是调用初始化函数\n```js\nmounted(){\n    //DOM初始化完成进行地图初始化\n    this.initMap();\n}\n```\n\n## 3、我所使用的代码\n\n我所使用的与官方的不太相同，没有官方这么复杂\n\n首先我还是定义一个 div 容器用来存放地图组件\n```html\n<div id=\"container\" :class=\"ismoblie==true?'map1':'map2'\">\n```\n\n然后在我们的页面加载完毕之后，立即异步加载我们的地图，这就要用到 vue3 的生命周期函数中的`onMounted`。\n\n根据官方的方式进行改进，就有我以下代码的方式来实现，具体用途都写上了注释。\n这样子与官方的同样，可以生成一个地图组件\n\n**完整的代码如下**\n```js\nonMounted(()=>{\n      //页面加载完,开始异步引入高德地图\n      //创建了一个回调函数,高德地图加载完毕会调用\n      window.onLoad = function () {\n        // 所有关于地图的逻辑全部都要写在这个回调里面\n        // 保证高德地图加载完毕\n        // var map = new AMap.Map(\"container\");\n        // 地图中心点\n        var map = new AMap.Map(\"container\", {\n          zoom: 16, //级别\n          center: [110.417813,25.31373], //中心点坐标\n          viewMode: \"3D\", //使用3D视图\n        });\n      };\n      // key是申请的值\n      var url =\n          \"https://webapi.amap.com/maps?v=1.4.15&key=d6c8f397b0da87524290b6622de498f5&callback=onLoad\";\n      //创建一个 script dom元素\n      // doc需要补全document\n      var jsapi = document.createElement(\"script\");\n      //设定script标签属性\n      jsapi.charset = \"utf-8\";\n      jsapi.src = url;\n      //将API文件引入页面中,加载完毕以后会调用函数\n      document.head.appendChild(jsapi);\n    })\n```\n\n**最后效果**\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308231640.png)\n\n## 4、其他功能\n\n我们本次所使用到的仅仅是很少的一部分功能，除此之外，高德地图的API还有很多的功能，官方也有很多的实例供我们所参考：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220308230605.png)\n\n我们可以根据官方的文档去制作我们所需要的各种插件。","tags":["记录"],"categories":["博客","个人网站"]},{"title":"给个人网站加上邮箱通知","url":"/2022/03/06/2022-03-06-给个人网站加上邮箱通知/","content":"\n# 给个人网站加上邮箱通知\n\n## 1、前言\n\n一般在网站上实现邮箱通知有多种方式，原先我所使用的是`mailto:chenyc2021@qq.com`的方式，这种方式可以直接调用设备上的邮箱发送邮件，但是这样子就容易被发件人不小心修改邮箱信息，而且如果发件人的设备上没有邮箱设备，可能就无法使用这个功能了，所以本次我更新了网站中的邮件发送功能，优化用户体验。\n\n原先的发送邮件方式：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220306190513.png)\n\n现如今改成使用 [commons-email](https://commons.apache.org/proper/commons-email/) 来发送邮箱，配合前端的表单，实现邮件发送。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220306190750.png)\n\n## 2、前端部分\n\n首先编写前端表单界面，我这里所使用的是点击按钮弹出弹框的形式进行填写，然后使用 axios 将数据传送到后端。\n\n```vue\n<div class=\"Formail\" v-if=\"isAd==0\">\n    <!--<a href=\"mailto:chenyc2021@qq.com?subject=广告招标&body=广告商家：初步报价：其他联系方式：\">联系管理员</a>-->\n    <el-button type=\"success\" @click=\"dialogVisible = true\">联系管理员</el-button>\n  </div>\n  <div>\n    <el-dialog\n        v-model=\"dialogVisible\"\n        title=\"您的广告内容\"\n        width=\"30%\"\n    >\n      <div>\n        <div>\n          <span style=\"size: 18px;font-weight: bold\">广告标题：</span>\n          <el-input v-model=\"input.title\" placeholder=\"广告标题\" style=\"width: 80%\"></el-input>\n        </div>\n        <div style=\"padding-top: 5px\">\n          <span style=\"size: 18px;font-weight: bold\">广告内容：</span>\n          <el-input v-model=\"input.text\" autosize type=\"textarea\" placeholder=\"广告内容\" style=\"width: 80%\"></el-input>\n        </div>\n        <div style=\"padding-top: 5px\">\n          <span style=\"size: 18px;font-weight: bold\">广告报价：</span>\n          <el-input v-model=\"input.money\" placeholder=\"广告报价\" style=\"width: 80%\"></el-input>\n        </div>\n        <div style=\"padding-top: 5px\">\n          <span style=\"size: 18px;font-weight: bold\">显示日期：</span>\n          <el-input v-model=\"input.times\" placeholder=\"显示日期\" style=\"width: 80%\"></el-input>\n        </div>\n        <div style=\"padding-top: 5px\">\n          <span style=\"size: 18px;font-weight: bold\">联系方式：</span>\n          <el-input v-model=\"input.phone\" placeholder=\"联系方式\" style=\"width: 80%\"></el-input>\n        </div>\n        <div style=\"padding-top: 5px\">\n          <span style=\"size: 18px;font-weight: bold\">您的邮箱：</span>\n          <el-input v-model=\"input.email\" placeholder=\"您的邮箱\" style=\"width: 80%\"></el-input>\n        </div>\n      </div>\n      <template #footer>\n      <span class=\"dialog-footer\">\n        <el-button @click=\"dialogVisible = false\">取消</el-button>\n        <el-button type=\"primary\" @click=\"buyEmail\">发送</el-button\n        >\n      </span>\n      </template>\n    </el-dialog>\n  </div>\n```\n\n所显示的效果如下图所示：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220306202634.png)\n\n随后是 axios 部分，将表单的数据传送给后端。\n```js\nconst buyEmail = () => {\n      proxy.$axios.get('ad/buy',{params:{\"title\":data.input.title,\n          \"text\":data.input.text,\n          \"money\":data.input.money,\n          \"time\":data.input.times,\n          \"phone\":data.input.phone,\n          \"buyemail\":data.input.email}\n      }).then((res)=>{\n        ElMessage({\n          message: '邮件发送成功，请等待工作人员回复.',\n          type: 'success',\n        })\n      })\n      data.dialogVisible = false\n    }\n```\n发送邮件之后，会反馈信息，提高用户体验。\n\n## 3、后端\n\n现在就是重要的后端部分了。\n### 3.1、引入依赖\n\n```xml\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-email</artifactId>\n    <version>1.5</version>\n</dependency>\n```\n\n### 3.2、控制器类\n\n编写一个控制器类，接收前端传来的数据，并在此处做邮件的发送工作。\n```java\n@GetMapping(\"/buy\")\npublic int buyAd(String title,String text,String money,String time,String phone,String buyemail) throws EmailException, MalformedURLException {\n    // 创建邮件\n    HtmlEmail email = new HtmlEmail();\n    // 邮箱主机，可以是域名也可以是IP地址\n    email.setHostName(\"smtp.qq.com\");\n    // 设置使用安全链接\n    email.setSSLOnConnect(true);\n    // QQ邮箱默认的端口是465\n    email.setSslSmtpPort(\"465\");\n    // 有中文的话需要设置编码，不然会乱码\n    email.setCharset(\"UTF-8\");\n    // 设置你的邮箱名与生成的授权码\n    email.setAuthentication(\"chenyc2021@qq.com\", \"cqyruivpditnebhc\");\n    // 发件人信息，收件人收到邮件时看到的收件人姓名\n    email.setFrom(buyemail, title);\n    // 标题\n    email.setSubject(title);\n    // 内容\n    StringBuilder sb=new StringBuilder();\n    sb.append(\"广告内容：\").append(text).append('\\n')\n    .append(\"广告报价：\").append(money).append('\\r')\n    .append(\"联系方式：\").append(phone).append('\\r')\n    .append(\"上架时间\").append(time);\n    email.setHtmlMsg(sb.toString());\n\n    email.addTo(\"chenyc2021@qq.com\");\n    //发送邮件\n    email.send();\n    return 1;\n}\n```\n\n上面的代码就是发送邮件所需要的最基础的代码了。除此之外还有很多方法可供我们使用，如果只是实现简单地发送，只要上面地简短代码即可。\n\n这里有一个邮箱的授权码，我以QQ邮箱为例子。\n1. 首先打开设置中的账户\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220306203509.png)\n2. 然后打开 POP3/SMTP服务，然后会有一个生成授权码的按钮，点击认证即可生成，然后及时复制到本地。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220306203652.png)\n\n\n","tags":["记录"],"categories":["博客","个人网站"]},{"title":"Java反射机制","url":"/2022/03/04/2022-03-04-Java反射机制/","content":"\n# Java反射机制\n\n## 1、反射是什么?\n\nJava反射机制（Java Reflection）是Java语言中一种动态（运行时）访问、检测以及修改它本身的能力。主要作用是动态获取类完整的结构信息和调用对象的方法。\n\n**正射和反射的区别：**\n一般情况下，我们使用某个类，都会知道这个类，以及要用它来做什么，可以直接通过 new 实例化创建对象，然后使用这个对象对类进行操作，这个就属于正射。\n而反射则是不知道要初始化的是什么类，无法使用 new 来实例化创建对象，主要通过 JDK 提供的反射 API 来实现，在运行时才知道要操作的是什么类，并且可以获取到类的完整构造以及调用对应的方法，这就是反射。\n\n**举例：**\n\n```java\npublic class Student {\n    private int id;\n\n    public void setId(int id) {\n        this.id = id;\n    }\n    public int getId() {\n        return id;\n    }\n\n    public static void main(String[] args) throws Exception{\n        //一、正射调用过程\n        Student student = new Student();\n        student.setId(1);\n        System.out.println(\"正射调用过程Student id:\" + student.getId());\n\n        //二、反射调用过程\n        Class clazz = Class.forName(\"com.justin.java.lang.Student\");\n        Constructor studentConstructor = clazz.getConstructor();\n        Object studentObj = studentConstructor.newInstance();\n        \n        Method setIdMethod = clazz.getMethod(\"setId\", int.class);\n        setIdMethod.invoke(studentObj, 2);\n        Method getIdMethod = clazz.getMethod(\"getId\");\n        System.out.println(\"正射调用过程Student id:\" + getIdMethod.invoke(studentObj));\n    }\n}\n```\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220304122334.png)\n\n## 2、反射获取 Class 的三种方式\n\n在 Java 中，反射获取 Class 有三种方式，这三种方式各有各的优点。\n以下是三种获取 Class 的方式：\n\n1. 通过 `类名.class`来获取。\n2. 通过`Class.forName(\"类的全局路径\")`来获取。\n3. 通过`new 类名().getClass()`来获取。\n\n使用第一种方式获取 Class，JVM 会使用 ClassLoader 类加载器将类加载到内存中，但并不会做任何类的初始化工作，返回 java.lang.Class 对象。\n使用第二种方式获取 Class，类会被 JVM 加载到内存中，并且会进行类的静态初始化工作，返回 java.lang.Class 对象。\n第三种获取 Class 的方式，它使用了 new 进行实例化操作，因此静态初始化和非静态初始化工作都会进行，getClass 方法属于顶级 Object 类中的方法，任何子类对象都可以调用，哪个子类调用，就返回那个子类的 java.lang.Class 对象。\n\n## 3、反射的优缺点\n\n**优点:**\n在运行时获得类的各种内容，进行反编译，对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。\n\n**缺点:**\n（1）反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；\n（2）反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n\n## 4、方法的反射\n\n**步骤思路：**\n1.获取该类的类类型\n2.通过类类型获取类的方法（getMethods()）\n3.循环遍历所获取到的方法\n4.通过这些方法的getReturnType()得到返回值类型的类类型，又通过该类类型得到返回值类型的名字\n5.getName()得到方法的名称，getParameterTypes()获取这个方法里面的参数类型的类类型。\n\n**实例：**\n```java\npublic class ClassUtil {\n    public static void printClassMethodMessage(Object obj){\n        //想要获取类的信息,首先我们要获取类的类类型\n        Class c = obj.getClass();\n        //Object类是一切类的父类，所以我们传递的是哪个子类的对象，c就是该子类的类类型。\n        //然后获取类的名称\n        System.out.println(\"类的名称是:\"+c.getName());\n        /*\n        *既然方法也是对象，那么是谁的对象呢？\n        * 在java里面，方法是Method类的对象\n        *一个成员方法就是一个Method的对象，那么Method就封装了对这个成员\n        *方法的操作\n        */\n        //如果我们要获得所有的方法，可以用getMethods()方法，这个方法获取的是所有的Public的函数，包括父类继承而来的。如果我们要获取所有该类自己声明的方法，就可以用getDeclaredMethods()方法，这个方法是不问访问权限的。\n        Method[] ms = c.getMethods();//c.getDeclaredMethods()\n        //接下来我们拿到这些方法之后干什么？我们就可以获取这些方法的信息，比如方法的名字。\n        //首先我们要循环遍历这些方法\n        for(int i = 0; i < ms.length;i++){\n            //然后可以得到方法的返回值类型的类类型\n            Class returnType = ms[i].getReturnType();\n            //得到方法的返回值类型的名字\n            System.out.print(returnType.getName()+\" \");\n            //得到方法的名称\n            System.out.print(ms[i].getName()+\"(\");\n            //获取参数类型--->得到的是参数列表的类型的类类型\n            Class[] paramTypes = ms[i].getParameterTypes();\n            for (Class class1 : paramTypes) {\n            \tSystem.out.print(class1.getName()+\",\");\n            }\n        System.out.println(\")\");\n        }\n    }\n}\n```\n\n## 5、成员变量的反射\n\n成员变量也是对象，是java.lang.reflect.Field类的对象，那么也就是说Field类封装了关于成员变量的操作。既然它封装了成员变量，我们又该如何获取这些成员变量呢？它有这么一个方法：\n```java\npublic class ClassUtil {\n    public static void printFieldMessage(Object obj){\n        Class c = obj.getClass();\n        Field[] fs = c.getFields();\n    }\n}\n```\n这里的getFields()方法获取的所有的public的成员变量的信息。和方法的反射那里public的成员变量，也有一个获取所有自己声明的成员变量的信息：`Field[] fs = c.getDeclaredFields();`\n我们得到它之后，可以进行遍历（既然封装了Field的信息，那么我们就可以得到Field类型）\n```java\nfor (Field field : fs) {\n    //得到成员变量的类型的类类型\n    Class fieldType = field.getType();\n    String typeName = fieldType.getName();\n    //得到成员变量的名称\n    String fieldName = field.getName();\n    System.out.println(typeName+\" \"+fieldName);\n}\n```\n\n## 6、Class类的动态加载类\n\n动态加载是啥意思？怎么样动态加载一个类呢？\n首先我们需要明白的是，动态加载和静态加载的概念以及区别。\n我们一般所理解的，在编译的时候所加载的类是静态加载类；而运行的时候加载的类是动态加载类。\n```java\nClass A{\n    Public static void main(String[] args){\n        if(\"B\".equal(args[0])){\n            B b=new B();\n            b.start();\n        }\n        if(\"C\".equal(args[0])){\n            C c=new C();\n            C.start();\n        }\n    }\n}\n```\n上面这一段代码，如果我们仅仅是在 IDEA 之中运行，是可以正常运行不发生错误的，而如果我们在 CMD 控制台运行的话，就会抛出问题。如下：\n```\nA.java：7：错误：找不到符号\nB b=new B();\n符号:  类B\n位置： 类A\nA.java：7：错误：找不到符号\nB b=new B();\n符号:  类B\n位置： 类A\nA.java：12：错误：找不到符号\nC c=new C();\n符号:  类C\n位置： 类A\nA.java：12：错误：找不到符号\nC c=new C();\n符号:  类C\n位置： 类A\n4个错误\n```\n\n此时，因为B不存在，就应该是错误的。\n但是，仔细想想，会发现B我们不一定使用，C我们也不一定使用。\n现在我们来模拟一下B存在的情况。\n也就是先编译B，然后再编译A。\n但是此时还是有问题，C也是不存在的。\n但是我们现在根本就不想用C，我们只想用B，那怎么办？\n想要正常使用B，我们就不得不将C一起编译。而如果有ABCDEFGHIJKLMN个类，我们同样只想用B，那么我们是不是同样得全部编译他们呢？答案是肯定的。这样子肯定不是很好的。\n以上这种说法就是所谓的静态加载类。\n而解决这个问题的方法也很简单，就是改为动态加载类。即要使用的时候再创建。\n\n我们新建一个类：\n```java\nClass All{\n    Public static void start(){\n    \ttry{\n            Class cl= Class.forName(args[0]);\n            //通过类类型，创建该类的对象\n            cl.newInstance();\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n```\nClass.forName(\"类的全称\")，它不仅仅表示了类的类类型，还表示了动态加载类。当我们javac A.ava的时候，它不会报任何错误，也就是说在编译的时候是没有错误的。只有当我们具体用某个类的时候，那个类不存在，它才会报错。\n\n如果我们要加载B，那么就需要：`B bt = (B) cl.newInstance();`\n加载C，就是：`C ct = (C) cl.newInstance();`\nDEFG等等都是这样。\n\n但是如果有一百各类，我们不可能写一百句这个，太冗余了。\n我们可以写一个统一处理的方法，统一一个标准，只要满足这个标准的都可以使用这个方法。\n`and s = (Stand) cl.newInstance();`\n\n例如B类：\n```java\nClass B implements Stand{\n    Public void start(){\n    \tSystem.out.print(\"B...satrt\");\n    }\n}\n```\n即满足了前面的标准。就可以通过这个统一的标准来运行。\n\n如果以后想用某一个类，不需要重新编译，只需要实现这个标准的接口即可。只需要动态的加载新的东西就行了。\n这就是**动态加载类**。","tags":["java"],"categories":["java","反射"]},{"title":"自定义注解","url":"/2022/02/09/2022-02-09-自定义注解/","content":"\n# 自定义注解\n\n## 1、注解\n\n注解是 java 这一门编程语言中很重要的一个知识点，利用注解，我们可以很方便实现很多功能。\n它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。\n注解不会影响代码的正常运行，他与我们的代码处于两个时空中，但是注解和我们的代码又在某些方面相互影响。\njava 中，所有的注解都继承了 Annotation 接口。\njava 中，已经预定义了很多注解，以方便我们的使用，我们可以在编程过程中直接对这些注解进行调用，实现我们所需要的功能。\n以下列出了一些平时会用到的注解：\n\n### 1.1、基础注解\n\n`@Override`:\n表示该方法是重写的方法。\n`@Deprecated`:\n表示该方法是过时的方法，我们在一些旧版本的 API 文档中警方会看到这个注解。\n\n### 1.2、元注解\n\n在我们自定义注解的过程中，就会使用到这些元注解，它可以帮助我们构建自己的自定义注解，就是用在注解中的注解。\n\n`@Target`:\n表示该注解可以被放在哪个位置。\n它的参数类型如下所示：\n```\nElementType.TYPE：能修饰类、接口或枚举类型\nElementType.FIELD：能修饰成员变量\nElementType.METHOD：能修饰方法\nElementType.PARAMETER：能修饰参数\nElementType.CONSTRUCTOR：能修饰构造器\nElementType.LOCAL_VARIABLE：能修饰局部变量\nElementType.ANNOTATION_TYPE：能修饰注解\nElementType.PACKAGE：能修饰包\n```\n\n`@Retention`:\n用于声明生命周期。\n参数类型如下所示：\n```\nRetentionPolicy.SOURCE：源码阶段\nRetentionPolicy.CLASS： 编译阶段\nRetentionPolicy.RUNTIME：运行阶段\n```\n\n`@Inherited`:\n表示注解可以被子类继承。即子类继承父类以后，也可以继承父类的注解。\n\n`@Documented`:\n表示生成 API 。\n\n`@Repeatable`:\n表示注解在同一个地方可以出现多次，如果不加这个注解的话，同一个地方注解只能出现一次。\n\n## 2、自定义注解\n\n对于自定义注解，说起来其实十分简单，用`@interface`修饰一个我们所创建的“类”，然后再加上我们需要的一些元注解，就可以实现一个自定义注解了。\n\n对于创建的自定义注解，我们需要考虑以下几个问题：\n1. 注解用在什么地方？\n2. 注解什么时候使用？\n3. 注解想要实现什么功能？\n\n在考虑好上面的这些问题之后，通过合理使用元注解，我们就能解决以上的一些问题。\n可以说自定义注解和元注解之间的关系密不可分！就比如说盖楼时我们必须打地基一样。\n\n自定义注解可以有很多种形式，以下是几个自定义注解的例子。\n\n### 2.1、自定义注解可以存放变量\n\n首先我们创建一个以下的自定义注解：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220209224224.png)\n\n可以看出来，这个自定义注解中有三个变量，分别是`id`，`name`，`age`。\n别处通过注解，可以很方便的使用它们。\n\n当我们创建一个类，标上这个注解的时候，他会提示我们所需要的三个变量：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220209225911.png)\n\n此时我们输入所需元素：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220209230104.png)\n\n如果我们想拿到注解中我们设置好的结果，通过以下的方法即可拿到：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220209230840.png)\n\n\n\n### 2.2、自定义注解实现某个功能\n\n上面的用法通常不太常见，我们更多所见到的，是通过注解来实现某个功能，所以下面就是一个这样的例子。\n\n因为参数校验是位于业务逻辑执行执行，可以考虑将其拆分。\n所以这个注解可以简单实现检验一个参数是否为空等检验功能。\n由于并不是所有的方法，都需要校验(某些方法允许空参数)，所以考虑使用自定义注解，让开发者进行灵活控制。\n\n首先创建以下的一个注解：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210112425.png)\n\n然后是注解用于检验的类\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210112726.png)\n\n然后在需要验证的字段上添加上这个注解\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210112920.png)\n\n最后创建一个控制器类，来检验我们的代码\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210113128.png)\n\n当我们标注的 name 字段有值的时候，可以正常返回信息\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210113421.png)\n\n而当值为空的时候，则会出现错误，后台会提示具体的错误信息\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210113505.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220210114008.png)\n\n以上就是一个验证字段是否为空的自定义注解的例子。\n\n## 3、附录\n\n`testInt1`:\n\n```java\nimport java.lang.annotation.*;\n\n/**\n * @author George\n * @project test2\n * @package demo1\n * @date 2022/2/9 21:30\n * @since 1.0\n */\n@Target({ElementType.METHOD,ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface testInt1 {\n    int id();\n    String name();\n    int age();\n}\n```\n`l1`:\n\n```java\n/**\n * @author George\n * @project test2\n * @package demo1\n * @date 2022/2/9 22:58\n * @since 1.0\n */\n\n@testInt1(id = 1,name = \"chenyicai\",age = 22)\npublic class l1 {\n\n    public static void f1(){\n        testInt1 testInt1=l1.class.getAnnotation(demo1.testInt1.class);\n\n        System.out.println(testInt1.id());\n        System.out.println(testInt1.name());\n        System.out.println(testInt1.age());\n    }\n\n    public static void main(String[] args) {\n        f1();\n    }\n}\n```\n\n`isNotNull`:\n```java\n//仅仅用于请求字段的非空校验\n@Target(ElementType.FIELD)\n//需要jvm运行时使用\n@Retention(RetentionPolicy.RUNTIME)\n//使用validator时必须添加，指定与NotNullValidator自定义校验器配合使用\n@Constraint(validatedBy = isNotNullValidator.class)\n@Inherited\n@Documented\n//@interface 代表此类是注解类\npublic @interface isNotNull {\n\n    // 默认错误信息\n    String message() default \"不能为空\";\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n}\n```\n\n`isNotNullValidator`:\n```java\npublic class isNotNullValidator implements ConstraintValidator<isNotNull,Object>{\n    @Override\n    public boolean isValid(Object o, ConstraintValidatorContext constraintValidatorContext) {\n        //此时name是当前非空校验的字段名\n        String name = String.valueOf(((ConstraintValidatorContextImpl) constraintValidatorContext)\n                .getConstraintViolationCreationContexts().get(0).getPath());\n        System.out.println(name + \" value is \" + String.valueOf(o));\n\n        //o是字段的值，我们需要校验是否为空\n        if(null == o ||\"\"==o){\n            // 获取到注解中message的值\n            System.err.println(((ConstraintValidatorContextImpl) constraintValidatorContext)\n                    .getConstraintViolationCreationContexts().get(0).getMessage());\n            //返回false代表校验失败\n            return false;\n        }\n        //返回true代表校验成功\n        return true;\n    }\n}\n```\n\n`Users`:\n```java\n@Data\npublic class Users {\n\n    private int id;\n    @isNotNull(message = \"姓名不能为空\")\n    private String name;\n}\n```\n\n`TestController`:\n```java\n@RestController\npublic class TestController {\n\n    @GetMapping(\"/add\")\n    public Object addUser(@Valid Users users){\n        return \"111\";\n    }\n}\n```","tags":["java","注解"],"categories":["java","注解"]},{"title":"位运算","url":"/2022/02/01/2022-02-01-位运算/","content":"\n# 1、位运算\n\n程序中的所有数在计算机内存中都是以二进制的形式储存的。\n位运算就是直接对整数在内存中的二进制位进行操作。\n比如，and运算本来是一个逻辑运算符，但整数与整数之间也可以进行and运算。\n举个例子，6的二进制是110，11的二进制是1011，那么6 and 11的结果就是2，它是二进制对应位进行逻辑运算的结果.\n&运算时，当且仅当两者都为 1 时，结果才为 1.\n使用二进制来表示就是如下：\n6  ：0 1 1 0\n11：1 0 1 1\n——————\n2  ：0 0 1 0\n\n相比于使用常规的运算符，在计算机语言中，合理使用位运算符能很好地帮助我们提高效率。\n\n## 2.1、位运算符\n\n|符号|描述|运算规则|\n| ---- | ---- | ---- |\n|&|与|两个位都为1时，结果才为1|\n|\\||或|两个位都为0时，结果才为0|\n|^|异或|两个位相同为0，相异为1|\n|~|非|0变1，1变0|\n|<<|左移|各二进位全部左移若干位，高位丢弃，低位补0|\n|>>|右移|各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）|\n\n## 2.2、实例\n### 2.2.1、与\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n2 ：0 0 1 0\n```\n当且仅当两者都为 1 的时候，结果才为 1，所以在这里只有第三位两者都为 1 ，所以结果就是 0010。\n\n### 2.2.2、或\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n15：1 1 1 1\n```\n当且仅当两者都为 0 的时候，结果才为 0，所以在这里所有的结果都为 1  ，所以结果就是 1111。\n\n### 2.2.3、非\n```\n6 ：0 1 1 0\n————————————\n9 ：1 0 0 1\n```\n非的规则是将 1 变成 0，0 变成 1，所以0110非操作之后就是1001，为9.\n\n### 2.2.4、异或\n```\n6 ：0 1 1 0\n11：1 0 1 1\n————————————\n13：1 1 0 1\n```\n异或的运算规则：0^0=0  0^1=1  1^0=1  1^1=0 相同为 0，相异为 1.\n\n### 2.2.5、左移和右移\n**左移：**\n```\n6 ：0 1 1 0\n————————————\n12：1 1 0 0\n```\n左移就是将所有的 1 都左移一位，然后空位上补0，所以 6 左移一位的结果就是 12.相当于 6 乘 2 等于 12.\n**右移：**\n```\n6 ：0 1 1 0\n————————————\n3 ：0 0 1 1\n```\n右移就是将所有的 1 都右移一位，然后空位上补0，所以 6 右移一位的结果就是 3.相当于 6 除 2 等于 3.\n\n从上面可以看出，如果我们在平时需要用到乘法或者除法，就可以使用左移和右移来进行替代，可以更好地提高效率。\n\n## 2.3、使用技巧\n### 2.3.1、实现乘除法\n数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2\n```\nint a = 2;\na >> 1; ---> 1\na << 1; ---> 4\n```\n\n### 2.3.2、交换两个数\n使用位运算交换两个数的时候，可以不使用第三个变量，虽然这个操作普通的运算也能做到，但是效率远不如位运算。\n```java\n//普通操作\nvoid swap(int &a, int &b) {\n  a = a + b;\n  b = a - b;\n  a = a - b;\n}\n\n//位与操作\nvoid swap(int &a, int &b) {\n  a ^= b;\n  b ^= a;\n  a ^= b;\n}\n```\n\n### 2.3.3、判断奇偶数\n只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。\n```java\nif(0 == (a & 1)) {\n //偶数\n}\n```\n\n### 2.3.4、交换符号\n交换符号将正数变成负数，负数变成正数\n```java\nint reversal(int a) {\n  return ~a + 1;\n}\n```\n\n### 2.3.5、求绝对值\n整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作\n```java\nint abs(int a) {\n  int i = a >> 31;\n  return i == 0 ? a : (~a + 1);\n}\n```\n上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)\n```java\nint abs2(int a) {\n  int i = a >> 31;\n  return ((a^i) - i);\n}\n```\n\n除此之外，还有很多用途。\n\n## 2.4、写法\n\n和普通的运算符一样，位运算符也可以组成复合运算符的形式。\n如下：\n```\n&=        例：a&=b    相当于     a=a&b\n|=        例：a|=b    相当于     a=a|b\n>>=      例：a>>=b   相当于     a=a>>b\n<<=      例：a<<=b     相当于      a=a<<b\n^=        例：a^=b    相当于   a= a^b\n```\n\n## 2.5、算法题应用\n### 2.5.1、只出现一次的数字\n**问题描述**\n给定一个非空整数数组，除了某个元素只出现一次以外，**其余每个元素均出现两次**。找出那个只出现了一次的元素。\n说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**分析**\n\n1. 0和任意数字进行异或操作结果为数字本身.\n2. 两个相同的数字进行异或的结果为0.\n\n**解答**\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int value=0;\n        for(int i=0;i<nums.length;i++)\n        {\n            value^=nums[i];\n        }\n        return value;\n    }\n}\n```\n\n### 2.5.2、只出现一次的数字\n**问题描述**\n给定一个非空整数数组，除了某个元素只出现一次以外，**其余每个元素均出现了三次**。找出那个只出现了一次的元素。\n说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n**分析**\n这题和上一题的思路略有不同，这题其他数字出现了3次，那么我们如果直接使用位运算异或操作的话无法直接找到结果，就需要巧妙的运用二进制的其他特性：判断整除求余操作。即判断所有数字二进制1的总个数和0的总个数一定有一个不是三的整数倍，如果0不是三的整数倍那么就说明结果的该位二进制数字为0，同理否则为1.\n在具体的操作实现上，问题中给出数组中的数据在int范围之内，那么我们就可以在实现上可以对int的32个位每个位进行依次判断该位1的个数求余3后是否为1，如果为1说明结果该位二进制为1可以将结果加上去。最终得到的值即为答案。\n**解答**\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int value=0;\n        for(int i=0;i<32;i++)\n        {\n            int sum=0;\n            for(int num:nums)\n            {\n                if(((num>>i)&1)==1)\n                {\n                    sum++;\n                }\n            }\n            if(sum%3==1)\n                value+=(1<<i);\n        }\n        return value;\n    }\n}\n```","tags":["java"]},{"title":"2021年终总结","url":"/2022/01/10/2022-01-10-2021年终总结/","content":"\n# 1、2021\n\n2021是崭新的一年，是疫情的第二年，也是大学生涯的第三年。\n\n## 1.1、编程学习\n\n今年一年，是冲刺学习 java 的一年，大部分的知识都是在今年学习到的。\n在今年，当了四个项目的组长，虽然都是简单的单体项目，但是在学习中一步一步成长的感觉还是十分舒服的。四个项目分别是：点餐系统、桂电宿舍管理系统、国医堂小程序以及骏泰理发店管理系统。\n2月，尽管是过年时间，线上学习还是不能停。\n6月，其他同学都放假回家了，我们留在学校加班学习，第一次不回家过暑假，看着家里的朋友在家喝茶玩耍，真是恨不得当场买票回去。但是想到以后工作之后，这将成为常态，感觉自己还是得适应，同时也感叹自己即将步入社会，也会开始怀念大学生活了。\n暑假的加班学习是为了今后更好的就业，所以我也一直在加油。\n8月，开发了自己的第一个博客，用的是 hexo 的框架，主要是图方便，还好看，主题多。然后博客是用 GitHubPage 搭建的，所有内容都存在GitHub上。想着这个博客里分享一些自己学到的技术，还有写一些自己的感想什么的。\n9月，开始面试了。在面试过程中，第一家公司，也就是现在签三方的公司，面试过程都比较轻松，感觉面试官也比较看重我。后面在面试一家工资较高的公司的时候，虽然笔试成绩还算不错，但是因为学的不够深入，很多问题没有回答上来，所以就被刷下来了。\n总结一下今年的秋招面试：有遗憾，但是也很满足了。\n11月，想着自己有一个闲置的服务器，就想着用来做点什么，就自己开发了一个书签项目，放在服务器里面，里面存了一些自己用过的书签网站，还可以快速跳转到我的博客，还可以快速搜索，自己还异想天开弄了一个广告框，想着有人能打广告，赚点零花钱。以后还会自己开发这个项目，增加更多功能。\n12月和好兄弟一起开发了一个真实的项目：桂林医学院报修系统！这个项目虽然是学长留下的二手项目，但是在接手项目时，从阅读源码到本地运行，从本地开发到正式上线，我真实感觉到了自己从项目中学习到了很多新的思想。一开始接手项目时，基本上是从0开始阅读源码，到现在已经可以灵活使用以及修改项目中的每一处代码，从中看到了自己的进步，同时也看到了自己和其他人的差距所在。\n印象比较深刻的是第一次上线自己写的程序的时候，刚刚一开始上线，系统就进不去了，折腾了一个晚上还是没有解决，最后还是靠学长帮忙才得以解决（虽然后面发现其实并不是我们的锅）。\n知道前几天，一起开发的兄弟才发现，原来是服务器jar的加密问题，具体的我也不太懂。\n其间还跟着老师去见了一次甲方，对项目的二期需求进行一个沟通，第一次真实经历这种场面，一开始还真有点紧张，但是到后面也逐渐放松了下来这样的经验是很珍贵的，对以后的职场应对有很大的帮助。在沟通过程中甲方有些不经过脑子的需求确实很难以理解，但是在积极的沟通之下还是进行的很顺利。\n现在项目一期也已经验收通过了，老师也说二期不用太过着急，但是还是要提上日程，尽快完成需要的项目。\n而另一个理发店项目基本处于放羊状态，也不着急，我们就慢慢做了。\n\n目前也在学习算法，只要算法玩的好，大厂什么的根本不是梦。\n## 1.2、专业学习\n\n今年是毕业年级了，要考虑的不只是学习，还有自己未来的发展方向。\n3月，现在是大三的下学期，这个学期会接触到更多的编程方面的课程，比如说：Java语言程序设计、算法分析与设计、软件工程、ACM程序设计等等。这样的课程对我来说是比较感兴趣的，相对于数学，我觉得我更适合编程，果然自己是一个科研废物。\n7月，成绩全都出了，今年终于迎来自己第一个大满贯，没有挂科科目，继续加油，争取更好成绩！今年暑假留校，加班学习。\n9月，正式成为一个大四狗。今年除了面对学习的压力，更多的是来自就业方面的，由于疫情的影响，大学生就业形式不容乐观，提升自己专业能力，才是使自己更有优势的唯一途径。\n12月，又是一个大满贯，终于把所有的课程都修完了，困扰了我多年的英语也终于都通过了。接下来就是毕业论文了，我做的内容是纯理论研究，对于我这样一个科研废物来说，这样的内容无疑是要我老命，但是没办法，终究自己还是数学专业的人，只能硬着头皮做了。\n奖项方面，今年跟同学一起拿了几个小奖项，数学建模竞赛校内三等奖、市场调查大赛校内三等奖、金融证券大赛南部赛区团队一等奖。\n感觉专业学习方面的年终总结确实写不出啥东西，毕竟科研方面自己还是不如其他同学。。。\n\n\n# 2、年度总结\n年度编程语言：java\n年度框架：Spring Boot\n年度IDE：IntelliJ IDEA\n年度技术社区：CSDN\n年度学科：数学\n年度歌手：五月天\n年度演员：沈腾\n年度电影：《飞驰人生》\n年度游戏：城市天际线\n年度社交软件：微信\n年度音乐软件：QQ音乐\n年度视频平台：bilibili\n年度UP主：徐大虾\n年度综艺：下一个是谁\n年度动漫：某科学的超电磁炮\n年度运动：篮球\n年度球队：洛杉矶湖人\n年度球星：凯尔 库兹马\n","tags":["随笔"],"categories":["随笔","年终总结"]},{"title":"SpringBoot发送微信模板消息","url":"/2021/12/10/2021-12-10-SpringBoot发送微信模板消息/","content":"\n# SpringBoot发送微信模板消息\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- MySQL 8.0\n\n## 2、工作\n\n这段时间在做项目的时候，甲方要求将之前的易班消息推送更换成微信公众号模板消息推送，所以本文就是记录一下使用模板消息的过程，\n\n开发的时候我用的是微信的[测试公众账号](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)，但是实际的功能和企业的账号是一样的。\n\n\n\n## 3、准备工作\n\n首先我们要知道，{% wavy 模板消息 %}是什么？以下就是公众号模板消息，我们在生活中很多场景都会接触到它。\n<img src=\"https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/Screenshot_2021-12-06-23-00-46-398_com.tencent.mm.jpg\" style=\"zoom:15%;\" />\n\n在进入了测试号的管理后台之后，我们可以在这里设置我们的模板消息的{% wavy 模板 %}\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209002928.png)\n\n首先我们要在公众平台中设置好我们的模板，然后 java 中根据模板信息来添加相应的内容。\n\n## 4、java后端编写\n\n我们创建一个名为`WeChatNotify`的工具类，里面存放的是模板消息的设置内容\n\n```java\n@Component\npublic class WeChatNotify {\n    @Autowired\n    private IDictService ds;\n    @Autowired\n    private ParseUtil pu;\n    @Autowired\n    private JdrService js;\n\n    // 发送模板信息\n    public String push(String openid,String map, Bxd bxd) {\n        //1，配置\n        WxMpInMemoryConfigStorage wxStorage = new WxMpInMemoryConfigStorage();\n        wxStorage.setAppId(\"wxacc93d31c5dbd26f\");\n        wxStorage.setSecret(\"f8c9e82b590ac71eb12e96f77cf65740\");\n        WxMpService wxMpService = new WxMpServiceImpl();\n        wxMpService.setWxMpConfigStorage(wxStorage);\n        //2,推送消息\n        WxMpTemplateMessage templateMessage = WxMpTemplateMessage.builder()\n                .toUser(openid)//要推送的用户openid\n                .templateId(\"-1pT4MrVw4asKamh0IQMF6c22Ih74dRjxqN8fwhjoQs\")//模版id\n                .url(\"https://www.cyc0819.top\")//点击模版消息要访问的网址\n                .build();\n\n        // 获取保修类别\n        String bxlb=pu.paraseBxlb(bxd.getBxlb());\n        //3,正式版发送模版消息，这里需要配置你的信息，替换微信公众号上创建的模板内容\n        templateMessage.addData(new WxMpTemplateData(\"map\", map, \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"type\",bxlb, \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"text\", bxd.getXxdd()+bxd.getBxnr(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"time\", bxd.getYysj(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"name\", bxd.getSbr(), \"#173177\"));\n        templateMessage.addData(new WxMpTemplateData(\"phone\", bxd.getSbrsj(), \"#173177\"));\n        try {\n            wxMpService.getTemplateMsgService().sendTemplateMsg(templateMessage);\n            return \"推送成功\";\n        } catch (Exception e) {\n            System.out.println(\"推送失败：\" + e.getMessage());\n            e.printStackTrace();\n            return \"推送失败\";\n        }\n    }\n\n    // 检查openid是否已经绑定\n    public String selOpenid(String ybid){\n        String openid=js.selOpenidForYbid(ybid);\n        if (openid == null){\n            return null;\n        }\n        return openid;\n    }\n}\n```\n在这里，我们需要公众号的`appid,appsecret`，以及接收人的`openid`。\n\n{% note warning:: 如何获取用户的 openid 可以看以下这篇文章。 %}\n{% link SpringBoot+Vue微信授权获取用户openid :: http://cyc0819.top/2021/12/09/2021-12-09-SpringBoot+Vue%E5%BE%AE%E4%BF%A1%E6%8E%88%E6%9D%83%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7openid/ %}\n\n给足所需要的消息，然后在要发送消息的地方调用即可\n```java\npublic String zdpdWeChat(String eid, String bxlb,Bxd bxd){\n    String ybid=zdpd(eid,bxlb);\n    String map=es.selxxwz(Integer.parseInt(eid));\n    //调用发送模板信息\n    wcn.push(\"OPENID\",map,bxd);\n    return ybid;\n}\n```\n\n","tags":["java","SpringBoot"],"categories":["java","SpringBoot"]},{"title":"SpringBoot+Vue微信授权获取用户openid","url":"/2021/12/09/2021-12-09-SpringBoot+Vue微信授权获取用户openid/","content":"\n# SpringBoot+Vue微信授权获取用户openid\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- MySQL 8.0\n- Vue 3.0\n\n## 2、需求\n\n这几天在做桂林医学院的项目的时候，甲方提出了需求说能不能将消息通知改成微信公众号通知，因为公众号的效率比较高，同时受众也是比较多（原本用的是易班的 api，文档及其不友好，bug 官方也不解决，按照上一届学长的说法，之前发送消息接收人得等两天之后才能收到）。\n\n而如果用到微信的公众号，必须就得接收人主动绑定自己的微信号，我们才能获取他的 openid ，才能对其发送模板消息。\n\n## 3、微信公众号模板消息\n\n开发的时候我用的是微信的[测试公众账号](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)，但是实际的功能和企业的账号是一样的。\n\n首先我们要知道，{% wavy 模板消息 %}是什么？以下就是公众号模板消息，我们在生活中很多场景都会接触到它。\n<img src=\"https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/Screenshot_2021-12-06-23-00-46-398_com.tencent.mm.jpg\" style=\"zoom:15%;\" />\n\n在进入了测试号的管理后台之后，我们可以在这里设置我们的模板消息的{% wavy 模板 %}\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209002928.png)\n\n当然，本文的主题并不是模板消息的发送，而是使用模板消息的时候引发的其他问题，具体的模板消息可以移步我的：\n{% link SpringBoot发送微信模板消息 :: http://cyc0819.top/2021/12/10/2021-12-10-SpringBoot%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF/ %}\n\n## 4、SpringBoot获取openid\n\nopenid 是微信用户的唯一标识，就跟人的身份证一样，每个微信号都有一个自己的 openid ，用于识别每个微信，一般情况下，我们无法看到，更无法修改我们的 openid，此时如果需要获取，就需要微信官方给我们提供的接口：\n\n我们点开下图中的{% span blue::蓝色 %}字体,\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003547.png)\n可以进入到[网页授权](https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html)的界面：\n\n里面详细介绍了获取openid，甚至是用户信息的过程：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003923.png)\n\n以下是我通过 java 实现的一些过程，可供参考。\n\n### 4.1、用户同意授权，获取code\n\n根据官方的说法，我们需要请求一个链接来获取到用户的 CODE\n链接如下：\n`https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect`\n\n这里有几个参数，官方文档都有说明，这里重点是把要去上一步中：\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209003547.png)\n\n最后面的修改那里，将域名改成与  REDIRECT_URI 一致\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209004933.png)\n\n而此时我们选择的`scope`是需要用户手动通过授权的`snsapi_userinfo`\n\n然后我们就有了我们的链接，此时就要去代码中对其进行请求了。\n\n以下就是java代码\n首先我们在 SpringBoot模块中建一个 `WechatOAuth` 控制器，用来接受前端发来的请求\n```java\n@RestController\n@RequestMapping(\"wechat\")\npublic class WechatOAuth {\n\n    @Autowired\n    private AuthUtil authUtil;\n    @Resource\n    private UserService userService;\n\n    // 用户同意授权，获取code\n    @RequestMapping(\"/oauth\")\n    public void oauth(HttpServletResponse response, String id) throws IOException {\n\n        // System.out.println(\"开始询问用户是否同统一授权\");\n        String appid = \"wxac**********d26f\";\n        String path = \"http://10.33.73.62:8089/wechat/invoke\";\n        path = URLEncoder.encode(path, \"UTF-8\");\n\n        String url = \"https://open.weixin.qq.com/connect/oauth2/authorize?appid=\" + appid\n                + \"&response_type=code&scope=snsapi_userinfo&redirect_uri=\" + path\n                + \"&state=\" + id\n                + \"&connect_redirect=1#wechat_redirect\";\n        //请求转发链接\n        response.sendRedirect(url);\n    }\n}\n```\n在这里，我们请求链接获得 code ，然后返回我们设置好的{% wavy 回调地址 %}，也就是上面的 path，（注意，此处的地址要和前面我们设置的一致，后面的端口可以改变）\n\n### 4.2、通过code换取网页授权openid\n\n然后我们再写一个转发之后的控制器。\n也就是上一步中`String path = \"http://10.33.73.62:8089/wechat/invoke\";`\n\n```java\n// 用户同意授权\n    @RequestMapping(\"/invoke\")\n    public String oauthInvoke(HttpServletRequest request, HttpServletResponse response) {\n        // 获得code\n        System.out.println(\"用户同意授权，开始获取openid\");\n        String code = request.getParameter(\"code\");\n        String state = request.getParameter(\"state\");\n        System.out.println(code);\n        System.out.println(state);\n\n        // 判断是否绑定过openid\n        String isOpenid=userService.selUser(state).getOpenid();\n        if (isOpenid!=null){\n            return \"您已经绑定过微信了,如需修改请联系管理员\";\n        }\n        // 通过token获取access_token\n        String appid = \"wxacc93d31c5dbd26f\";\n        String secret = \"f8c9e82b590ac71eb12e96f77cf65740\";\n        String url = \"https://api.weixin.qq.com/sns/oauth2/access_token?appid=\" + appid\n                + \"&secret=\" + secret\n                + \"&code=\" + code\n                + \"&grant_type=authorization_code\";\n        try {\n            JSONObject jsonObject = authUtil.doGetJson(url);\n            String openid= (String) jsonObject.get(\"openid\");\n            System.out.println(openid);\n            // 将openid插入到user表中\n            userService.addOpenid(state,openid);\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"授权成功,绑定微信成功\";\n    }\n```\n\n此处同样是请求链接，就可以返回一个 json 数据，里面就有我们所需要的数据，如果还需要用户信息的数据，可以继续跟着官方的步骤继续往下做，但是我们这里只需要一个 openid，所以就到这一步。\n\n在这一步中，我们请求该链接，然后用`authUtil`工具里来解析，将其返回的数据转换为 json 数据，以方便我们的提取使用，转换为 json 数据之后，只要从中通过 `key` 取出来即可。\n\n此处首先会判断用户的 openid 是否存在，如果存在就弹出提示，不执行以下的操作，否则在查出用户的openid 之后，即可绑定到数据库，弹出提示信息。\n\n以下是此处用到的 authUtil 工具类\n```java\n@Component\npublic class AuthUtil {\n\n    public static final String APPID = \"wx45c1428e5584fcdb\";\n    public static final String APPSECRET = \"98174450eb706ada330f37e646be85d5\";\n\n    public JSONObject doGetJson(String url) throws ClientProtocolException, IOException {\n        JSONObject jsonObject = null;\n        //首先初始化HttpClient对象\n        DefaultHttpClient client = new DefaultHttpClient();\n        //通过get方式进行提交\n        HttpGet httpGet = new HttpGet(url);\n        //通过HTTPclient的execute方法进行发送请求\n        HttpResponse response = client.execute(httpGet);\n        //从response里面拿自己想要的结果\n        HttpEntity entity = response.getEntity();\n        if(entity != null){\n            String result = EntityUtils.toString(entity,\"UTF-8\");\n            // jsonObject = JSONObject.fromObject(result);\n            jsonObject= JSON.parseObject(result);\n        }\n        //把链接释放掉\n        httpGet.releaseConnection();\n        return jsonObject;\n    }\n}\n```\n\n## 5、前端请求后端接口\n\n我们需要一个能看得过去，能让用户输入账号密码的前端界面，所以以下是我们 vue 的代码\n```vue\n<template>\n  <div class=\"login\">\n    <div class=\"form-login\">\n      <el-form ref=\"form\" :model=\"data.form\" >\n        <el-form-item label=\"账户\">\n          <el-input v-model=\"data.form.name\" class=\"input-login\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"密码\">\n          <el-input v-model=\"data.form.pass\" type=\"password\" class=\"input-login\"></el-input>\n        </el-form-item>\n        <el-button type=\"primary\"  @click=\"Wechatlogin\">微信授权</el-button>\n      </el-form>\n    </div>\n  </div>\n</template>\n\n<script>\nimport {getCurrentInstance, reactive} from \"vue\";\nimport qs from \"qs\";\nimport router from \"../../router\";\nimport { ElLoading } from 'element-plus'\n\nexport default {\n  name: \"Wechar\",\n  setup(){\n    const {proxy}=getCurrentInstance();\n    const qs=require('qs');\n    const data=reactive({\n      form: {\n        name: '',\n        pass: '',\n      },\n    })\n    const Wechatlogin = () => {\n      const loading = ElLoading.service({\n        lock: true,\n        text: 'Loading',\n        background: 'rgba(0, 0, 0, 0.7)',\n      })\n      proxy.$axios.post('user/login',qs.stringify({ \"userId\":data.form.name,\"userPass\":data.form.pass })).then(res=>{\n        if (\"允许登录\"==res.data){\n          window.location.href=\"http://10.33.73.62:8089/wechat/oauth?id=\"+data.form.name\n          loading.close()\n        }else{\n          loading.close()\n          alert(res.data);\n        }\n      });\n\n    }\n    return{\n      data,Wechatlogin,\n    }\n  }\n}\n</script>\n```\n\n这里点击授权的按钮之后，首先会判断用户是否存在以及密码是否正确，然后就去调用后端的接口。\n\n{% note warning:: 注意此处有一个坑：\n可以看到我这里`window.location.href=\"http://10.33.73.62:8089/wechat/oauth?id=\"+data.form.name`使用的是`window.location.href`请求后端接口。\n这里是不能用`axios`进行请求的，会出现跨域异常（跨域到微信的服务器）。\n算是一个逼坑指南。 %}\n\n\n## 6、完整流程\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209115733.png)\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209115941.png)\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120057.png)\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120115.png)\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211209120147.png)\t\t","tags":["java","SpringBoot","Vue"],"categories":["java","SpringBoot","前端","Vue"]},{"title":"json—lib依赖无法下载问题","url":"/2021/12/08/2021-12-08-json—lib依赖无法下载问题/","content":"\n# json-lib依赖无法下载问题\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- Maven源：阿里云\n\n## 2、问题\n\n昨天在研究微信验证时，需要用到 `JSONObject.fromObject(result);` 这个方法，所以需要引入 `json-lib` 的依赖，引入依赖很简单，本以为复制黏贴就可以了，但是不知道为什么阿里云的 maven 仓库却死活无法找到这个依赖的包。后面通过手动引入的方式解决。\n\n## 3、解决\n### 3.1、引入的依赖\n```xml\n<!-- https://mvnrepository.com/artifact/net.sf.json-lib/json-lib -->\n<dependency>\n    <groupId>net.sf.json-lib</groupId>\n    <artifactId>json-lib</artifactId>\n    <version>2.4</version>\n</dependency>\n```\n\n### 3.2、报错\n\n此时直接进行下载会提示找不到依赖的相关内容\n\n### 3.3、解决方法一\n\n翻阅了网上的说法，说是在依赖后面加上一句：`<classifier>jdk15</classifier>` ，因为远程提供了两个包，我试了一下在我这里并不管用。\n所以，此方法基本放弃。\n\n### 3.4、解决方法二\n\n另一个方法，就是去[MAVEN存储库](https://mvnrepository.com/)直接下载jar包，\n但是在我打开网站的时候，点击 jar 包进行下载，却发现，这里的也无法下载了\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208141505.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208141543.png)\n\n所以基本上可以判断不是我们自己的问题了。\n\n偶然之间，我发现这个依赖竟然有一个官网：[JSON-lib](http://json-lib.sourceforge.net/)\n\n进去看看![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142229.png)\n官网里应该有 jar 包的下载链接\n果然，点击下面这个按钮就可以正常下载了\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142313.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208142413.png)\n\n**下载完成之后就可以进行手动的导入了**\n我这里选择的是将我们手动下载的 jar 包，放在 maven 本地仓库的相应位置\n首先，我们需要将后面的 `jdk15` 去掉，因为我们的依赖里是没有的。\n\n然后根据自己的本地仓库位置，找到 json-lib的本地仓库\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208143118.png)\n点击进入 2.4 文件夹,将我们更名之后的 jar 包放到其中\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211208143204.png)\n最后记得把带有 `last` 的文件删掉\n\n最后到 java 项目中重新载入一下 maven 就可以了。\n\n\n\n## 4、结束\n\n`json-lib` 相当于 `jackson,fastjson`这样的 jar 来说，效率不高，所以建议使用后者。\n\n`json-lib`中的 `JSONObject.fromObject(result)` 方法可用\n`fastjson`中的`JSON.parseObject(result);`进行替代\n\n","tags":["java","maven"],"categories":["java","maven"]},{"title":"回顾SSM框架整合","url":"/2021/11/30/2021-11-30-回顾SSM框架整合/","content":"\n# 回顾SSM框架整合\n\n## 1、环境\n- jdk 1.8.0_271\n- Maven 3.6.1\n- mySQL 8.0\n- Tomcat 9.0.27\n\n## 2、创建数据库\n首先创建一个测试用的数据库 books：\n```sql\ncreate table books\n(\n    bid     int     not null primary key,\n    sname   varchar(255) null,\n    bname   varchar(255) null,\n    bauthor varchar(255) null,\n    bhome   varchar(255) null\n);\n```\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130132921.png)\n\n## 3、创建项目\n现在创建一个普通的 Maven 项目，并引入所需要的依赖\n```xml\n\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <spring.version>5.2.3.RELEASE</spring.version>\n    </properties>\n    \n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.3</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.3.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.zaxxer</groupId>\n            <artifactId>HikariCP</artifactId>\n            <version>3.4.5</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>${spring.version}</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.11</version>\n        </dependency>\n        <dependency>\n            <groupId>com.mchange</groupId>\n            <artifactId>c3p0</artifactId>\n            <version>0.9.5.2</version>\n        </dependency>\n    </dependencies>\n```\n\n## 4、设置资源过滤\n在 pom.xm 中插入资源过滤的代码\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.xml</include>\n                <include>**/*.properties</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.xml</include>\n                <include>**/*.properties</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n## 5、添加 web 框架支持\n给我们创建的普通项目添加上框架支持，在项目名上右键，即可添加框架支持。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130133853.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130134459.png)\n\n## 5、创建 spring 配置文件\n在刚刚项目的 resources 下面创建配置文件 db.properties ，其中写的是数据库的相关配置\n```properties\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF8&userSSL=true&serverTimezone=GMT\njdbc.username=chenyicai\njdbc.password=cyc1234\n```\n\n以及创建 applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!--    使用连接池，开源的连接池-->\n    <!--    阿里：druid-->\n    <!--    c3p0-->\n    <!--    hiraki：springboot默认使用的连接池-->\n    <!--    一个应用最大并发如果有500个，那么为了提高查询效率，预先创建500个连接，并且把500个连接放入连接池（容器）-->\n\n    <!-- 控制器类的创建交给SpringMVC，不能配置在bean容器中 -->\n    <context:component-scan base-package=\"com.chen\"></context:component-scan>\n\n    <context:property-placeholder location=\"classpath:db.properties\"></context:property-placeholder>\n\n    <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n        <property name=\"driverClass\" value=\"${jdbc.driver}\"></property>\n        <property name=\"jdbcUrl\" value=\"${jdbc.url}\"></property>\n        <property name=\"user\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n\n        <!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3 -->\n        <property name=\"initialPoolSize\" value=\"15\"></property>\n\n        <!--最大空闲时间，60秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 -->\n        <property name=\"maxIdleTime\" value=\"0\"></property>\n\n        <!--连接池中保留的最大连接数。默认值: 15 -->\n        <property name=\"maxPoolSize\" value=\"100\"></property>\n\n        <!-- 连接池中保留的最小连接数，默认为：3 -->\n        <property name=\"minPoolSize\" value=\"10\"></property>\n\n        <!--c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值:\n            0 -->\n        <property name=\"maxStatements\" value=\"200\"></property>\n\n        <!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认:\n            0 -->\n        <property name=\"checkoutTimeout\" value=\"3000\" />\n\n        <!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 -->\n        <property name=\"acquireIncrement\" value=\"2\" />\n\n        <!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次 -->\n        <property name=\"acquireRetryAttempts\" value=\"0\" />\n\n        <!--重新尝试的时间间隔，默认为：1000毫秒 -->\n        <property name=\"acquireRetryDelay\" value=\"5000\" />\n\n        <!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 -->\n        <property name=\"autoCommitOnClose\" value=\"false\"></property>\n\n        <!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值:\n            null -->\n        <property name=\"automaticTestTable\" value=\"Test\"></property>\n\n        <!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认:\n            false -->\n        <property name=\"breakAfterAcquireFailure\" value=\"false\"></property>\n\n        <!--每60秒检查所有连接池中的空闲连接。默认值: 0，不检查 -->\n        <property name=\"idleConnectionTestPeriod\" value=\"0\"></property>\n\n        <!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 -->\n        <property name=\"maxStatementsPerConnection\" value=\"10\"></property>\n    </bean>\n\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.chen.entity\"></property>\n        \n    </bean>\n</beans>\n```\n\n## 6、编写代码主体\n现在来编写代码中 entity，controller，service，mapper 层的代码\n**entity：books**\n```java\npublic class Books implements Serializable {\n    private Integer bid;\n\n    private String sname;\n\n    private String bname;\n\n    private String bauthor;\n\n    private String bhome;\n\n    private static final long serialVersionUID = 1L;\n    \n}\n```\n\n**mapper（此处演示的是传统的 DAO 的方式）:booksDao：**\n```java\npublic interface BooksDao {\n    int deleteByPrimaryKey(Integer bid);\n\n    int insert(Books record);\n\n    int insertSelective(Books record);\n\n    Books selectByPrimaryKey(Integer bid);\n\n    int updateByPrimaryKeySelective(Books record);\n\n    int updateByPrimaryKey(Books record);\n}\n```\n**booksDaoImpl：**\n```java\n@Repository\npublic class BooksDaoImpl implements BooksDao {\n\n    private SqlSessionFactory sqlSessionFactory;\n\n    public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) {\n        this.sqlSessionFactory = sqlSessionFactory;\n    }\n\n    @Override\n    public int deleteByPrimaryKey(Integer bid) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out=sqlSession.delete(\"deleteByPrimaryKey\",bid);\n        return out;\n    }\n\n    @Override\n    public int insert(Books record) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out=sqlSession.insert(\"insert\",record);\n        return out;\n    }\n\n    @Override\n    public Books selectByPrimaryKey(Integer bid) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        Books books=sqlSession.selectOne(\"selectByPrimaryKey\",bid);\n        return books;\n    }\n\n    @Override\n    public int updateByPrimaryKey(Books record) {\n        SqlSession sqlSession=sqlSessionFactory.openSession();\n        int out = sqlSession.update(\"updateByPrimaryKey\",record);\n        return out;\n    }\n}\n```\n\n**然后是 xml 文件，其中是执行的 sql：**\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org/DTD Mapper 3.0\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"user\">\n    <select id=\"selectByPrimaryKey\" parameterType=\"int\" resultType=\"com.chen.entity.Books\">\n        select\n        *\n        from books\n        where bid = #{bid,jdbcType=INTEGER}\n    </select>\n\n    <delete id=\"deleteByPrimaryKey\" parameterType=\"int\">\n        delete from books\n        where bid = #{bid,jdbcType=INTEGER}\n    </delete>\n\n    <insert id=\"insert\" parameterType=\"com.chen.entity.Books\" useGeneratedKeys=\"true\">\n        insert into books (sname, bname, bauthor,\n                           bhome)\n        values (#{sname,jdbcType=VARCHAR}, #{bname,jdbcType=VARCHAR}, #{bauthor,jdbcType=VARCHAR},\n                #{bhome,jdbcType=VARCHAR})\n    </insert>\n\n    <update id=\"updateByPrimaryKey\" parameterType=\"com.chen.entity.Books\">\n        update books\n        set sname = #{sname,jdbcType=VARCHAR},\n            bname = #{bname,jdbcType=VARCHAR},\n            bauthor = #{bauthor,jdbcType=VARCHAR},\n            bhome = #{bhome,jdbcType=VARCHAR}\n        where bid = #{bid,jdbcType=INTEGER}\n    </update>\n</mapper>\n```\n\n**service 层：BooksService**\n```java\npublic interface BooksService {\n    int deleteByPrimaryKey(Integer bid);\n\n    int insert(Books record);\n\n    Books selectByPrimaryKey(Integer bid);\n\n    int updateByPrimaryKey(Books record);\n}\n```\n**impl：**\n```java\npublic class BooksServiceImpl implements BooksService {\n\n    @Autowired\n    private BooksDao booksDao;\n\n    @Override\n    public int deleteByPrimaryKey(Integer bid) {\n        return booksDao.deleteByPrimaryKey(bid);\n    }\n\n    @Override\n    public int insert(Books record) {\n        return booksDao.insert(record);\n    }\n\n    @Override\n    public Books selectByPrimaryKey(Integer bid) {\n        return booksDao.selectByPrimaryKey(bid);\n    }\n\n    @Override\n    public int updateByPrimaryKey(Books record) {\n        return booksDao.updateByPrimaryKey(record);\n    }\n}\n```\n\n**最后是 Controller 层：BooksController**\n```java\n@RestController\npublic class BooksController {\n\n    @Autowired\n    private BooksService booksService;\n\n    public void setBooksService(BooksService booksService) {\n        this.booksService = booksService;\n    }\n\n    @RequestMapping(\"/del\")\n    int deleteByPrimaryKey(Integer bid){\n        return booksService.deleteByPrimaryKey(bid);\n    }\n\n    @RequestMapping(\"/ins\")\n    int insert(Books record){\n        return booksService.insert(record);\n    }\n\n    @RequestMapping(\"/sel\")\n    Books selectByPrimaryKey(Integer bid){\n        return booksService.selectByPrimaryKey(bid);\n    }\n\n    @RequestMapping(\"/up\")\n    int updateByPrimaryKey(Books record){\n        return booksService.updateByPrimaryKey(record);\n    }\n}\n```\n\n最后项目的结构如下：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130145929.png)\n\n## 7、现在需要在配置 xml 中编写扫描我们的 bean 的代码\n\n加入以下代码：\n```xml\n    <bean id=\"userDao\" class=\"com.chen.mapper.impl.BooksDaoImpl\">\n        <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    </bean>\n\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.chen.entity\"></property>\n        <property name=\"mapperLocations\" value=\"classpath*:mapper/BooksMapper.xml\"></property>\n    </bean>\n```\n如图：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130150442.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130150809.png)\n\n## 8、web 配置\n在 web.xml 中配置以下内容,用于配置dispatcherServlet中心控制器\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <display-name>Archetype Created Web Application</display-name>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:applicationContext.xml</param-value>\n    </context-param>\n    <!-- 监听器会自动读取applicationContext.xml中的bean的信息，完成bean的初始化-->\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class><!-- 前端控制器 -->\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>/</url-pattern><!-- 处理所有请求，当然也包含静态资源（js、css、img...） -->\n    </servlet-mapping>\n</web-app>\n```\n\n在创建一个 dispatcher-servlet.xml，用于 MVC 的装配\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 扫描控制器的包，以确定哪些类是控制器类（哪些类上使用了@Controller注解） -->\n    <context:component-scan base-package=\"cn.edu.guet.controller\"></context:component-scan>\n\n    <!-- 表示：所有的静态资源使用默认的Servlet -->\n    <mvc:default-servlet-handler></mvc:default-servlet-handler>\n\n    <mvc:annotation-driven></mvc:annotation-driven>\n\n\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"></property><!-- 告诉SpringMVC去哪个目录找文件 -->\n        <property name=\"suffix\" value=\".jsp\"></property><!-- 文件的后缀 -->\n    </bean>\n    <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>\n    <!--通过处理器适配器AnnotationMethodHandlerAdapter来开启支持@RequestMapping注解-->\n\n</beans>\n```\n\n## 9、运行测试\n此时我们用 Tomcat 构建项目。\n出现以下结果：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130172158.png)\n\n如果出现这种情况，我们就需要将 maven 的包手动导入，才能成功启动项目。\n步骤如下：\n1. 打开项目结构。\n2. 点击构件，然后点击WEB-INF目录，点击新建文件夹按钮，创建lib文件夹。\n3. 然后引入库。\n4. 将其全选，然后需要的jar包便全部导入到项目中。\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211130173210.png)\n\n**再运行，即可**","tags":["java","spring"],"categories":["java","spring"]},{"title":"eCharts学习笔记","url":"/2021/11/27/2021-11-27-eCharts学习笔记/","content":"\n# eCharts 学习笔记\n\n## 1、简介\neCharts 是百度出品的一款基于 JavaScript 的数据可视化图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表。最开始是由百度团队开源的，后面于2018年交由Apache基金会，称为ASF孵化项目。并于2021年1月26日正式毕业。\n\n## 2、在 Vue 中使用\n1. 首先下载 eCharts：\n```shell\nnpm install echarts --save\n```\n2. 全局引入 eCharts:\n```js\nimport * as echarts from 'echarts';\n```\n3. 或者可以按需引入\n```js\n// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。\nimport * as echarts from 'echarts/core';\n// 引入柱状图图表，图表后缀都为 Chart\nimport { BarChart } from 'echarts/charts';\n// 引入提示框，标题，直角坐标系，数据集，内置数据转换器组件，组件后缀都为 Component\nimport {\n  TitleComponent,\n  TooltipComponent,\n  GridComponent,\n  DatasetComponent,\n  DatasetComponentOption,\n  TransformComponent\n} from 'echarts/components';\n// 标签自动布局，全局过渡动画等特性\nimport { LabelLayout, UniversalTransition } from 'echarts/features';\n// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步\nimport { CanvasRenderer } from 'echarts/renderers';\n\n// 注册必须的组件\necharts.use([\n  TitleComponent,\n  TooltipComponent,\n  GridComponent,\n  DatasetComponent,\n  TransformComponent,\n  BarChart,\n  LabelLayout,\n  UniversalTransition,\n  CanvasRenderer\n]);\n```\n## 3、基本语法结构\n\n在使用 eCharts 之前，我们需要给它一个 DOM 容器，官方是推荐我们使用具有定义好的长和宽的一个父容器（可以是 div ）。\n所以我们首先构建一个父容器 div 来存放 eCharts 图表\n```html\n<div id=\"billreport\"\n    :style=\"{ width: '95%', height: '500px' }\"></div>\n```\n\n由于 eCharts 基于js构建的，所以只要会js的语法，eCharts的语法自然也不在话下。\n而 eCharts 的基本语法结构为：\n```js\nsetup(){\nconst data=reactive({\n    option:{\n    \t//图表信息\n    }\n})\n\nconst ech = () => {\n\t//绘制图表的方法\n\t}\n}\n\nonBeforeMount(()=>{\n\t//在页面渲染之前加载图表的信息\n})\n```\n\n## 4、图表配置信息\n图表配置信息，即 option 中的内容，在这一部分，我们将配置一系列的信息，正是这些信息生成了对应的图表。\n```js\noption:{\n\ttitle:{\n\t\ttext: \"收入与支出趋势图\"//图表的标题\n\t},\n\ttooltip:{//提示的信息\n\t\ttrigger:'axis'//触发方式\n\t},\n    legend: {//图例\n        data: [{\n        \tname: '收入',\n        \t// 强制设置图形为圆。\n        \ticon: 'circle',\n        \t// 设置文本为红色\n        \ttextStyle: {\n            \tcolor: 'red'\n        \t}\n    \t},\n              {\n        \tname: '支出',\n        \t// 强制设置图形为圆。\n        \ticon: 'circle',\n        \t// 设置文本为红色\n        \ttextStyle: {\n            \tcolor: 'red'\n        \t}\n    \t}]//图例的标题，分别对应 series 中的数据\n    }，\n    xAxis: {//配置要在x轴显示的项\n        type: 'category',//'value' 数值轴，适用于连续数据。 'category' 类目轴，适用于离散的类目数据，为该类型时必须通过 data 设置类目数据。 'time' 时间轴，适用于连续的时序数据，与数值轴相比时间轴带有时间的格式化，在刻度计算上也有所不同，例如会根据跨度的范围来决定使用月，星期，日还是小时范围的刻度。 'log' 对数轴。适用于对数数据。\n        boundaryGap: false,// 刻度离纵轴有无间隙，默认true有间距\n        data: []//横轴坐标的值\n    },\n    yAxis: {//配置y轴的项，配置与x轴类似\n        type: 'value'\n    },\n    series: [//系列列表,显示在图表中的内容\n      {\n        name: '收入',//系列名称\n        type: 'line',//图表类型\n        stack: '收入',//堆叠，如果有相同名称的会堆叠\n        data: []\n      },\n      {\n        name: '支出',\n        type: 'line',\n        stack: '支出',\n        data: []\n      }\n   ]\n}\n```\n\n图表类型表：\n\n| 配置                  | 图表类型                       |\n| --------------------- | ------------------------------ |\n| type: 'bar'           | 柱状/条形图                    |\n| type: 'line'          | 折线/面积图                    |\n| type: 'pie'           | 饼图                           |\n| type: 'scatter'       | 散点（气泡）图                 |\n| type: 'effectScatter' | 带有涟漪特效动画的散点（气泡） |\n| type: 'radar'         | 雷达图                         |\n| type: 'tree'          | 树型图                         |\n| type: 'treemap'       | 树型图                         |\n| type: 'sunburst'      | 旭日图                         |\n| type: 'boxplot'       | 箱形图                         |\n| type: 'candlestick'   | K线图                          |\n| type: 'heatmap'       | 热力图                         |\n| type: 'map'           | 地图                           |\n| type: 'parallel'      | 平行坐标系的系列               |\n| type: 'lines'         | 线图                           |\n| type: 'graph'         | 关系图                         |\n| type: 'sankey'        | 桑基图                         |\n| type: 'funnel'        | 漏斗图                         |\n| type: 'gauge'         | 仪表盘                         |\n| type: 'pictorialBar'  | 象形柱图                       |\n| type: 'themeRiver'    | 主题河流                       |\n| type: 'custom'        | 自定义系列                     |\n\n## 5、x 轴、y 轴\n\nx 轴和 y 轴都由轴线、刻度、刻度标签、轴标题四个部分组成。\n一般情况下，二维的图标结构都会有 x 轴和 y 轴，通常情况下，x 轴会在图表的下方，而 y 轴在图表的左边。\n而 eCharts 也提供了一些特定的坐标轴的设置选项，如：\n**轴线：**\n我们可以通过 axisLine 来对轴线进行设置，比如轴线两头的箭头，轴线的样式等等，比如：\n```js\noption = {\n  xAxis: {\n    axisLine: {\n      show:'true' //显示轴线\n      symbol: 'arrow', //轴线两边的箭头\n      lineStyle: { //轴线的样式，有颜色、宽度、类型等等\n        type: 'dashed'\n        // ...\n      }\n    }\n    // ...\n  },\n  yAxis: {\n    axisLine: {\n      symbol: 'arrow',\n      lineStyle: {\n        type: 'dashed'\n        // ...\n      }\n    }\n  }\n  // ...\n};\n```\n轴线两边的箭头选项：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129165935.png)\n\n**坐标轴刻度：**\nECharts 提供了轴线 axisTick 相关的配置，我们可以根据实际情况调整，例如刻度线的长度，样式等。以下是一个坐标轴刻度的例子：\n```js\noption = {\n  xAxis: {\n    axisTick: {\n      show:true //开启坐标轴刻度\n      alignWithLabel:true //使刻度与标签对其（类目轴中在 boundaryGap 为 true 的时候有效）\n      inside:true //刻度线是否朝里（true为朝里）\n      interval：0 //坐标轴刻度的显示间隔,如果设置为 1，表示『隔一个标签显示一个标签』，如果值为 2，表示隔两个标签显示一个标签，以此类推。\n      length: 6,//刻度线的长度\n      lineStyle: { //样式设置\n        type: 'dashed'\n        // ...\n      }\n    }\n    // ...\n  },\n  yAxis: {\n    axisTick: {\n      length: 6,\n      lineStyle: {\n        type: 'dashed'\n        // ...\n      }\n    }\n  }\n  // ...\n};\n```\n\n**刻度标签：**\nECharts 提供了轴线 axisLabel 相关的配置，我们可以根据实际情况调整。以下是一个例子：\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129171709.png)\n如上图所示，下面的星期就是刻度标签\n```js\noption = {\n  xAxis: {\n    axisLabel: {\n      show:true //显示刻度标签\n      interval:0 //显示刻度，同上\n      inside:true //标签是否朝里（true朝里）\n      rotate：45 // 标签偏移的角度\n      margin:5 //标签与轴线的距离\n      formatter: '{value} kg', //刻度标签的内容格式器，支持字符串模板和回调函数两种形式。\n      align: 'center' //文字水平对齐方式，默认自动。可选为：'left','center','right'\n      // ...\n    }\n    // ...\n  },\n  yAxis: {\n    axisLabel: {\n      formatter: '{value} 元',\n      align: 'center'\n      // ...\n    }\n  }\n  // ...\n};\n```\n\n**标签中的formatter：**\n```js\n// 使用字符串模板，模板变量为刻度默认标签 {value}\nformatter: '{value} kg'\n// 使用函数模板，函数参数分别为刻度数值（类目），刻度的索引\nformatter: function (value, index) {\n    return value + 'kg';\n}\n```\n更多关于 formatter 的内容可以参考官方的 [API](https://echarts.apache.org/zh/option.html#xAxis.axisLabel.formatter)\n\n## 6、主题配置\n\n在eCharts的内部，内置了两套主题，分别是亮色主题以及暗色主题\n通过以下的方式，我们可以修改主题\n```js\nvar chart = echarts.init(dom, 'light');\nvar chart = echarts.init(dom, 'dark');\n```\n\n或者我们可以通过eCharts的[主题编辑器](https://echarts.apache.org/zh/theme-builder.html)来创建自己的主题![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211128132725.png)\n\n## 7、数据集（dataset）\ndataset 组件可以用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以基于数据指定数据到视觉的映射。\n\n**写法一：**\n```js\ndataset: {\n    // 提供一份数据。\n    //第一行对应的是 x 轴\n    source: [\n        ['product', '2015', '2016', '2017'],\n        ['Matcha Latte', 43.3, 85.8, 93.7],\n        ['Milk Tea', 83.1, 73.4, 55.1],\n        ['Cheese Cocoa', 86.4, 65.2, 82.5],\n        ['Walnut Brownie', 72.4, 53.9, 39.1]\n    ]\n},\n```\n在 dataset 中管理数据之后，就可以不用在 series 单独进行数据的声明，而是直接在 data 除进行调用\n```js\n// 声明多个柱状图系列，默认情况下，每个系列会自动对应到 dataset 的每一列。\nseries: [\n    {type: 'bar'},\n    {type: 'bar'},\n    {type: 'bar'}\n]\n```\n\n**写法二：**\n```js\ndataset: {\n    // 这里指定了维度名的顺序，从而可以利用默认的维度到坐标轴的映射。\n    // 如果不指定 dimensions，也可以通过指定 series.encode 完成映射，参见后文。\n    dimensions: ['product', '2015', '2016', '2017'],\n        source: [\n            {product: 'Matcha Latte', '2015': 43.3, '2016': 85.8, '2017': 93.7},\n            {product: 'Milk Tea', '2015': 83.1, '2016': 73.4, '2017': 55.1},\n            {product: 'Cheese Cocoa', '2015': 86.4, '2016': 65.2, '2017': 82.5},\n            {product: 'Walnut Brownie', '2015': 72.4, '2016': 53.9, '2017': 39.1}\n        ]\n},\n```\n\n## 8、图例\n图例是图表中对内容区元素的注释、用不同形状、颜色、文字等来标示不同数据列，通过点击对应数据列的标记，可以显示或隐藏该数据列。图例虽然不是图表中的主要信息、却是了解图表信息的钥匙。\n以下是一个例子：\n```js\noption = {\n  legend: {\n    type:'plain' //图例的类型可选值：'scroll'：可滚动翻页的图例。当图例数量较多时可以使用。\n    // Try 'horizontal'\n    orient: 'vertical', //图例列表的布局朝向。可选：'horizontal'水平，'vertical'垂直\n    right: 10, //图例组件离容器右侧的距离。\n    top: 'center' //图例组件离容器上侧的距离。\n  },\n  dataset: {\n    source: [\n      ['product', '2015', '2016', '2017'],\n      ['Matcha Latte', 43.3, 85.8, 93.7],\n      ['Milk Tea', 83.1, 73.4, 55.1],\n      ['Cheese Cocoa', 86.4, 65.2, 82.5],\n      ['Walnut Brownie', 72.4, 53.9, 39.1]\n    ]\n  },\n  xAxis: { type: 'category' },\n  yAxis: {},\n  series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]\n};\n```\n显示内容如下：![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20211129173307.png)\n更多内容参考官方 [API](https://echarts.apache.org/zh/option.html#legend)","tags":["前端","eCharts"],"categories":["前端","eCharts"]},{"title":"SpringSecurity+JWT实现的登录认证","url":"/2021/11/20/2021-11-20-SpringSecurity+JWT实现的登录认证/","content":"\n# SpringSecurity+JWT实现的登录认证\n\n## 1、简介\n\n1. Spring Security\n在 Web 编程开发中，登录安全往往也是很重要的一个部分，而 Spring Security 所做得就是这个工作。在 java 领域，成熟的安全框架解决方案一般有 Apache Shiro、Spring Security 等两种技术选型。Apache Shiro 简单易用也算是一大优势，但其功能还是远不如 Spring Security 强大。后者可以为应用提供声明式的安全访问限制，他提供了一系列的可以由开发者主动配置的 bean ，并利用 Spring IoC和 AOP等功能特性来为应用系统提供声明式的安全访问控制功能，减少了诸多重复工作。\n\n2. JWT\nJWT 的全称是：Json Web Token 。是在网路应用中传递信息的一种基于 json 的开发标准，可用于作为 json 对象在不同系统之间进行安全地信息传输。主要使用场景一般是用来在身份提供者和服务提供者间传递被认证的用户身份信息。\n\n## 2、设计登录认证所用的表\n\n本次登录认证需要用到三个表，分别是用户表，身份表以及用户和身份绑定的表。``\n\n```sql\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for hibernate_sequence\n-- ----------------------------\nDROP TABLE IF EXISTS `hibernate_sequence`;\nCREATE TABLE `hibernate_sequence`  (\n  `next_val` bigint(0) NULL DEFAULT NULL\n) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;\n\n-- ----------------------------\n-- Records of hibernate_sequence\n-- ----------------------------\nINSERT INTO `hibernate_sequence` VALUES (1);\nINSERT INTO `hibernate_sequence` VALUES (1);\n\n-- ----------------------------\n-- Table structure for role\n-- ----------------------------\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role`  (\n  `id` bigint(0) NOT NULL,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of role\n-- ----------------------------\nINSERT INTO `role` VALUES (1, 'ROLE_NORMAL');\nINSERT INTO `role` VALUES (2, 'ROLE_ADMIN');\n\n-- ----------------------------\n-- Table structure for user\n-- ----------------------------\nDROP TABLE IF EXISTS `user`;\nCREATE TABLE `user`  (\n  `id` bigint(0) NOT NULL,\n  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of user\n-- ----------------------------\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles`  (\n  `user_id` bigint(0) NULL DEFAULT NULL,\n  `roles_id` bigint(0) NULL DEFAULT NULL,\n  INDEX `FKj9553ass9uctjrmh0gkqsmv0d`(`roles_id`) USING BTREE,\n  INDEX `FK55itppkw3i07do3h7qoclqd4k`(`user_id`) USING BTREE,\n  CONSTRAINT `FK55itppkw3i07do3h7qoclqd4k` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,\n  CONSTRAINT `FKj9553ass9uctjrmh0gkqsmv0d` FOREIGN KEY (`roles_id`) REFERENCES `role` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES (1, 2);\nINSERT INTO `user_roles` VALUES (1, 1);\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users`  (\n  `id` bigint(0) NOT NULL,\n  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES (1, 'chenyicai', '$2a$10$hZG8XjmuAcuY.izAj0D7wuQIvPDdwdz.y4KcbGPI18Mri1hx1FWA6');\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n![](https://z3.ax1x.com/2021/11/20/IqIxJI.png)\n\n![](https://z3.ax1x.com/2021/11/20/IqoFeg.png)\n\n![](https://z3.ax1x.com/2021/11/20/IqokwQ.png)\n\n## 3、创建新工程并导入依赖及实体类\n\n1. 在创建一个SpringBoot工程之后我们需要引入Security和JWT必须的依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>io.jsonwebtoken</groupId>\n\t<artifactId>jjwt</artifactId>\n\t<version>0.9.0</version>\n</dependency>\n```\n\n2. 在配置文件中配置数据库信息\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/jwtdemo?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true\n    username: chenyicai\n    password: cyc1234\n  ackson:\n    serialization:\n      indent_output: true\nserver:\n  port: 8086\n#日志级别（一般设置为INFO）\nlogging:\n  level:\n    cn:\n      edu:\n        guet:\n          mapper: debug\n  org:\n    springframework:\n      security: info\nmybatis:\n  type-aliases-package: cn.edu.guet.entity\n  mapper-locations: classpath:mapper/*.xml\n```\n3. 创建用户以及身份实体类\n\nUsers类：（省略 getset 方法）\n\n此处所创建的 User 类继承了 Spring Security 的 UserDetails 接口，从而成为了一个符合 Security 安全的用户，即通过继承 UserDetails，即可实现 Security 中相关的安全功能。\n```java\npublic class User implements UserDetails {\n\n    private Long id;\n\n    private String username;\n\n    private String password;\n\n    private List<Role> roles;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        List<GrantedAuthority> authorities = new ArrayList<>();\n        for (Role role : roles) {\n            authorities.add( new SimpleGrantedAuthority( role.getName() ) );\n        }\n        return authorities;\n    }\n    @Override\n    public String getUsername() {\n        return username;\n    }\n\n    @Override\n    public String getPassword() {\n        return password;\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n```\nRole类：（省略 getset 方法）\n```java\npublic class Role {\n\n  private Long id;\n\n  private String name;\n\n}\n```\n\n## 4、JWT工具类\n\n该工具类主要用于对 JWT Token 进行各项操作，比如生成Token、验证Token、刷新Token 等\n```java\n@Component\npublic class JwtTokenUtils implements Serializable {\n    private static final long serialVersionUID = -5625635588908941275L;\n\n    private static final String CLAIM_KEY_USERNAME = \"sub\";\n    private static final String CLAIM_KEY_CREATED = \"created\";\n    private static final String CLAIM_KEY_AUTHORITIES=\"authorities\";\n\n    // 生成token\n    public String generateToken(UserDetails userDetails) {\n        Map<String, Object> claims = new HashMap<>();\n        claims.put( CLAIM_KEY_USERNAME, userDetails.getUsername());\n        claims.put(CLAIM_KEY_CREATED, new Date());\n        return generateToken(claims);\n    }\n\n    // 验证token\n    public boolean validateToken(String token, UserDetails userDetails) {\n        String username = getUserNameFromToken(token);\n        return  !isTokenExpired(token);\n    }\n    // 刷新token\n    public String refreshToken(String token){\n        Claims claims = getClaimsFromToken(token);\n        claims.put(CLAIM_KEY_CREATED,new Date());\n        return generateToken(claims);\n    }\n    // 验证token是否失效\n    public boolean isTokenExpired(String token){\n        Date expireDate = getExpiredDateFromToken(token);\n        return expireDate.before(new Date());\n    }\n    // 从token中获取过期时间\n    public Date getExpiredDateFromToken(String token) {\n        Claims claims = getClaimsFromToken(token);\n        return claims.getExpiration();\n    }\n    // 从token中获取用户名\n    public String getUserNameFromToken(String token){\n        String username;\n        try{\n            Claims claims = getClaimsFromToken(token);\n            username = claims.getSubject();\n        } catch (Exception e) {\n            username = null;\n        }\n        return username;\n    }\n    // 从token中获取荷载\n    private Claims getClaimsFromToken(String token){\n        Claims claims = null;\n        try {\n            claims = Jwts.parser()\n                    .setSigningKey(Const.SECRET)\n                    .parseClaimsJws(token)\n                    .getBody();\n        } catch (Exception e){\n            e.printStackTrace();\n        }\n        return claims;\n    }\n    // 生成过期时间\n    private Date generateExpirationDate() {\n        return new Date(System.currentTimeMillis()+Const.EXPIRATION_TIME*1000);\n    }\n    // 根据荷载生成token\n    String generateToken(Map<String, Object> claims) {\n        return Jwts.builder()\n                .setClaims(claims)\n                .setExpiration(generateExpirationDate())\n                .signWith(SignatureAlgorithm.HS512, Const.SECRET )\n                .compact();\n    }\n}\n```\n\n这里还有一个常量类，存储了JWT的一些常量信息\n```java\npublic class Const {\n\n  // 5天(以毫秒ms计)\n  public static final long EXPIRATION_TIME = 432_000_000;\n  // JWT密码\n  public static final String SECRET = \"CodeSheepSecret\";\n  // Token前缀\n  public static final String TOKEN_PREFIX = \"Bearer\";\n  // 存放Token的Header Key\n  public static final String HEADER_STRING = \"Authorization\";\n}\n\n```\n\n## 5、Token过滤器\n\n用于每次外部对接口请求时的Token处理\n```java\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtils jwtTokenUtil;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\n        // 确认是否能根据key拿到value\n        String authHeader = httpServletRequest.getHeader( Const.HEADER_STRING );\n        if (authHeader == null) {\n            authHeader =Const.TOKEN_PREFIX+\" \"+httpServletRequest.getHeader(\"token\");\n        }\n        // 判断登录用户的token不为空和是Bearer开头的\n        if (authHeader != null && authHeader.startsWith( Const.TOKEN_PREFIX )) {\n            // 取到token\n            final String authToken = authHeader.substring( Const.TOKEN_PREFIX.length() );\n            // 从用户请求携带的token获取用户名，能取到证明token除了时间以外都合法了\n            String username = jwtTokenUtil.getUserNameFromToken(authToken);\n            System.out.println(username);\n            // token 存在用户名但没有认证的\n            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\n                UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);\n                // 根据userDetails验证了token是否有效（验证时间是否过期和当前用户名是否匹配）\n                if (jwtTokenUtil.validateToken(authToken, userDetails)) {\n                    // 我们的token，框架是不认识的，token有效就转化构建 UsernamePasswordAuthenticationToken表示认证通过和进行相关授权\n                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(\n                            userDetails, null, userDetails.getAuthorities());\n                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(\n                            httpServletRequest));\n                    // 设置了认证主体，到UsernamePasswordAuthenticationFilter就不会拦截，因为你应该带有了它的token\n                    SecurityContextHolder.getContext().setAuthentication(authentication);\n                }\n            }\n        }\n        // 继续执行其他过滤器\n        filterChain.doFilter(httpServletRequest, httpServletResponse);\n    }\n}\n```\n\n## 6、Service层业务操作\n\n主要是登录以及注册的业务\n\n首先是AuthService接口：\n```java\npublic interface AuthService {\n    User register( User userToAdd );\n    String login( String username, String password );\n}\n```\n\nAuthServiceImpl实现类：\n```java\n@Service\npublic class AuthServiceImpl implements AuthService {\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private JwtTokenUtil jwtTokenUtil;\n\n    @Autowired\n    private UserRepository userRepository;\n\n    // 登录\n    @Override\n    public String login( String username, String password ) {\n        UsernamePasswordAuthenticationToken upToken = new UsernamePasswordAuthenticationToken( username, password );\n        final Authentication authentication = authenticationManager.authenticate(upToken);\n        SecurityContextHolder.getContext().setAuthentication(authentication);\n        final UserDetails userDetails = userDetailsService.loadUserByUsername( username );\n        final String token = jwtTokenUtil.generateToken(userDetails);\n        return token;\n    }\n\n    // 注册\n    @Override\n    public User register( User userToAdd ) {\n        final String username = userToAdd.getUsername();\n        if( userRepository.findByUsername(username)!=null ) {\n            return null;\n        }\n        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n        final String rawPassword = userToAdd.getPassword();\n        userToAdd.setPassword( encoder.encode(rawPassword) );\n        return userRepository.save(userToAdd);\n    }\n}\n```\n\n然后是 UserService 实现类，它实现了 UserDetailsService，可用于在登录认证时检验用户的身份\n```java\n@Service\npublic class UserService implements UserDetailsService {\n    @Autowired\n    UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        User user = userMapper.findByUsername(s);\n        List<Role> roleList =userMapper.findRoleByUsername(s);\n        user.setRoles(roleList);\n        System.out.println(user.getId());\n        System.out.println(user.getUsername());\n        System.out.println(user.getPassword());\n        System.out.println(user.getAuthorities());\n        System.out.println(user.getRoles());\n        if (user == null) {\n            throw new UsernameNotFoundException(\"用户不存在\");\n        }\n        return user;\n    }\n}\n```\n\n## 7、Spring Security配置类编写\n\n这是比较重要的一点，这里决定了拦截的页面以及其他的一些操作。这是一个高度综合的配置类，主要是通过重写 WebSecurityConfigurerAdapter 的部分 configure 配置，来实现用户自定义的部分。\n```java\n@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(prePostEnabled=true)\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private UserService userService;\n\n    @Bean\n    public JwtFilter authenticationTokenFilterBean() throws Exception {\n        return new JwtFilter();\n    }\n\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    protected void configure( AuthenticationManagerBuilder auth ) throws Exception {\n        auth.userDetailsService( userService ).passwordEncoder( new BCryptPasswordEncoder() );\n    }\n\n    @Override\n    protected void configure( HttpSecurity httpSecurity ) throws Exception {\n        httpSecurity.csrf().disable()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll() // OPTIONS请求全部放行\n                .antMatchers(HttpMethod.POST, \"/authentication/**\").permitAll()  //登录和注册的接口放行，其他接口全部接受验证\n                .antMatchers(HttpMethod.POST).authenticated()\n                .antMatchers(HttpMethod.PUT).authenticated()\n                .antMatchers(HttpMethod.DELETE).authenticated()\n                .antMatchers(HttpMethod.GET).authenticated();\n\n        // 使用前文自定义的 Token过滤器\n        httpSecurity\n                .addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);\n\n        httpSecurity.headers().cacheControl();\n    }\n}\n```\n## 8、接下来编写Controller类进行测试\n\n首先是登陆注册的类：\n```java\n@RestController\npublic class JwtAuthController {\n\n    @Autowired\n    private AuthService authService;\n\n    // 登录\n    @RequestMapping(value = \"/authentication/login\", method = RequestMethod.POST)\n    public String createToken( String username,String password ) throws AuthenticationException {\n        return authService.login( username, password );\n    }\n\n    // 注册\n    @RequestMapping(value = \"/authentication/register\", method = RequestMethod.POST)\n    public User register( @RequestBody User addedUser ) throws AuthenticationException {\n        return authService.register(addedUser);\n    }\n\n}\n```\n\n然后是测试权限的类：\n```java\n@RestController\npublic class TestController {\n\n    // 测试普通权限\n    @PreAuthorize(\"hasAuthority('ROLE_NORMAL')\")\n    @RequestMapping( value=\"/normal/test\", method = RequestMethod.GET )\n    public String test1() {\n        return \"ROLE_NORMAL /normal/test接口调用成功！\";\n    }\n\n    // 测试管理员权限\n    @PreAuthorize(\"hasAuthority('ROLE_ADMIN')\")\n    @RequestMapping( value = \"/admin/test\", method = RequestMethod.GET )\n    public String test2() {\n        return \"ROLE_ADMIN /admin/test接口调用成功！\";\n    }\n}\n```\n\n## 9、现在我们进行测试\n\n1. 首先测试能否正常登录并获取到Token![](https://z3.ax1x.com/2021/11/20/IqbGDK.png)\n可以看到在账号密码正确的情况下，能返回一个Token，接下来只要访问网页时带上这个Token，就可以顺利进行访问\n\n2. 接下来测试能否正常访问网页\n首先是不带Token的情况：\n![](https://z3.ax1x.com/2021/11/20/IqbOPJ.png)\n很明显，被拒绝访问了。\n接下来我们测试一下携带Token的情况：\n![](https://z3.ax1x.com/2021/11/20/IqxMd0.png)\n可以成功访问。\n\n","tags":["SpringSecurity","JWT"],"categories":["java","权限管理","SpringSecurity","JWT"]},{"title":"我们还有必要深入学习jQuery吗","url":"/2021/11/17/2021-11-17-我们还有必要深入学习jQuery吗/","content":"\n# 我们还有必要深入学习 jQuery 吗\n\n## 表达想法\n\n前几天在某个视频平台看到一个博主的视频，该博主对于『 我们还有必要深入学习 jQuery 吗？』这个问题做出了一个很肯定的答案：就是没有必要。\n\n而他对于这个结论并也不是空穴来风，同样是做出了一系列的解释。比如说：jQuery 已经过时了、Vue.js以及React.js这样的前端框架能更好地实现jQuery所能实现的功能等等。\n\n当然，作为该博主的个人想法，评论区自然是炸开了锅，有人赞同该博主的言论，而也有人对该博主的言论表示不敢苟同。这里我说说我个人的想法：\n\n我认为 jQuery 虽然是一个多年以前的技术，但是他作为学习路上所必须经历的一段经历，我认为还是有必要进行学习的，但是也不用过度深入，在该阶段花费过多的时间。\n\njQuery 的开发模式和 Vue.js 等框架的开发模式是不同的两种开发模式，只有体会到两种开发模式的不同之处，我们才能更深入地理解如今所流行的前端框架所流行的原因，以及 jQuery 落后的原因等等。同样在若干年以后，可能会有更多新的前端框架的出现，替代现在地 vue.js、react.js 等等，到时候，经历过 vue.js 时代的我们，是不是又能从一种新的层面看到多种开发模式地区别呢？我们所了解到的是：为什么是这样子？而不是本来就是这样子。永远保持好奇与探索，对一个开发者来说是极其重要的。\n\n而对于 js ，我认为我们应该重点对原生的js进行学习，毕竟 jQuery，vue，react 这些框架都是在js的基础上进行封装的，所以说我们在使用这些框架的时候，实际上我们还是在使用 js ，但是方便就方便在这些框架的一些优秀的封装类帮我们实现了 js 中很多复杂操作，我们只要按照框架所规定的语法进行编写，就能很方便的实现 js 中一些复杂的操作，这也是为什么框架技术能够如此流行的原因之一。\n\n而我们不能只知道使用，而不知原理，这样子是走不远的，但是这并不表示我们就应该去生啃这些框架的源码，而是说我们应该学好 js 的语法，这样子在我们使用时也能很好地理解框架的原理，在使用的过程中，逐步地理解框架。\n\n## jQuery 有什么优点？\n\n抛开现在流行的 vue 等前端框架不谈，我们来说说 jQuery 时代，他都有哪些有优点。\n\n1. 能很好的操作 DOM\n有这样一个例子，如果我要修改一个元素的样式，我用原生的js是这样子完成地：\n```js\nvar dom=document.getElementById('test')\ndom.style.color='red'\n```\n而我用 jQuery 来替代上面地代码\n```js\n$('#test').css('color','red');\n```\n相对于原生的 js 来说，我们的代码精简了许多，在 jQuery 中我们用`$`来替代了原生 js 中的`document.getElementById`这一行语句，所以代码精简了许多。\n\n2. 极其方便地 ajax 操作\n在jQuery中，如果我们要使用ajax访问后台的数据，我们可以这样子实现：\n```js\n$.ajax({\n\turl:'/index',\n\tsuccess:function(res){\n\t\tconsole.log(\"请求成功\")\n\t}\n})\n```\n而如果我们要在原生的js中使用 ajax ，那别提有多复杂了，我们首先得创建一个异步对象，然后再设置请求的 url 以及参数，然后发送请求，最后我们需要将其注册到一个事件上，才能进行访问。虽然我们也能将其封装成一个可重复使用的方法，但是对于 jQuery 来说，他还是太麻烦了。\n\n3. 更方便的页面动效\n通常我们的界面需要用到一些很有趣的画面，我们在 jQuery 中可以这样子实现：\n```js\n$(\"#test\").animate({left:'100px'})\n```\n\n以上的这些操作，说实话在 js 中我们都可以实现，而 jQuery 作为一个很好的 js 框架，他所封装的很多函数可以大大方便我们的操作，所以这也就是 jQuery 为什么会流行的原因之一。我们自己也能封装一个这样的代码库，只是我们可能不能做到这么优秀，也不一定有时间和精力来做这样的工作。\n\n## MVVM 框架是怎么替代 jQuery 的？\n\n现在的 MVVM 框架，他们都引入了几个新的概念：模块化、组件化。并采用了虚拟 DOM 的方式来替代原来的 DOM 操作，在这些框架中，数据和视图实现了分离，对数据的操作不在需要引用响应的 DOM 对象，达到了编程世界中一个共同的目标——解耦。\n\n1. 针对 DOM 操作\n在 MVVM 框架中，我们基本看不到 DOM 操作的影子，是因为他们采用了一种绑定元素渲染的方式，来绑定我们的视图以及数据。比如说 vue 框架中的`v-model`。\n但是 DOM 操作不可能完全不需要，某些特殊情况还是会用到。\n\n2. 针对 ajax 操作\n在 ajax 操作方面，基本上是被 axios 这样的库给替代了，而且所实现的功能与 ajax 都差不多，而且能更好地契合这些框架。\n\n3. 针对界面动效\nCSS 3已经能很好地实现界面动态地效果。而且有很多优秀的动效库，能完美适配现在流行的框架，并能更好的实现很多好看的动效。\n\n\n## 感想\n\n可能在若干年后地某一天，又会出现更新的比现在更好的框架，那时候又会更加方便我们的使用。而我们同样要顺应时代地潮流，去学习这些新的技术，从入了编程这一行开始，我就深知这是一个需要不断学习知识，更新自己的行业，如果停止学习，就会被高速发展的互联网行业抛弃。所以这是一个很『内卷』的行业，我喜欢这种挑战，也渴望能从这种挑战中获得一个不断进步的自己。","tags":["随笔","前端"],"categories":["随笔","前端"]},{"title":"Service中包含哪些代码","url":"/2021/11/12/2021-11-12-Service中包含哪些代码/","content":"\n# Service中包含哪些代码\n\n## 1、简介\nService层中 = 核心功能(几十行 上百代码) + 额外功能(附加功能)\n1. 核心功能\n   业务运算\n   DAO调用\n2. 额外功能 \n   1. 不属于业务\n   2. 可有可无\n   3. 代码量很小 \n   \n\n以及：事务、日志、性能...\n\nService层，作为程序的业务层面，其中最重要的必然是程序的业务流程，只有对程序的业务流程有足够的了解，才能写出优秀的Service层代码。\n\n不冗余，是一个程序员代码水平的一个体现。\n\n## 2、接口\n为什么要先写接口？\n接口的作用是什么？\n\n这里我引用一句话:\n```\n接口主要用于描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以实现一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。——《Java核心技术卷一》\n```\n这句话所描述的是接口的扩展性。简而言就是：接口是一个统一的插座，如果有需要我们就可以直接进行调用，实现了即插即用。\n\n例如：有一个登录功能需要我们去实现，而该系统又有多种登陆方式，我们不可能每种接口都写一个Service代码给Controller进行调用，这样是十分繁琐的。而我们将多种登陆的方式统一成一个接口，然后根据用户的需求来分配最后实际的实现类。此时对于使用者来说，他们只需要关注的是登陆这个方法，整个登陆操作变得十分灵活，根据不同的场景使用不同的方式登陆。\n\n对于开发者来说，接口中清晰地列出了所有地方法，对于后期的维护以及修改也是有极大的方便。\n\n## 3、Service之间的互相调用\n\nService层之间可以相互调用吗？\n\n这个问题相信很多人都有过思考，理论上来讲是不应该相互进行调用的，因为Service层的存在的一个很重要的目的就是 **解耦** 。\n\n将业务层的每一个业务独立出来，以至于他们之间不相互影响，能够实现代码的优化，否则多种业务的代码混在一起，长久之后谁都看不出来代码的逻辑。所以说Service层就实现了这一个很重要的功能。\n\n所以如果Service层之间的代码相互调用，是不是会是一种倒退呢？\n\n有些人可能会问，有些业务中确实是会使用到其他业务中的代码，那这部分代码怎么办？重新写？那是不可能的，这又犯了冗余这个错误。所以我们该怎么解决呢？\n\n首先，我们要清楚，这个情况是出于Service间有通用的逻辑，而不是通用的业务，每个Service对应一个业务，业务之间应该有明确的分界，不然会出现业务间的耦合，这是设计的不合理。\n\n 既然是通用的逻辑，我们是不是又可以把他们抽象出来，独立成一个工具类，当我们需要的时候直接进行调用这个工具类就可以了呢？\n\n 所以我个人认为Service层之间是不建议相互调用的。\n\n ## 4、需要向Conrtroller层展示业务吗？\n\n当我们实现一个登录功能的时候，Controller层，调用Service层，往往我以前的写法是，Service返回登录成功或者失败的代码，然后Controller进行一个判断，判断是否成功登录，然后再向前端返回信息。这样子的写法有个问题，Controller判断的一个过程，算不算是业务？如果算，是不是Controller层又接触到了业务？\n\n又回到了之前的问题，为什么要有Service层？\n\n所以说，我们应该让Controller层尽可能少的接触到业务，所以我们的写法可以优化为，再Service层做完所有业务相关的工作，最后返回给Controller层的是一个开箱即用的接口，这样子是不是可以避免Controller层接触到业务相关的代码呢？\n这就又符合了我们使用Service层的初衷了。\n\n## 5、最后\n\n在看了一些文章之后，个人的一些小小观点。","tags":["java"],"categories":["java"]},{"title":"算法学习_leetcode设计模块","url":"/2021/10/09/2021-10-09-算法学习_leetcode设计模块/","content":"\n# leetcode设计模块\n\n## 1、子矩形查询\n### 题目\n[lettcode-1476题](https://leetcode-cn.com/problems/subrectangle-queries/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FPlgH.png )\n\n### 解题思路\n按照题目的要求，我们需要根据输入的坐标，拿到该坐标的值。\n以及根据输入的两个坐标和一个值，修改两个坐标之间的值为所给出来的值。\n所以实现这两个功能首先我们需要一个二维数组。拿到坐标的值并不难。\n主要是修改两个坐标之间的值。\n因为输入的两个坐标，假如是`(1,1)`和`(3,4)` ,所以可以看出来纵坐标是修改1和4之间的值，然后横坐标是修改1，3之间的值。所以通过遍历可以遍历第一行的1-4列，第二行的1-4列一直循环下去，最终修改所有的值。\n\n### 具体代码\n```java\nclass SubrectangleQueries {\n    int[][] rectangle;\n\n    public SubrectangleQueries(int[][] rectangle) {\n        this.rectangle=rectangle;\n    }\n\n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for (int i=row1;i<=row2;i++){\n            for (int j=col1;j<=col2;j++){\n                rectangle[i][j]=newValue;\n            }\n        }\n    }\n\n    public int getValue(int row, int col) {\n        return rectangle[row][col];\n    }\n}\n```\n\n## 2、TinyURL 的加密与解密\n\n### 题目\n[lettcode-535题](https://leetcode-cn.com/problems/encode-and-decode-tinyurl/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FkmEq.png)\n\n### 解题思路\n\n为了加密 URL，我们使用计数器 (ii) ，每遇到一个新的 URL 都加一。我们将 URL 与它的次数 ii 放在哈希表 HashMap 中，这样我们在稍后的解密中可以轻易地获得原本的 URL\n\n### 具体代码\n```java\npublic class Codec {\n\n    Map<Integer, String> map = new HashMap<>();\n    int i = 0;\n\n    // Encodes a URL to a shortened URL.\n    public String encode(String longUrl) {\n        map.put(i,longUrl);\n        return \"http://tinyurl.com/\" + i++;\n    }\n\n    // Decodes a shortened URL to its original URL.\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n```\n\n## 3、二叉搜索树迭代器\n\n### 题目\n[lettcode-173题](https://leetcode-cn.com/problems/binary-search-tree-iterator/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5FAJSS.png)\n\n### 解题思路\n\n二叉树，我们可以使用一个TreeNode来实现，其中我们将遍历到的值错放到一个list集合中去。\n二叉树的中序遍历，遍历顺序是：左节点-中节点-右节点。\n所以我们在方法中输入一个二叉树，重复进行遍历，即可得到最后中序遍历的结果。\n\n### 具体代码\n```java\nclass BSTIterator {\n\n    private int index;\n    private List<Integer> arr;\n\n    public BSTIterator(TreeNode root) {\n        index = 0;\n        arr = new ArrayList<Integer>();\n        inorderTraversal(root, arr);\n    }\n\n    public int next() {\n        return arr.get(index++);\n    }\n\n    public boolean hasNext() {\n        return index < arr.size();\n    }\n\n    private void inorderTraversal(TreeNode root, List<Integer> arr) {\n        if (root == null) {\n            return;\n        }\n        //实现中序遍历 左-中-右\n        inorderTraversal(root.left, arr);\n        arr.add(root.val);\n        inorderTraversal(root.right, arr);\n    }\n}\n```\n\n## 4、设计一个支持增量操作的栈\n\n### 题目\n[lettcode-1381题](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/) \n难度：中等![1633055736251]( https://z3.ax1x.com/2021/10/09/5F35b6.png)\n\n### 解题思路\n\n题目要求这个栈需要有一个最大数量，所以我们需要定义一个变量来限制栈的大小。\n如果没有达到最大数量，就将新元素添加到栈的顶端，否则就不允许添加。\n当删除栈中元素的时候，首先删除栈顶端的元素，如果栈中没有东西，就返回一个 -1\n更新栈中的元素的时候首先判断栈中的数量与输入的k的大小关系，如果k大，就将栈中元素数量作为更新的数量，由于index是由0开始的，所以数量就是index+1，否则就是以k作为数量。\n\n### 具体代码\n```java\nclass CustomStack {\n\n\n    int maxSize;\n    int[] myStack=null;\n    int head=-1;\n    public CustomStack(int maxSize) {\n        myStack=new int[maxSize];\n        this.maxSize=maxSize;\n    }\n\n    public void push(int x) {\n        if (head==myStack.length-1){\n            return;\n        }else {\n            myStack[++head]=x;\n        }\n    }\n\n    public int pop() {\n        if (head==-1){\n            return -1;\n        }else{\n            return myStack[head--];\n        }\n    }\n\n    public void increment(int k, int val) {\n        int min;\n        if (head<k){\n            min=head+1;\n        }else{\n            min=k;\n        }\n        for (int i=0;i<min;i++){\n            myStack[i]+=val;\n        }\n    }\n}\n```\n\n## 5、在受污染的二叉树中查找元素\n\n### 题目\n[lettcode-1261题](https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FJsVP.png)\n\n### 解题思路\n\n通过题目我们可以看出，根节点的左子树是2x+1，右子树是2x+2，所以以此类推下去，就能还原出二叉树。\n首先得判断是否有子节点。\n然后如果一个节点没有父子树，就说明他是根节点，就将他设为0\n\n### 具体代码\n\n```java\nclass FindElements {\n\n    Set<Integer> set=new HashSet<>();\n\n    public FindElements(TreeNode root) {\n        rebuildTree(root, null);\n    }\n\n    public boolean find(int target) {\n        // 判断 Set 集合是否包含指定的对象\n        return set.contains(target);\n    }\n    private void rebuildTree(TreeNode root, TreeNode parent) {\n        if (root == null) {\n            return;\n        }\n        // 如果没有父节点，就设为0\n        // 否则就执行下面的条件\n        if (parent == null) {\n            root.val = 0;\n        } else {\n            root.val = root == parent.left ?\n                    (parent.val << 1) + 1 : (parent.val << 1) + 2;\n        }\n        // 将结果添加到set中\n        set.add(root.val);\n        // 重复执行上面的内容\n        rebuildTree(root.left, root);\n        rebuildTree(root.right, root);\n\n    }\n}\n```\n\n## 6、扁平化嵌套列表迭代器\n### 题目\n[lettcode-341题](https://leetcode-cn.com/problems/flatten-nested-list-iterator/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5Faz40.png)\n\n### 解题思路\n\n从题目上看，题目所输入的数据就是一个嵌套的数组，一个数组中可以存放整数，也可以存放一个新的数组。\n而当我们进行遍历时需要先遍历完一个数组，然后再遍历后面的数组，相当于把多个数组中的值给摊开成一个只有整数的数组。\n所以我们在遍历时，将遍历的方法抽成一个独立的方法。如果碰到嵌套数组，我们就再次对遍历的方法进行调用，依次重复多次，就可以实现对多个嵌套数组的遍历。\n\n### 具体代码\n```java\npublic class NestedIterator implements Iterator<Integer> {\n\n    List<Integer> list = new ArrayList<>();\n    int index=0;\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        add(nestedList);\n    }\n\n    private void add(List<NestedInteger> nestedList) {\n        for (NestedInteger nestedInteger : nestedList) {\n            if (nestedInteger.isInteger()) {\n                list.add(nestedInteger.getInteger());\n            } else {\n                //重新遍历嵌套的数组\n                add(nestedInteger.getList());\n            }\n        }\n    }\n\n    @Override\n    public Integer next() {\n        return list.get(index++);\n    }\n\n    @Override\n    public boolean hasNext() {\n        return index<list.size();\n    }\n}\n```\n\n## 7、实现 Trie (前缀树)\n### 题目\n[lettcode-208题](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FBvsU.png)\n\n### 解题思路\n\n前缀树，又叫做字典树。通过阅读题目，这一题我们可以用List数组来实现。\n其中添加元素可以用add方法来实现，而contains方法可以用来判断数组中书否有该元素。\nstartsWith方法即可用用于判断数组中的元素是否包含某一个值。\n\n### 具体代码\n```java\npublic class Trie {\n\n    private List<String> list;\n    private int index = 0;\n\n    public Trie() {\n        list = new ArrayList<>();\n    }\n\n    public void insert(String word) {\n        list.add(word);\n    }\n\n    public boolean search(String word) {\n        if (list.contains(word)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean startsWith(String prefix) {\n        for (String lists:list){\n            if (lists.startsWith(prefix)){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n## 8、皇位继承顺序\n### 题目\n[lettcode-1600题](https://leetcode-cn.com/problems/throne-inheritance/) \n难度：中等![1633055736251](https://z3.ax1x.com/2021/10/09/5FyFWn.png)\n\n### 解题思路\n\n这题一开始读起来有点晦涩难懂，和后面读起来其实就是类似于我国古代的世袭机制。\n首先是皇帝，然后长子次子，但是长子之后的皇帝应该是长子的后代，如果长子没有后代了，皇帝才会传给次子。类似这样子循环下去。\n然后我们需要每个人有一个列表来存储他的后代们。所以可以使用HashMap来实现这一功能。\n然后该Map的键是String类型，值是一个list类型。所以比如说皇帝A，他的A就是键，他的后代就构成了Map的值list。\n死亡人员我们可以用一个Set来实现，因为他是不可重复的，一个人也不可能死很多次，所以我们将死亡的人员放到其中。\n最后是排序。首先判断在set中的人员，将他们删除，然后循环遍历List中的值。首先我们输入皇帝的名字，然后就会遍历皇帝的后代，遍历到皇帝的第一个后代，又会遍历到他的第一个后代的后代，一直到完，就是深度优先遍历。\n所以我们可以将便利的代码抽成一个独立的方法，以供重复进行调用，实现这个功能。\n\n### 具体代码\n```java\npublic class ThroneInheritance {\n\n    private String kingName;\n    private Map<String, List<String>> map = new HashMap<>();\n    //不可重复\n    private Set<String> deathSet = new HashSet<>();\n\n    public ThroneInheritance(String kingName) {\n        this.kingName=kingName;\n        map.put(kingName,new ArrayList<>());\n    }\n\n    public void birth(String parentName, String childName) {\n        map.get(parentName).add(childName);\n        map.put(childName,new ArrayList<>());\n    }   \n\n    public void death(String name) {\n        deathSet.add(name);\n    }\n\n    public List<String> getInheritanceOrder() {\n        List<String> list=new ArrayList<>();\n        add(list,kingName);\n        return list;\n    }\n\n    public void add(List<String> list, String name){\n        if (!deathSet.contains(name)){\n            list.add(name);\n        }\n        //遍历该人物的子孙\n        for (String names:map.get(name)){\n            add(list,names);\n        }\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"RabbitMQ入门使用","url":"/2021/10/06/2021-10-06-RabbitMQ入门使用/","content":"\n# RabbitMQ入门使用\n\n## 1、同步、异步通信\n\n我们服务之间的通信，一般分为同步和异步两种方式。\n\n**同步**就是：当两个服务间通信时，必须要每一步按照顺序进行之后再进行下一步的内容。看上去同步可以立即得到结果，好像很好。但是这样的通信方式往往就会产生一些问题。\n1. 耦合度较高。当我们加入新的需求时，需要修改很多的代码。\n2. 性能不好。因为每次都要等待上一个服务完成，所以会消耗很多时间，导致性能下降.\n3. 资源浪费。在等待服务完成的时候，不能释放资源，也不能做事情，就导致了资源的浪费。\n4. 级联失败。如果服务调用过程中一个环节出现错误，就会导致其他环节跟着出现错误。就像是多米诺骨牌一样。\n\n**异步**就是：当两个服务间通信时，A将资料传给B的时候，就可以继续去做自己的事情，而不用一直等待B传送消息回来，在B有空的时候处理就可以。同时，异步通信解决了一些同步通信存在的问题：`耦合度低`，`吞吐量提升`，`故障隔离` ，`流量削峰`。\n但是同时也带来了一些新的问题：\n1. 依赖于Broker的可靠性、安全性、吞吐能力\n2. 架构复杂了，业务没有明显的流程线，不好追踪管理\n\n所以我们在使用的时候，应该根据实际情况来使用异步或者同步通信。\n\n## 2、消息队列（MQ）简介\n\nMQ （MessageQueue），中文是消息队列，字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。\n\n消息队列中间件是分布式系统中重要的组件，主要解决应用耦合、异步消息、流量削锋等问题。实现高性能、高可用、可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\n### 2.1、常见的MQ\n以下就是四种我们常用的MQ以及它们之间的对比：\n![](https://i.bmp.ovh/imgs/2021/10/6d1e83477fe9a9c8.png)\n\n接下来我们就以RabbitMQ来作为我们学习的工具。\n\n### 2.2、RabbitMQ介绍以及安装\n\nRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/\n\n由于它是基于Erlang语言开发的，所以我们必须安装Erlang语言的开发环境。\n为了省时间，我们这里直接在Dockers里面进行安装并做一个映射。\n步骤如下：\n\n1. 下载RabbitMQ的镜像\n```shell\ndocker pull rabbitmq:3-management\n```\n2. 安装mq\n```shell\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=chenyicai \\\n -e RABBITMQ_DEFAULT_PASS=123456 \\\n --name mq \\\n --hostname mq1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d \\\n rabbitmq:3-management\n```\n然后我们的RabbitMQ就安装完成了，现在我们可以在浏览器输入服务器地址+15672进入RabbitMQ的控制台\n![](https://i.bmp.ovh/imgs/2021/10/d864df3d43bd58c4.png)\n账号密码就是我们前面设置好的`chenyicai`和`123456`\n登录之后：\n![](https://i.bmp.ovh/imgs/2021/10/9079fb7ec4d8d3db.png)\n\n以下是RabbitMQ中的几个基本概念：\n\n- channel：操作MQ的工具\n- exchange：路由消息到队列中\n- queue：缓存消息\n- virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组\n\n## 3、常见的消息模型\n\n### 3.1、官方给出的消息模型\n\n官方一共给出的五个MQ的Demo，分别对应了几种不同的用法：\n1. 基本消息队列（BasicQueue）\n2. 工作消息队列（WorkQueue）\n3. 发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：\n\t1. Fanout Exchange：广播\n\t2. Direct Exchange：路由\n\t3. Topic Exchange：主题\n\n![](https://i.bmp.ovh/imgs/2021/10/6e351b659680b5ee.png)\n![](https://i.bmp.ovh/imgs/2021/10/830978c3cd4ea8dc.png)\n\n### 3.2、Hello World\n\n现在我们就在SpringBoot里面实现以下官方示例中的Hello World这个例子。\n官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：\n1. publisher：消息发布者，将消息发送到队列queue\n2. queue：消息队列，负责接受并缓存消息\n3. consumer：订阅队列，处理队列中的消息\n\n所以我们实现这个例子的步骤如下：\n基本消息队列的消息发送流程：\n1. 建立connection\n```java\nConnectionFactory factory = new ConnectionFactory();\n//设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\nfactory.setHost(\"8.129.212.155\");\nfactory.setPort(5672);\nfactory.setVirtualHost(\"/\");\nfactory.setUsername(\"chenyicai\");\nfactory.setPassword(\"123456\");\n//建立连接\nConnection connection = factory.newConnection();\n```\n2. 创建通道channel\n```java\nChannel channel = connection.createChannel();\n```\n3. 利用channel声明队列\n```java\n//队列名\nString queueName = \"simple.queue\";\n//队列的属性\nchannel.queueDeclare(queueName, false, false, false, null);\n```\n4. 利用channel向队列发送消息\n```java\nString message = \"hello, rabbitmq!\";\nchannel.basicPublish(\"\", queueName, null, message.getBytes());\nSystem.out.println(\"发送消息成功：【\" + message + \"】\");\n```\n\n基本消息队列的消息接收流程：\n1. 建立connection\n2. 创建通道channel\n3. 利用channel声明队列\n4. 定义consumer的消费行为handleDelivery()\n利用channel将消费者与队列绑定\n```java\nchannel.basicConsume(queueName, true, new DefaultConsumer(channel){\n\t@Override\n\tpublic void handleDelivery(String consumerTag, Envelope envelope,\n             AMQP.BasicProperties properties, byte[] body) throws IOException {\n\t// 5.处理消息\n\tString message = new String(body);\n\tSystem.out.println(\"接收到消息：【\" + message + \"】\");\n\t}\t\n});\nSystem.out.println(\"等待接收消息。。。。\");\n```\n\n\n很显然如果每次使用消息队列都这样开关连接，那么是非常不好的一种现象，所以我们接下来就要使用Spring的一个框架，来更好地帮助我们对消息队列进行使用。\n\n##  4、SpringAMQP\n\n### 4.1、什么是SpringAMQP\n\nSpringAmqp的官方地址：https://spring.io/projects/spring-amqp\n![](https://i.bmp.ovh/imgs/2021/10/a347fedc49140107.png)\n\nAMQP：是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。\n\nSpringAMQP：是基于AMQP协议定义的一套API规范，提供了模板来发送和接受消息。包含两部分，其中Spring-AMQP是基础抽象，Spring-rabbit是底层的默认实现。\n\n### 4.2、SpringAMQP实现Hello World\n\nSpring中已经集成了AMQP的依赖，所以我们只需要引入依赖就可以实现自动注入，具体步骤如下：\n1. 引入SpringAMQP的依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n2. 在publisher中编写一个yml配置文件，添加mq连接的信息\n```yaml\nspring:\n  rabbitmq:\n    host: 8.129.212.155 # rabbitMQ的ip地址\n    port: 5672 # 端口\n    username: chenyicai\n    password: 123456\n    virtual-host: /\n```\n3. 在publisher服务中新建一个测试类，编写测试方法发送消息：\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAmqpTest {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSendMessage2SimpleQueue() {\n        String queueName = \"simple.queue\";\n        String message = \"hello, spring amqp!\";\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n```\n如果此时我们没有接受信息，信息就会存在mq的缓存区里面，如下:\n![](https://i.bmp.ovh/imgs/2021/10/7fff7b4306ad9074.png)\n![](https://i.bmp.ovh/imgs/2021/10/77dd30c482f123d4.png)\n4. 在consumer中接受消息（consumer中也要创建连接配置文件）\n```java\n@Component\npublic class SpringRabbitListener {\n\t@RabbitListener(queues = \"simple.queue\")\n    public void listenSimpleQueue(String msg) {\n        System.out.println(\"消费者接收到simple.queue的消息：【\" + msg + \"】\");\n    }\n}\n```\n现在我们就完成了一个Hello World的例子的实现。\n结果如下：\n![](https://i.bmp.ovh/imgs/2021/10/6d5247dea94d40d9.png)\n消息队列是阅后即焚的，是一个不可逆的过程。\n现在我们看看剩下的几个例子。\n\n### 4.3、Work Queue 工作队列\n工作队列，可以提高消息处理速度，避免队列消息堆积\n他的逻辑图如下：\n![](https://i.bmp.ovh/imgs/2021/10/71a3d073f2914be1.png)\n\n现在我们要来实现一个工作队列\n1. 在publisher服务中添加一个测试方法，循环发送50条消息到simple.queue队列\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAmqpTest {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSendMessage2WorkQueue() throws InterruptedException {\n        String queueName = \"simple.queue\";\n        String message = \"hello, message__\";\n        for (int i = 1; i <= 50; i++) {\n            rabbitTemplate.convertAndSend(queueName, message + i);\n            Thread.sleep(20);\n        }\n    }\n}\n```\n2. 在consumer服务中添加一个消费者，也监听simple.queue：\n```java\n@Component\npublic class SpringRabbitListener {\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenWorkQueue1(String msg) throws InterruptedException {\n        System.out.println(\"消费者1接收到消息：【\" + msg + \"】\" + LocalTime.now());\n        Thread.sleep(20);\n    }\n\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenWorkQueue2(String msg) throws InterruptedException {\n        System.err.println(\"消费者2........接收到消息：【\" + msg + \"】\" + LocalTime.now());\n        Thread.sleep(200);\n    }\n}\n```\n3. 然后我们修改yml配置文件，添加以下内容\n```yaml\nspring:\n  rabbitmq:\n    listener:\n      simple:\n        prefetch: 1 #每次只能获取一条消息，处理完成才能获取下一个消息\n```\n4. 然后我们进行测试，结果如下\n![](https://z3.ax1x.com/2021/10/06/5SSH0J.png)\n\n两个消费者就会交替获取信息，而睡眠20毫秒的用户会比睡眠200毫秒的用户获取更多的信息。\n\n### 4.4、发布（ Publish ）、订阅（ Subscribe ）\n\n发布订阅模式与之前案例的区别就是允许将同一消息发送给多个消费者。实现方式是加入了exchange（交换机）。\n常见exchange类型包括：\n\n- Fanout：广播\n- Direct：路由\n- Topic：话题\n\n![](https://z3.ax1x.com/2021/10/06/5SpKBQ.png)\n\n**注意**：exchange负责消息路由，而不是存储，路由失败则消息丢失\n\n#### 4.4.1、发布订阅-Fanout Exchange\n`Fanout Exchange` 会将接收到的消息广播到每一个跟其绑定的queue\n\n具体实现步骤如下：\n1. 在`consumer`服务声明`Exchange`、`Queue`、`Binding`\n在`consumer`服务常见一个类，添加`@Configuration` 注解，并声明`FanoutExchange`、`Queue`和绑定关系对象`Binding`\n```java\n@Configuration\npublic class FanoutConfig {\n    // itcast.fanout\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"itcast.fanout\");\n    }\n\n    // fanout.queue1\n    @Bean\n    public Queue fanoutQueue1(){\n        return new Queue(\"fanout.queue1\");\n    }\n\n    // 绑定队列1到交换机\n    @Bean\n    public Binding fanoutBinding1(Queue fanoutQueue1, FanoutExchange fanoutExchange){\n        return BindingBuilder\n                .bind(fanoutQueue1)\n                .to(fanoutExchange);\n    }\n\n    // fanout.queue2\n    @Bean\n    public Queue fanoutQueue2(){\n        return new Queue(\"fanout.queue2\");\n    }\n\n    // 绑定队列2到交换机\n    @Bean\n    public Binding fanoutBinding2(Queue fanoutQueue2, FanoutExchange fanoutExchange){\n        return BindingBuilder\n                .bind(fanoutQueue2)\n                .to(fanoutExchange);\n    }\n}\n```\n2. 在`consumer`服务的`SpringRabbitListener`类中，添加两个方法，分别监听`fanout.queue1`和`fanout.queue2`\n```java\n@Component\npublic class SpringRabbitListener {\n    @RabbitListener(queues = \"fanout.queue1\")\n    public void listenFanoutQueue1(String msg) {\n        System.out.println(\"消费者接收到fanout.queue1的消息：【\" + msg + \"】\");\n    }\n    @RabbitListener(queues = \"fanout.queue2\")\n    public void listenFanoutQueue2(String msg) {\n        System.out.println(\"消费者接收到fanout.queue2的消息：【\" + msg + \"】\");\n    }\n}\n```\n3. 在`publisher`服务发送消息到`FanoutExchange`\n```java\n\t@Test\n    public void testSendFanoutExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.fanout\";\n        // 消息\n        String message = \"hello, every one!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"\", message);\n    }\n```\n4. 测试，此时两个消费者都会受到这条消息\n![](https://z3.ax1x.com/2021/10/06/5S9Va9.png)\n\n#### 4.4.2、发布订阅-DirectExchange\n\n`Direct Exchange` 会将接收到的消息根据规则路由到指定的`Queue`，因此称为路由模式（routes）。\n\n- 每一个`Queue`都与`Exchange`设置一个`BindingKey`\n- 发布者发送消息时，指定消息的`RoutingKey`\n- `Exchange`将消息路由到`BindingKey`与消息`RoutingKey`一致的队列\n![](https://z3.ax1x.com/2021/10/06/5S9KxK.png)\n\n具体实现步骤如下：\n1. 在`consumer`服务中，编写两个消费者方法，分别监听`direct.queue1`和`direct.queue2`。并利用`@RabbitListener`声明`Exchange`、`Queue`、`RoutingKey`\n\n```java\n\t@RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"direct.queue1\"),\n            exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT),\n            key = {\"red\", \"blue\"}\n    ))\n    public void listenDirectQueue1(String msg){\n        System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"direct.queue2\"),\n            exchange = @Exchange(name = \"itcast.direct\", type = ExchangeTypes.DIRECT),\n            key = {\"red\", \"yellow\"}\n    ))\n    public void listenDirectQueue2(String msg){\n        System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");\n    }\n```\n\n2. 在`publisher`服务发送消息到`DirectExchange`\n```java\n\t@Test\n    public void testSendDirectExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.direct\";\n        // 消息\n        String message = \"hello, red!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"red\", message);\n    }\n```\n\n测试如下：\n![](https://z3.ax1x.com/2021/10/07/5S9Lz6.png)\n两个都能收到`red`的消息，而我们现在换一种发送消息的方式看看，发送一个`blue`的消息，按照规定`direct.queue2`应该是没有消息的。\n![](https://z3.ax1x.com/2021/10/07/5SCkSP.png)\n确实是这个样子。\n\n#### 4.4.3、发布订阅-TopicExchange\n\n`TopicExchange`与`DirectExchange`类似，区别在于`routingKey`必须是多个单词的列表，并且以 `. `分割。\n`Queue`与`Exchange`指定`BindingKey`时可以使用通配符：\n\n- #：代指0个或多个单词\n- *：代指一个单词\n\n![](https://z3.ax1x.com/2021/10/07/5SCQWq.png)\n\n实现步骤如下：\n1. 在`consumer`服务中，编写两个消费者方法，分别监听`topic.queue1`和`topic.queue2`。\n并利用`@RabbitListener`声明`Exchange`、`Queue`、`RoutingKey`\n```java\n\t@RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"topic.queue1\"),\n            exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC),\n            key = \"china.#\"\n    ))\n    public void listenTopicQueue1(String msg){\n        System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue(name = \"topic.queue2\"),\n            exchange = @Exchange(name = \"itcast.topic\", type = ExchangeTypes.TOPIC),\n            key = \"#.news\"\n    ))\n    public void listenTopicQueue2(String msg){\n        System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");\n    }\n```\n2. 在`publisher`服务发送消息到`TopicExchange`\n```java\n\t@Test\n    public void testSendTopicExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.topic\";\n        // 消息\n        String message = \"中国新闻\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);\n    }\n```\n\n进行测试，此时两个消费者都能接收到消息\n![](https://z3.ax1x.com/2021/10/07/5SCc0e.png)\n\n如果修改`key`的值，后面不为`news`时，`topic.queue2`将无法收到消息\n```java\n@Test\n    public void testSendTopicExchange() {\n        // 交换机名称\n        String exchangeName = \"itcast.topic\";\n        // 消息\n        String message = \"中国新闻,一条\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(exchangeName, \"china.new\", message);\n    }\n```\n结果如下：\n![](https://z3.ax1x.com/2021/10/07/5SCI6f.png)\n\n\n\n### 4.5、SpringAMQP-消息转换器\n\n在`SpringAMQP`的发送方法中，接收消息的类型是`Object`，也就是说我们可以发送任意对象类型的消息，`SpringAMQP`会帮我们序列化为字节后发送。\n\n我们在`consumer`中利用`@Bean`声明一个队列：\n```java\n@Configuration\npublic class FanoutConfig {\n    @Bean\n    public Queue objectQueue(){\n        return new Queue(\"object.queue\");\n    }\n}\n```\n在`publisher`中发送消息以测试:\n```java\n\t@Test\n    public void testSendMap() throws InterruptedException {\n        // 准备消息    \n        Map<String,Object> msg = new HashMap<>();    \n        msg.put(\"name\", \"Jack\");    \n        msg.put(\"age\", 21);\n        // 发送消息 \n        rabbitTemplate.convertAndSend(\"object.queue\", msg);\n    }\n```\n会发现在消息队列中我们传过去的是一堆乱码\n![](https://z3.ax1x.com/2021/10/07/5SP6g0.png)\n\n其实就是`java`将我们的消息进行了一个序列化来进行传输，但是这样子十分不具有可读性，而且字符串较长，会影响到传输的效率。\n\n`Spring`的对消息对象的处理是由`org.springframework.amqp.support.converter.MessageConverter`来处理的。而默认实现是`SimpleMessageConverter`，基于`JDK`的`ObjectOutputStream`完成序列化。\n如果要修改只需要定义一个`MessageConverter` 类型的`Bean`即可。推荐用`JSON`方式序列化，步骤如下：\n\n1. 首先我们需要引入json的依赖\n```xml\n<dependency>\n\t<groupId>com.fasterxml.jackson.core</groupId>\n\t<artifactId>jackson-databind</artifactId>\n</dependency>\n```\n2. publisher服务声明MessageConverter（可以放在启动类上）\n```java\n\t@Bean\n    public MessageConverter messageConverter(){\n        return new Jackson2JsonMessageConverter();\n    }\n```\n然后我们进行测试\n![](https://z3.ax1x.com/2021/10/07/5SiFr8.png)\n\n此时显示的消息就很有可读性了。\n\n\n\n## 5、总结\n\n以上就是我对RabbirMQ入门学习的一个总结，还有很多的内容需要去学习，以后学到了会继续补充。s","tags":["java","消息队列"],"categories":["java","消息队列"]},{"title":"Swagger3入门使用","url":"/2021/10/05/2021-10-05-Swagger3入门使用/","content":"\n# Swagger3入门使用\n\n## 1、Swagger3简介\n\nSwagger 是一套基于 OpenAPI 规范（OpenAPI Specification，OAS）构建的开源工具，后来成为了 Open API 标准的主要定义者。\n对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证API 文档的及时性将有很大的帮助。\n\n**swagger2于17年停止维护，现在最新的版本为17年发布的 Swagger3（Open Api3）**\n\n## 2. Swagger3与Swagger2.x比较\n\n- 应用主类添加注解@EnableOpenApi (swagger2是@EnableSwagger2)\n- swagger配置类SwaggerProperties.class，与swagger2.xx 版本有差异，具体看下文\n- 自定义一个配置类 SwaggerConfiguration.class,看下文\n- 访问地址：http://localhost:8080/swagger-ui/index.html (swagger2.xx版本访问的地址为http://localhost:8080/swagger-ui.html)\n\n## 3、SpringBoot整合Swagger3\n\n### 3.1、引入依赖\n```xml\n<dependency>\n\t<groupId>io.springfox</groupId>\n\t<artifactId>springfox-boot-starter</artifactId>\n\t<version>3.0.0</version>\n</dependency>\n```\n\n### 3.2、在Controller类上添加注解\n\nSwagger通过几个注解，就能实现api的添加。\n\n`@Api` ：用在controller类，描述API接口\n`@EnableOpenApi` :表示开启SwaggerApi\n`@ApiOperation` ：描述接口方法\n`@ApiModel` ：描述对象\n`@ApiModelProperty` ：描述对象属性\n`@ApiImplicitParams`  ：描述接口参数\n`@ApiResponses` ：描述接口响应\n`@ApiIgnore` ：忽略接口方法\n`@ApiParam` ：为 Rest 接口参数添加其它元数据\n\n如下所示：\n```java\n@EnableOpenApi // 也可以不写此注解\n@Api(description=\"讲师管理\")\n@RestController\n@RequestMapping(\"/admin/edu/teacher\")\n\npublic class MyController {\n\n    @Autowired\n    private TeacherService teacherService;\n\n    @ApiOperation(value = \"所有讲师列表\")\n    @GetMapping\n    public List<Teacher> list(){\n        return teacherService.list();\n    }\n\n    @ApiOperation(value = \"根据ID删除讲师\")\n    @DeleteMapping(\"{id}\")\n    public boolean removeById(\n            @ApiParam(name = \"id\", value = \"讲师ID\", required = true)\n            @PathVariable String id){\n        return teacherService.removeById(id);\n    }\n\n    @ApiOperation(value = \"查询某个讲师\")\n    @GetMapping(\"/setlct/{id}\")\n    public Teacher teacher(@ApiParam(name = \"id\", value = \"讲师ID\", required = true) @PathVariable String id){\n        return teacherService.teacher(id);\n    }\n}\n```\n\n### 3.3、自定义一个配置类SwaggerProperties.class\n\n```java\n@Component\n@ConfigurationProperties(\"swagger\")\npublic class SwaggerProperties {\n    /**\n     * 是否开启swagger，生产环境一般关闭，所以这里定义一个变量\n     */\n    private Boolean enable;\n    \n    /**\n     * 项目应用名\n     */\n    private String applicationName;\n\n    /**\n     * 项目版本信息\n     */\n    private String applicationVersion;\n\n    /**\n     * 项目描述信息\n     */\n    private String applicationDescription;\n\n    /**\n     * 接口调试地址\n     */\n    private String tryHost;\n\n    public Boolean getEnable() {\n        return enable;\n    }\n\n    public void setEnable(Boolean enable) {\n        this.enable = enable;\n    }\n\n    public String getApplicationName() {\n        return applicationName;\n    }\n\n    public void setApplicationName(String applicationName) {\n        this.applicationName = applicationName;\n    }\n\n    public String getApplicationVersion() {\n        return applicationVersion;\n    }\n\n    public void setApplicationVersion(String applicationVersion) {\n        this.applicationVersion = applicationVersion;\n    }\n\n    public String getApplicationDescription() {\n        return applicationDescription;\n    }\n\n    public void setApplicationDescription(String applicationDescription) {\n        this.applicationDescription = applicationDescription;\n    }\n\n    public String getTryHost() {\n        return tryHost;\n    }\n\n    public void setTryHost(String tryHost) {\n        this.tryHost = tryHost;\n    }\n}\n```\n\n### 3.4、自定义springfox swagger3配置类SwaggerConfiguration.class\n\n```java\nimport io.swagger.models.auth.In;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.springframework.boot.SpringBootVersion;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistration;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.oas.annotations.EnableOpenApi;\nimport springfox.documentation.service.*;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spi.service.contexts.SecurityContext;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport java.lang.reflect.Field;\nimport java.util.*;\n\n@Configuration\npublic class SwaggerConfiguration implements WebMvcConfigurer {\n    private final SwaggerProperties swaggerProperties;\n\n    public SwaggerConfiguration(SwaggerProperties swaggerProperties) {\n        this.swaggerProperties = swaggerProperties;\n    }\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.OAS_30).pathMapping(\"/\")\n\n                // 定义是否开启swagger，false为关闭，可以通过变量控制\n                .enable(swaggerProperties.getEnable())\n\n                // 将api的元信息设置为包含在json ResourceListing响应中。 \n                .apiInfo(apiInfo())\n\n                // 接口调试地址\n                .host(swaggerProperties.getTryHost())\n\n                // 选择哪些接口作为swagger的doc发布\n                .select()\n                .apis(RequestHandlerSelectors.any())\n                .paths(PathSelectors.any())\n                .build()\n\n                // 支持的通讯协议集合\n                .protocols(newHashSet(\"https\", \"http\"))\n\n                // 授权信息设置，必要的header token等认证信息\n                .securitySchemes(securitySchemes())\n\n                // 授权信息全局应用\n                .securityContexts(securityContexts());\n    }\n\n    /**\n     * API 页面上半部分展示信息\n     */\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder().title(swaggerProperties.getApplicationName() + \" Api Doc\")\n                .description(swaggerProperties.getApplicationDescription())\n                .contact(new Contact(\"lighter\", null, \"123456@gmail.com\"))\n                .version(\"Application Version: \" + swaggerProperties.getApplicationVersion() + \", Spring Boot Version: \" + SpringBootVersion.getVersion())\n                .build();\n    }\n\n    /**\n     * 设置授权信息\n     */\n    private List<SecurityScheme> securitySchemes() {\n        ApiKey apiKey = new ApiKey(\"BASE_TOKEN\", \"token\", In.HEADER.toValue());\n        return Collections.singletonList(apiKey);\n    }\n\n    /**\n     * 授权信息全局应用\n     */\n    private List<SecurityContext> securityContexts() {\n        return Collections.singletonList(\n                SecurityContext.builder()\n                        .securityReferences(Collections.singletonList(new SecurityReference(\"BASE_TOKEN\", new AuthorizationScope[]{new AuthorizationScope(\"global\", \"\")})))\n                        .build()\n        );\n    }\n\n    @SafeVarargs\n    private final <T> Set<T> newHashSet(T... ts) {\n        if (ts.length > 0) {\n            return new LinkedHashSet<>(Arrays.asList(ts));\n        }\n        return null;\n    }\n\n    /**\n     * 通用拦截器排除swagger设置，所有拦截器都会自动加swagger相关的资源排除信息\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        try {\n            Field registrationsField = FieldUtils.getField(InterceptorRegistry.class, \"registrations\", true);\n            List<InterceptorRegistration> registrations = (List<InterceptorRegistration>) ReflectionUtils.getField(registrationsField, registry);\n            if (registrations != null) {\n                for (InterceptorRegistration interceptorRegistration : registrations) {\n                    interceptorRegistration\n                            .excludePathPatterns(\"/swagger**/**\")\n                            .excludePathPatterns(\"/webjars/**\")\n                            .excludePathPatterns(\"/v3/**\")\n                            .excludePathPatterns(\"/doc.html\");\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n## 4、测试\n\n完成上述的编写之后可以打开下面的地址查看是否成功创建\n```\nhttp://localhost:8080/swagger-ui/index.html\n```\n\n成功显示如下![](https://z3.ax1x.com/2021/10/05/4jUGVJ.png)\n\n![](https://z3.ax1x.com/2021/10/05/4jUa26.png)","tags":["java","Swagger"],"categories":["java","Swagger"]},{"title":"算法学习_最小栈","url":"/2021/10/04/2021-10-04-算法学习_最小栈/","content":"\n# 最小栈\n\n## 题目\n[lettcode-155题](https://leetcode-cn.com/problems/min-stack/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/874db5e3352e9d73.png )\n\n\n## 解题思路\n题目基本上就是要求找出一个栈中最小的值，通过java中内置的栈的方法即可实现这一目标\n\n首先我的想法是通过遍历比较所有的值来找出最小的那个值，但是这样子消耗了较多的时间，而且题目希望是设计一种栈的结构，而不是直接用栈的方法。\n\n所以后面换了一种新的方法，就是使用链表来实现，这样子的效率是较高的，相比于之前的方法，用时整整少了200多毫秒![](https://i.bmp.ovh/imgs/2021/10/677ed412598a9dc4.png)\n\n具体实现方式如下\n\n\n## 具体代码(第一种思路)\n```java\nclass MinStack {\n\n    Stack<Integer> stack;\n    public MinStack() {\n        stack = new Stack<Integer>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n    }\n\n    public void pop() {\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        int min=stack.get(0);;\n        for (int i=0;i<stack.size();i++){\n            if (stack.get(i)<min){\n                min=stack.get(i);\n            }\n        }\n        return min;\n    }\n}\n\n```\n\n## 具体代码(第二种思路)\n\n```java\nclass MinStack {\n\n    private Node head;\n    \n    public void push(int x) {\n        if(head == null) \n            head = new Node(x, x);\n        else \n            head = new Node(x, Math.min(x, head.min), head);\n    }\n\n    public void pop() {\n        head = head.next;\n    }\n\n    public int top() {\n        return head.val;\n    }\n\n    public int getMin() {\n        return head.min;\n    }\n    \n    private class Node {\n        int val;\n        int min;\n        Node next;\n        \n        private Node(int val, int min) {\n            this(val, min, null);\n        }\n        \n        private Node(int val, int min, Node next) {\n            this.val = val;\n            this.min = min;\n            this.next = next;\n        }\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"算法学习_设计hash集合、hash映射","url":"/2021/10/03/2021-10-03-算法学习_设计hash集合、hash映射/","content":"\n# 设计hash集合、hash映射\n\n## 题目1\n[lettcode-705题](https://leetcode-cn.com/problems/design-hashset/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/40b4bcb17c130bf0.png )\n\n\n## 解题思路\n既然说是一个HashSet，所以他就是一个不可重复的集合，就意味着在该集合中每个元素只能出现一次。\n\n所以说我们就可以用boolean类型的数组来模拟出这样的一个集合\n\n数组的索引就对应了set的key，数组所对应的布尔值就是set的value，当其为true1时就说明存在，否则就是不存在\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass MyHashSet {\n\n    //创建一个boolean类型的数组\n    boolean[] map=null;\n    public MyHashSet() {\n        map=new boolean[1000001];\n    }\n\n    public void add(int key) {\n        map[key]=true;\n    }\n\n    public void remove(int key) {\n        map[key]=false;\n    }\n\n    public boolean contains(int key) {\n        if (map[key]==true){\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n```\n\n## 题目2\n[lettcode-706题](https://leetcode-cn.com/problems/design-hashmap/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/6d0c43c3b85e5903.png )\n\n\n## 解题思路\n从题目中我们可以看出来跟上一题差不多，无非是一个set一个map的差别\n\n阅读题目要求我们可以知道对应的`key`和`value` 都是`int` 类型的，所以我们可以定义一个int类型的数组来存储数据\n\n取值的时候如果取值为空就返回一个`-1` ，所以我做了一个判断，判断是否有值\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass MyHashMap {\n\n    // 创建一个int类型的数组\n    Integer[] map=null;\n    public MyHashMap() {\n        map=new Integer[1000001];\n    }\n\n    public void put(int key, int value) {\n        map[key]=value;\n    }\n\n    public int get(int key) {\n        if (map[key]!=null){\n            int value=map[key];\n            return value;\n        }else{\n            return -1;\n        }\n    }\n\n    public void remove(int key) {\n        map[key]=null;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"SpringCloud微服务入门","url":"/2021/10/03/2021-10-03-SpringCloud微服务入门/","content":"\n# SpringCloud微服务入门\n\n##  1、微服务的发展历程\n\n### 1.1、单体结构\n简介：将业务的所有功能集中在一个项目中开发，打成一个包部署。我们之前所做的学生管理系统基本都是单体结构\n优点：结构简单、部署成本低\n缺点：耦合度高\n\n### 1.2、分布式结构\n简介：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。\n优点：降低服务耦合、有利于服务升级拓展\n分布式架构的要考虑的问题：\n服务拆分粒度如何？\n服务集群地址如何维护？\n服务之间如何实现远程调用？\n服务健康状态如何感知？\n\n### 1.3、微服务架构\n简介：微服务是一种经过良好架构设计的分布式架构方案。\n优点：拆分粒度更小、服务更独立、耦合度更低\n缺点：架构非常复杂，运维、监控、部署难度提高\n微服务架构的特征：\n- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发\n- 面向服务：微服务对外暴露业务接口\n- 自治：团队独立、技术独立、数据独立、部署独立\n- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n## 2、使用SpringCloud\n\nSpringCloud并不是一个全新的框架，其实他是一个将其他开源的框架集合的一个大篮子\n得益于SpringBoot框架方便的使用，我们也能很轻松地在SpringBoot上整合SpriongCloud的模块\n以下是SpringBoot和SpringCloud的版本匹配表，如果不按照这个规则，就有可能出现很多奇怪的问题![](https://bu.dusays.com/2021/10/03/9337d5a6f9ca0.png)\n\n### 2.1、服务拆分\n\n当我们使用微服务时，实际上就是相当于把原本在一起的模块拆分成一个一个的小的模块，所以我们在进行服务拆分时必须注意以下几点：\n1. 单一职责：不同微服务，不要重复开发相同业务\n2. 数据独立：不要访问其它微服务的数据库\n3. 面向服务：将自己的业务暴露为接口，供其它微服务调用\n\n### 2.2、服务调用\n\n当我们成功拆分出两个服务的时候，在使用时，肯定会出现A调用B，B调用C的情况出现，而此时我们想到的第一个方法就是根据服务的IP地址和端口进行调用。![](https://bu.dusays.com/2021/10/03/3cfda9ed84286.png)\n\n但是此时会出现一个问题，实际情况中我们一个服务肯定不只是只有一个地址，可能会有多个一样的服务，作为负载均衡。但是如果每个服务我们都需要通过IP+端口的方式来连接，那么当我们修改一个服务的端口时，就要相应地修改很多个调用他的端口的服务，显然是很麻烦的，而且也不能实现真正的负载均衡。所以我们需要一个注册中心来统一管理我们的所有服务。\n所以就有了eureka\n\n### 2.3、eureka注册中心\n\n消费者该如何获取服务提供者具体信息？\n- 服务提供者启动时向eureka注册自己的信息\n- eureka保存这些信息\n- 消费者根据服务名称向eureka拉取提供者信息\n\n如果有多个服务提供者，消费者该如何选择？\n- 服务消费者利用负载均衡算法，从服务列表中挑选一个\n\n消费者如何感知服务提供者健康状态？\n- 服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态\n- eureka会更新记录服务列表信息，心跳不正常会被剔除\n- 消费者就可以拉取到最新的信息\n\n现在我们来创建一个eureka注册中心：\n1. 我们需要创建一个普通的maven项目，然后在其中引入依赖：\n```shell\n<dependency>    \n\t<groupId>org.springframework.cloud</groupId>    \n\t<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n2. 在启动类上添加`@EnableEurekaServer`注解\n3. 然后创建一个配置文件`Application.yml`,在其中添加以下内容\n```yaml\nserver: \n\tport: 10086 #端口\nspring:  \n\tapplication:    \n\t\tname: eurekaserver\u000b#服务名称\neureka: \n\tclient:    \n\t\tservice-url:       \n\t\t\tdefaultZone: http://127.0.0.1:10086/eureka/ # eureka的地址，将自己注册到eureka中\n```\n\n以上就成功创建了一个eureka注册中心，运行打开端口，就可以看到我们创建好的注册中心![](https://bu.dusays.com/2021/10/03/aee959c4bd69a.png)\n\n注册成功的服务会显示在`Instances currently registered with Eureka`处\n\n\n\n接下来我们将客户端注册到注册中心去\n\n1. 我们在需要加入的服务中添加以下依赖：\n```shell\n<dependency>    \n\t<groupId>org.springframework.cloud</groupId>    \n\t<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n2. 然后再配置文件中添加以下内容\n```yaml\nspring: \n\tapplication:\n    name: orderservice\neureka:\n\tclient:\n\t\tservice-url:\n\t\t\tdefaultZone: http://127.0.0.1:10086/eureka/\n```\n与上面一样，将自己注册到了注册中心中![](https://bu.dusays.com/2021/10/03/28ced8e089410.png)\n\n### 2.4、eureka服务调用\n\n在成功将服务注册到eureka中之后，我们就可以使用服务名来替代端口地址对服务进行调用了\n```java\nString url = \"http://userservice/user/\" + order.getUserId();\n```\n但这不是一个真实有效的地址，是不能直接进行访问的，只能通过eureka进行访问\n\n## 3、负载均衡\n\n### 3.1、认识负载均衡\n以下是负载均衡的一个流程图（此流程图也解释了如何通过服务名调用对应的服务）![](https://bu.dusays.com/2021/10/03/7165d0dd07c93.png)\n\n负载均衡简单来说就是我们有多个同名的服务，他们做的是一样的事情，我们希望所有的请求给他们所有人一起分担，而不是一个人抗下所有的请求，所以这个时候负载均衡就起到了作用，根据不同的规则，负载均衡可以以不同的策略对请求的服务进行管理，可以极大减小服务器的压力。\n\n### 3.2、负载均衡策略\n以下就是负载均衡的策略规则\n![](https://bu.dusays.com/2021/10/03/c6326bca1dd7c.png)\n\n![](https://bu.dusays.com/2021/10/03/eb43a6d5349a9.png)\n\n**饥饿加载**\nRibbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n\n在yml配置文件中加入以下内容，就可以开启饥饿加载模式：\n```yaml\nribbon:\n\teager-load:\n\t\tenabled: true # 开启饥饿加载 \n\t\t\tclients: userservice # 指定对userservice这个服务饥饿加载\n```\n\n## 4、SpringCloud Alibaba\nSpring Cloud Alibaba 是阿里巴巴提供的微服务开发一站式解决方案，是阿里巴巴开源中间件与 Spring Cloud 体系的融合。\n\nSpring Cloud Alibaba在自身有很多新的组件之外，还可以兼容SpringCloudNetflix的部分组件，如eureka、zuul等等\n\n### 4.1、注册中心Nacos\n\nNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高\n\n**在使用之前我们得先进行安装**\n首先得去Github上下载Nacos的压缩包,[点击跳转](https://github.com/alibaba/nacos/releases)\n下载完成后放到一个没有中文的路径\n在`bin`路径处打开cmd，输入以下命令，即可运行Nacos\n```shell\nstartup.cmd -m standalone\n```\n以下是运行成功的标志![]( https://i.bmp.ovh/imgs/2021/10/f421f5312ec052f6.png )\n然后我们在浏览器输入地址和端口就可以进入到nacos里面去\n\n**可能报错**\n在启动的时候碰到以下错误\n\n```markdown\n 在启动时碰见这个提示：此时不应有 \\nacos\"\\logs\\java_heapdump.hprof -XX:-UseLargePages\"\n```\n此时我们打开自带的编译器，将下面的语句注释掉\n```shell\nREM if %MODE% == \"cluster\" (    REM echo \"nacos is starting with cluster\"\t  REM if %EMBEDDED_STORAGE% == \"embedded\" (\t      REM set \"NACOS_OPTS=-DembeddedStorage=true\"\t  REM )    REM set \"NACOS_JVM_OPTS=-server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=%BASE_DIR%\\logs\\java_heapdump.hprof -XX:-UseLargePages\"REM )\n```\n再次运行即可通过\n\n### 4.2、将服务注册到Nacos\n\n1. 在微服务的父工程文件中添加以下内容\n```shell\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-alibaba-dependencies</artifactId>    \t\t\t<version>2.2.6.RELEASE</version>\n\t<type>pom</type>\n\t<scope>import</scope>\n</dependency>\n```\n2. 注释掉所有的eureka依赖文件\n3. 添加Nacos依赖\n```shell\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n4. 然后修改yml文件，注释掉eureka的地址，添加上Nacos的地址\n```yaml\nspring:\n\tcloud:\n    \tnacos:\n      \t\tserver-addr: localhost:8848 # nacos服务地址\n```\n启动服务就可以注册到Nacos中了![]( https://i.bmp.ovh/imgs/2021/10/72e709e90cb38267.png )\n\n### 4.3、服务集群\n\n服务调用尽可能选择本地集群的服务，跨集群调用延迟较高\n本地集群不可访问时，再去访问其它集群\n\n**现在我们来设置服务的集群**\n1. 首先我们在yml文件中添加以下的内容\n```yaml\nspring:\n  cloud:\n    nacos:\n      discovery:\n        cluster-name: SH #cluster-name就是集群的名称\n```\n2. 然后重新运行就可以看到变化![](https://i.bmp.ovh/imgs/2021/10/d5fd108812f6fef4.png)\n\n3. 然后在order-service中设置负载均衡的IRule为NacosRule，这个规则优先会寻找与自己同集群的服务\n```ymal\nuserservice:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule  # 负载均衡规则\n```\n当本地集群正常运行时，服务就会优先调用本地集群的服务，而随后再考虑远程集群\n\n### 4.4、环境隔离 - namespace\n\nNacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离\n\n1. 在nacos的控制太我们可以创建一个命名空间![](https://z3.ax1x.com/2021/10/04/4Oh4bR.png)\n\n2. 填写好命名空间的信息，然后复制命名空间的ID\n3. 然后修改yml文件，添加命名空间的配置(添加最后一句)\n```yaml\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos服务地址\n      discovery:\n        cluster-name: HZ\n        ephemeral: false\n        namespace: 4d6ce343-9e1b-44df-a90f-2cf2b6b3d177 # dev环境\n```\n\n4. 启动服务就会看到相应的变化\n5. 此时不同空间中的服务是不能相互访问的\n\n## 5、Nacos配置管理\n\n### 5.1、Nacos实现配置的管理\n\nNacos有一个功能，就是可以将为服务的配置管理到自己的注册中心去，然后我们就可以通过远程调用，来使用这些配置在远端的配置文件。\n但是这又有什么用处呢？\n用处就是当我们有一些需要修改的开关型配置文件，我们希望修改时不影响到程序的运行，只要我们对程序进行了更改，就会自动进行配置，也叫做热部署。\n所以Nacos的配置管理就可以实现这样的一个功能。\n那么要怎么实现呢？\n\n1. 首先我们进入到Nacos的配置管理界面，打开配置列表，点击右上角的`+` 创建新的配置![](https://z3.ax1x.com/2021/10/04/4XiLA1.png)\n\n2. 如下图一样配置好文件，然后可以在下面的黑色输入框以`yml` 文件的格式输入你想要的配置内容，完成之后点击发布即可![](https://z3.ax1x.com/2021/10/04/4XkuRK.png)\n\n3. 现在我们就可以去java代码中进行配置的拉取了\n\n### 5.2、配置的拉取\n\n创建好了配置文件，我们现在需要去java代码中对其进行拉取。\n而以往我们运行微服务时直接就会读取 `application.yml` 这个配置文件，如何在读取他之前先读取Nacos上的配置文件呢？\n这时，我们就可以添加一个优先级更高的配置文件`bootstrap.yml` ，在里面编写读取Nacos配置的配置。\n\n![](https://z3.ax1x.com/2021/10/04/4XA3lT.png)\n\n\n1. 首先引入Nacos配置文件的依赖\n```shell\n<!--<nacos配置依赖-->\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n```\n2. 然后我们创建一个 `bootstrap.yml` ，里面写的是拉取远程配置的代码\n```yaml\nspring:\n  application:\n    name: userservice\n  profiles:\n    active: dev # 环境\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n```\n比如这里我们读取了 `userservice-dev.yaml` 文件的内容\n\n3. 然后我们检验一下是否能拿到远程的配置，以下是我们的远程配置文件中所包含的内容\n```yaml\npattern:\n    dateformat: yyyy/MM/dd HH:mm:ss\n```\n然后我们在Controller文件中获取一下配置文件，然后输出到屏幕上\n```java\n@Value(\"${pattern.dateformat}\")\nprivate String dateformat;\n\n@GetMapping(\"now\")\npublic String now(){\n\treturn LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n}\n```\n如果读取成功屏幕上就会按照前面的格式输出时间![](https://z3.ax1x.com/2021/10/04/4XEA41.png)\n\n### 5.3、配置热更新\n\n有了配置文件之后，我们现在要来配置热更新了。\n最简单的方法就是通过注解的方式来进行添加，就是以下的这种方法\n\n在 `@Value` 注入的变量所在类上添加注解 `@RefreshScope`\n\n另一种方法就是使用 `@ConfigurationProperties` 注解来实现。\n\n首先我们创建一个 `PatternProperties ` 类，然后在上面标上 `@ConfigurationProperties(prefix = \"pattern\")` ,`@Component` ,`@Data` 等注解。\n然后在类中创建一个私有成员变量`private String dateformat;` ，然后其他的控制器中对其进行注入并调用，就可以实现热更新。\n\n### 5.4、多环境配置共享\n\n![](https://z3.ax1x.com/2021/10/04/4XZMtA.png)\n\n而在不同微服务之间可以共享配置文件，可以通过下面的两种方式来指定：\n\n1. 方式一\n```yaml\nspring:\n\tapplication:\n\t\tname: userservice # 服务名称\n\tprofiles:\n\t\tactive: dev # 环境，\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # Nacos地址\n\t\t\tconfig: \n\t\t\t\tfile-extension: yaml # 文件后缀名\n\t\t\t\tshared-configs: # 多微服务间共享的配置列表\n\t\t\t\t\t- dataId: common.yaml # 要共享的配置文件id\n```\n2. 方式二\n```yaml\nspring:\n\tapplication:\n\t\tname: userservice # 服务名称\n\tprofiles:\n\t\tactive: dev # 环境，\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # Nacos地址\n\t\t\tconfig: \n            \tfile-extension: yaml # 文件后缀名\n\t\t\t\textends-configs: # 多微服务间共享的配置列表\n\t\t\t\t\t- dataId: extend.yaml # 要共享的配置文件id\n\n```\n\n### 5.5、Nacos集群搭建\n\n以下是教程中所要搭建的集群结构\n\n![](https://z3.ax1x.com/2021/10/04/4Xe2Kf.png)\n\n三个nacos节点的地址：\n\n| 节点   | ip            | port |\n| ------ | ------------- | ---- |\n| nacos1 | 192.168.150.1 | 8845 |\n| nacos2 | 192.168.150.1 | 8846 |\n| nacos3 | 192.168.150.1 | 8847 |\n\n**然后我们现在开始搭建我们的集群**\n\n搭建集群的基本步骤：\n\n- 搭建数据库，初始化数据库表结构\n- 下载nacos安装包\n- 配置nacos\n- 启动nacos集群\n- nginx反向代理\n\n1. 初始化数据库\n\n   我们在我们的数据库中创建好一个我们所需要的数据库\n\n2. 然后安装包我们已经下载过了，就可以直接跳过，然后配置一下nacos\n\n   进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：\n   ![](https://z3.ax1x.com/2021/10/04/4Xeva4.png)\n\n   然后添加以下三个地址\n\n   ![](https://z3.ax1x.com/2021/10/04/4XmfQx.png)\n\n   然后修改application.properties文件，添加数据库配置\n\n``` properties \n   spring.datasource.platform=mysql\n   db.num=1\n   db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\n   db.user.0=root\n   db.password.0=123\n```\n\n3. 启动\n\n   将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\n\n   然后分别修改三个文件夹中的 `application.properties` ，\n\n   nacos1:\n\n```properties\n   server.port=8845\n```\n\n   nacos2:\n\n```properties\n   server.port=8846\n```\n\n   nacos3:\n\n```properties\n   server.port=8847\n```\n\n   然后分别启动三个nacos节点：\n```\nstartup.cmd\n```\n\n4. Nginx反向代理\n\n安装好nginx之后，打开文件夹。修改conf/nginx.conf文件，配置如下：\n\n```nginx\nupstream nacos-cluster {\n    server 127.0.0.1:8845;\n\tserver 127.0.0.1:8846;\n\tserver 127.0.0.1:8847;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location /nacos {\n        proxy_pass http://nacos-cluster;\n    }\n}\n```\n\n然后在浏览器访问：http://localhost/nacos即可。\n\n代码中application.yml文件配置如下：\n\n```yaml\n spring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n```\n\n## 6、客户端Feign\n\nFeign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现http请求的发送\n\n![](https://z3.ax1x.com/2021/10/04/4Xtf4x.png)\n\n### 6.1、使用\n\n1. 引入依赖\n```xml\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-openfeign</artifactId>\n </dependency>\n```\n2. 在order-service的启动类添加注解开启Feign的功能：![](https://z3.ax1x.com/2021/10/04/4XNUMD.png)\n\n3. 编写feign客户端\n```java\n@FeignClient(\"userservice\")\npublic interface UserClient {\n\t@GetMapping(\"/user/{id}\") \n\tUser findById(@PathVariable(\"id\") Long id);\n}\n```\n主要是基于SpringMVC的注解来声明远程调用的信息，比如：\n- 服务名称：userservice\n- 请求方式：GET\n- 请求路径：/user/{id}\n- 请求参数：Long id\n- 返回值类型：User\n\n使用这种方式就可以很方便地代替之前的url的调用方式，代码变得更加清晰简洁。\n以下就是调用的内容\n\n4. 调用\n![](https://z3.ax1x.com/2021/10/04/4XUSF1.png)\n\n### 6.2、自定义Feign的配置\n\nFeign运行自定义配置来覆盖默认配置，可以修改的配置如下：![](https://z3.ax1x.com/2021/10/04/4XUiQO.png)\n\n一般情况下我们会修改日志级别,最好用basic或none\n\n### 6.3、配置Feign的日志\n\n配置日志时我们也有两种方式，一种是配置文件的方式，另一种是java代码的方式\n\n1. 配置文件方式\n\n```yaml\nfeign:\n\tclient:\n\t\tconfig:\n\t\t\tdefault: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n\t\t\t\tloggerLevel: FULL #  日志级别\n```\n\n2. java代码方式\n\n首先我们声明一个Bean\n```java\npublic class FeignClientConfiguration {\n\t@Bean\n\tpublic Logger.Level feignLogLevel(){\n\t\treturn Logger.Level.BASIC; \n\t}\n}\n```\n然后如果是全局配置，我们就放到 `@EnableFeignClients` 这个注解中\n```java\n@EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) \n```\n如果是局部配置，我们就放到 `@FeignClient` 这个注解中\n```java\n@FeignClient(value = \"userservice\", configuration = FeignClientConfiguration.class) \n```\n\n### 6.4、性能优化\n\nFeign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：\n\n- URLConnection：默认实现，不支持连接池\n- Apache HttpClient ：支持连接池\n- OKHttp：支持连接池\n\n因此提高Feign的性能主要手段就是使用**连接池**代替默认的URLConnection。\n这里我们用Apache的HttpClient来演示。\n1. 引入依赖\n在order-service的pom文件中引入Apache的HttpClient依赖：\n```xml\n<!--httpClient的依赖 -->\n<dependency>\n    <groupId>io.github.openfeign</groupId>\n    <artifactId>feign-httpclient</artifactId>\n</dependency>\n```\n2. 配置连接池\n```yaml\nfeign:\n  client:\n    config:\n      default: # default全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启feign对HttpClient的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n```\n3. 优化总结\n总结，Feign的优化：\n\n1.日志级别尽量用basic\n2.使用HttpClient或OKHttp代替URLConnection\n①  引入feign-httpClient依赖\n②  配置文件开启httpClient功能，设置连接池参数\n\n### 6.5、最佳实践\n\n所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。\n自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：\nfeign客户端：![](https://z3.ax1x.com/2021/10/04/4X0pHe.png)\nUserController：![](https://z3.ax1x.com/2021/10/04/4X0k9I.png)\n\n我们有两种方法来优化重复的代码编写\n1. 继承方式\n2. 抽取方式\n\n首先来说一下**继承方式**：\n一样的代码可以通过继承来共享：\n1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。\n2）Feign客户端和Controller都集成这个接口![](https://z3.ax1x.com/2021/10/04/4X0EgP.png)\n\n优点：\n- 简单\n- 实现了代码共享\n\n缺点：\n- 服务提供方、服务消费方紧耦合\n- 参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解\n\n然后是**抽取的方式**\n将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。\n例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用\n![](https://z3.ax1x.com/2021/10/04/4X0dUJ.png)\n\n### 6.6、基于抽取的最佳实践\n\n1. 首先创建一个公共类 `feign-api`\n2. 在这个类中引入依赖\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n3. 然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中\n![](https://z3.ax1x.com/2021/10/04/4X0RVe.png)\n4. 在order-service中使用feign-api（引入api的依赖）\n```xml\n<dependency>\n    <groupId>cn.itcast.demo</groupId>\n    <artifactId>feign-api</artifactId>\n    <version>1.0</version>\n</dependency>\n```\n5. 修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包\n6. 此时当我们重启测试的时候，就会发现出错了，出错内容如下\n![](https://z3.ax1x.com/2021/10/04/4X07Kf.png)\n\n这是因为UserClient现在在cn.itcast.feign.clients包下，\n而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。\n7. 解决扫描包问题\n\n有两种方法，一种是：指定Feign应该扫描的包\n```java\n@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\")\n```\n一种是指定要加载的Client的接口\n```java\n@EnableFeignClients(clients = {UserClient.class})\n```\n\n8. 至此，就设置完毕了\n\n\n\n## 7、Gateway网关\n\n为什么需要网关？网关用来干嘛\n网关可以用于：\n\n- 身份认证和权限校验\n- 服务路由、负载均衡\n- 请求限流\n\n在SpringCloud中有两种网关服务，一种是Gateway，另一种是Zuul\n而两者的差别是：Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。\n\n### 7.1、搭建一个Gateway网关\n\n我们需要创建一个网关的类来搭建一个网关，具体步骤如下：\n1. 创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖\n```xml\n<!--网关依赖-->\n<dependency>\n\t<groupId>org.springframework.cloud</groupId>\n\t<artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<!--nacos服务发现依赖-->\n<dependency>\n\t<groupId>com.alibaba.cloud</groupId>\n\t<artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n2. 然后在网关的yml文件中编写路由配置及nacos地址\n```yaml\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: localhost:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service # 路由id，自定义，只要唯一即可\n          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n```\n此时，如果我们在控制台输入nacos的地址，以及加上断言中配置好的路径进行访问，就会被网关带到制定好的位置。\n比如说我访问`localhost:8848/user/now`，就会被带到userservice的now方法去，这就是网关的服务路由功能，是使用断言来实现的。\n\n### 7.2、断言工厂\n\n在yml文件中有这样一个配置：\n```\npredicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地\n```\n我们在配置文件中写的断言规则只是字符串，这些字符串会被`Predicate Factory`读取并处理，转变为路由判断的条件\n例如 `Path=/user/**`\n是按照路径匹配，这个规则是由`org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory` 类来处理的\n像这样的断言工厂在`SpringCloudGateway`还有十几个\n\nSpring给我们提供了很多种Predicate工厂\n![](https://z3.ax1x.com/2021/10/05/4j49G6.png)\n但是我们一般用的比较多的还是 `Path` 这种方式.\n\n### 7.3、路由过滤器/过滤器工厂\n\nGatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n![](https://z3.ax1x.com/2021/10/05/4j41sg.png)\n\nSpring提供了31种不同的路由过滤器工厂,例如：\n![](https://z3.ax1x.com/2021/10/05/4j4yw9.png)\n\n现在我们通过一个简单的例子，实际应用一下这个功能：\n给所有的userservice添加一个请求头\n```yaml\nspring:\n\tcloud:\n\t\tgateway:\n\t\t\troutes: # 网关路由配置\n\t\t\t\t- id: user-service\n\t\t\t\t  uri: lb://userservice\n\t\t\t\t  predicates:\n\t\t\t\t\t- Path=/user/**\n\t\t\t\t  filters: # 过滤器\n\t\t\t\t\t- AddRequestHeader=Truth, GUET is freaking awesome! # 添加请求头\n```\n此时所有的userservice的请求都加上了`Truth, GUET is freaking awesome!`这个请求头。\n\n而此时其他的不受影响，那么怎么样才能修改所有的请求头呢？\n有一个简单的方法，就是使用 `default-filters` \n例子如下：\n```yaml\nspring:\n\tapplication:\n\t\tname: gateway # 服务名称\n\tcloud:\n\t\tnacos:\n\t\t\tserver-addr: localhost:8848 # nacos地址\n\tgateway:\n\t\troutes: # 网关路由配置\n\t\t\t- id: user-service \n\t\t \t  uri: lb://userservice \n\t\t\t  predicates: \n\t\t\t\t- Path=/user/**\n\t\t\t- id: order-service\n\t\t\t  uri: lb://orderservice\n\t\t\t  predicates:\n\t\t\t\t- Path=/order/**\n\t\tdefault-filters: # 默认过滤器，会对所有的路由请求都生效\n\t\t\t- AddRequestHeader=Truth, GUET is freaking awesome! # 添加请求头\n```\n此时，过滤器并没有指定加载哪一个服务上面，而是加在了`routes`的同一级上，包括了所有的service服务，所以他的含义就是为所有的服务都统一添加了这样的一个请求头\n\n### 7.4、全局过滤器\n\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与`GatewayFilter`的作用一样。\n区别在于`GatewayFilter`通过配置定义，处理逻辑是固定的。而`GlobalFilter`的逻辑需要自己写代码实现。\n定义方式是实现`GlobalFilter`接口。\n![](https://z3.ax1x.com/2021/10/05/4j5I3V.png)\n\n下面我们以一个案例来说明：\n\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n- 参数中是否有 `authorization`，\n- `authorization` 参数值是否为admin\n\n如果同时满足则放行，否则拦截.\n我们现在自定义一个类，实现FlobalFilter接口\n```java\n@Order(-1)\n@Component\npublic class AuthorizeFilter implements GlobalFilter {\n\t@Override\n\tpublic Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n\t\t// 1.获取请求参数\n\t\tMultiValueMap<String, String> params = exchange.getRequest().getQueryParams();\n\t\t// 2.获取authorization参数\n\t\tString auth = params.getFirst(\"authorization\");\n\t\t// 3.校验\n\t\tif (\"admin\".equals(auth)) {\n\t\t\t// 放行\n\t\t\treturn chain.filter(exchange);\n\t\t}\n\t\t// 4.拦截\n\t\t// 4.1.禁止访问\n\t\texchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);\n\t\t// 4.2.结束处理\n\t\treturn exchange.getResponse().setComplete();\n\t}\n}\n\n```\n注意一点，**在Order注解中，包含的值越小，优先级越高**\n\n**接下来我们看看过滤器的执行顺序：**\n\n- 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前。\n- GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定\n- 路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。\n- 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器 > GlobalFilter的顺序执行。\n\n\n### 7.5、Cors跨域\n\n跨域：域名不一致就是跨域，主要包括：\n域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com\n域名相同，端口不同：localhost:8080和localhost8081\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题\n解决方案：CORS\n\n只需要简单配置即可实现，如下所示：\n```yaml\nspring:\n\tcloud:\n\t\tgateway:\n\t\t\tglobalcors: # 全局的跨域处理\n\t\t\t\tadd-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n\t\t\t\tcorsConfigurations:\n\t\t\t\t'[/**]':\n\t\t\t\t\tallowedOrigins: # 允许哪些网站的跨域请求 \n\t\t\t\t\t  - \"http://localhost:8090\"\n\t\t\t\t\t  - \"http://www.leyou.com\"\n\t\t\t\t\tallowedMethods: # 允许的跨域ajax的请求方式\n\t\t\t\t\t  - \"GET\"\n\t\t\t\t\t  - \"POST\"\n\t\t\t\t\t  - \"DELETE\"\n\t\t\t\t\t  - \"PUT\"\n\t\t\t\t\t  - \"OPTIONS\"\n\t\t\t\t\tallowedHeaders: \"*\" # 允许在请求中携带的头信息\n\t\t\t\t\t\tallowCredentials: true # 是否允许携带cookie\n\t\t\t\t\tmaxAge: 360000 # 这次跨域检测的有效期\n```\njava代码就会根据上面配置的内容执行跨域的请求。","tags":["java","SpringCloud"],"categories":["java","SpringCloud"]},{"title":"算法学习_栈实现队列、队列实现栈","url":"/2021/10/01/2021-10-01-算法学习_栈实现队列、队列实现栈/","content":"\n# 栈实现队列、队列实现栈\n\n## 题目1、用栈来实现队列\n[lettcode-232题](https://leetcode-cn.com/problems/implement-queue-using-stacks/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/10/0e1d526ab12c4731.png )\n\n\n### 1.1、 解题思路\n栈是一个先进后出的数据结构，而队列是一个先进先出的数据结构，所以我们想要用栈来实现队列，就必须要用到两个栈，第一个栈出栈到第二个栈中，第二个栈再进行出栈，就可以实现队列先进先出的功能。\n\n具体代码如下\n\n\n### 1.2、具体代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> a;\n    private Stack<Integer> b;\n\n    public MyQueue() {\n        a=new Stack<>();\n        b=new Stack<>();\n    }\n\n    /**\n     * 入栈\n     * @param x\n     */\n    public void push(int x) {\n        a.push(x);\n    }\n\n    /**\n     * 出栈\n     * @return\n     */\n    public int pop() {\n        if(b.isEmpty()){\n            while (!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n\n    /**\n     * 返回栈顶元素\n     * @return\n     */\n    public int peek() {\n        if(b.isEmpty()){\n            while (!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n\n    /**\n     * 判断栈空\n     * @return\n     */\n    public boolean empty() {\n        return a.isEmpty()&&b.isEmpty();\n    }\n}\n```\n\n## 题目2、用队列来实现栈\n\n[lettcode-225题](https://leetcode-cn.com/problems/implement-stack-using-queues/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/10/69ec1eaccdf3cbb8.png )\n\n### 2.1、解题思路\n\n与上一题相同，我们需要用两个队列来实现一个栈\n\n利用队列中的基本方法们就可以实现栈的先进后出的操作\n\n代码如下：\n\n### 2.2、具体代码\n\n```java\nclass MyStack {\n\n    private Queue<Integer> a;\n    private Queue<Integer> b;\n\n    public MyStack() {\n        a=new LinkedList<>();\n        b=new LinkedList<>();\n    }\n\n    /**\n     * 入栈\n     * @param x\n     */\n    public void push(int x) {\n        a.offer(x);\n        // 将b队列中元素全部转给a队列\n        while(!b.isEmpty()) {\n            a.offer(b.poll());\n        }\n        // 交换a和b,使得a队列没有在push()的时候始终为空队列\n        Queue temp = a;\n        a = b;\n        b = temp;\n    }\n\n    /**\n     * 出栈\n     * @return\n     */\n    public int pop() {\n        return b.poll();\n    }\n\n    /**\n     * 返回栈顶元素\n     * @return\n     */\n    public int top() {\n        return b.peek();\n    }\n\n    /**\n     * 判断栈是否为空\n     * @return\n     */\n    public boolean empty() {\n        return b.isEmpty();\n    }\n}\n```\n\n","tags":["算法"],"categories":["算法"]},{"title":"算法学习_最近的请求次数","url":"/2021/10/01/2021-10-01-算法学习_最近的请求次数/","content":"\n# 最近的请求次数\n\n## 题目\n[lettcode-933题](https://leetcode-cn.com/problems/number-of-recent-calls/) \n难度：简单![1633055736251]( https://i.bmp.ovh/imgs/2021/10/19b9897eff6dedb1.png )\n\n\n## 解题思路\n从题目上来看，一时半会看不出来是什么意思。\n\n其实所输入的数字t就是一个毫秒数，根据这个数来判断3000毫秒之前的数，如果小于3000毫秒之前的就删除小于的那个。\n\n所以当我们输入3002时，3000-3000=2，而1小于2，所以1就会被删除。\n\n所以说这个题是一个先进先出的方式，所以我们可以使用队列来实现。\n\n具体实现方式如下\n\n\n## 具体代码\n```java\nclass RecentCounter {\n\n    //构造一个队列，LinkedList的队列\n    Queue<Integer> queue;\n    public RecentCounter() {\n        queue=new LinkedList<>();\n    }\n\n    public int ping(int t) {\n        //将输入的数值入队\n        queue.add(t);\n        //判断栈顶元素是否小于t-3000\n        //如果小于t-3000，将其出队\n        while (queue.peek()<t-3000){\n            queue.poll();\n        }\n        //返回队列的长度\n        return queue.size();\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"Redis使用注解实现二级缓存","url":"/2021/09/29/2021-09-29-Redis使用注解实现二级缓存/","content":"\n# Redis使用注解实现二级缓存\n\n## 1、介绍\n\n上一篇文章中，我们实现二级缓存的方式是通过java代码判断Redis是否存在缓存，然后决定从何处取数据，但是这种方法在我们有大量的需要用到缓存的地方的时候，会产生大量的冗余代码，而且有大量的判断语句，让我们的代码不能够专注于业务上面，这样子是不太好的。\n\n所以在Spring的3.1版本之后就引入了对注解的支持，我们可以通过在类上、方法上标记注解来实现二级缓存的存取\n\n其三个注解分别为：`Cacheable` ，`CacheEvict`，`CachePut`\n\n下面我会将三个注解分别展开进行简单解释\n\n## 2、Cacheable注解\n\n- @Cacheable可以标记在一个方法上，也可以标记在一个类上。\n- 对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。\n- Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果。\n- 至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。\n- 需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。\n- @Cacheable可以指定三个属性，value、key和condition。\n\n### 2.1、value属性\n\nvalue属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。\n如下例子所示：\n```java\n@RequestMapping(\"selectForAll\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper::AllStudent\")\npublic List<Student> selectStudentForAll() {\n    List<Student> studentList = studentService.selectStudentForAll();\n    return studentList;\n}\n```\n\n### 2.2、key属性\n\n- key属性是用来指定Spring缓存方法的返回结果时对应的key的。\n- 该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。\n- 定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n此时，如果我查询了一个sId为1800710318的学生\n那么上面的方法中最后缓存的键为：`MYBATIS:com.chen.mysqlredisdemo.StudentMapper::1800710318`\n\n### 2.3、condition属性\n\n- condition属性可以用于指定缓存发生的条件。\n- 有的时候我们可能并不希望缓存一个方法所有的返回结果，这时候通过condition属性可以实现这一功能。\n- condition属性默认为空，表示将缓存所有的调用情形。\n- 其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。\n如下例子所示：\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n@Cacheable(value = \"MYBATIS:com.chen.mysqlredisdemo.StudentMapper\", key = \"#sId\",condition = \"#sId>1800710301\")\npublic Student selectStudentForOne(@PathVariable int sId) {\n\tStudent student = studentService.selectStudentForOne(sId);\n\treturn student;\n}\n```\n上面的例子就表示当查询的sId大于1800710318的时候才会执行缓存的操作\n\n## 3、CachePut注解\n\n- 在支持Spring Cache的环境下，对于使用@Cacheable标注的方法，Spring在每次执行前都会检查Cache中是否存在相同key的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。\n- @CachePut也可以声明一个方法支持缓存功能。\n- 与@Cacheable不同的是使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。\n- @CachePut也可以标注在类上和方法上。使用@CachePut时我们可以指定的属性跟@Cacheable是一样的。\n\n简而言之就是CachePut只会往缓存中写数据，不会从缓存中拿数据\n\n## 4、CacheEvict注解\n\n- @CacheEvict是用来标注在需要清除缓存元素的方法或类上的。当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。\n- @CacheEvict可以指定的属性有value、key、condition、allEntries和beforeInvocation。\n- 其中value、key和condition的语义与@Cacheable对应的属性类似。即value表示清除操作是发生在哪些Cache上的（对应Cache的名称）；key表示需要清除的是哪个key，如未指定则会使用默认策略生成的key；condition表示清除操作发生的条件。\n- 与前面不同的不同的是有了两个多出来的属性：`allEntries`和`beforeInvocation`\n\n### 4.1、allEntries属性\n- allEntries是boolean类型，表示是否需要清除缓存中的所有元素。\n- 默认为false，表示不需要。当指定了allEntries为true时，Spring Cache将忽略指定的key。\n- 有的时候我们需要Cache一下清除所有的元素，这比一个一个清除元素更有效率。\n\n### 4.2、beforeInvocation属性\n\n- 清除操作默认是在对应方法成功执行之后触发的，即方法如果因为抛出异常而未能成功返回时也不会触发清除操作。\n- 使用beforeInvocation可以改变触发清除操作的时间，当我们指定该属性值为true时，Spring会在调用该方法之前清除缓存中的指定元素。\n\n## 5、Caching注解\n\n@Caching注解可以让我们在一个方法或者类上同时指定多个Spring Cache相关的注解。\n其拥有三个属性：cacheable、put和evict，分别用于指定@Cacheable、@CachePut和@CacheEvict。\n\n其例子如下\n```java\n @Caching(cacheable = @Cacheable(\"users\"), evict = { @CacheEvict(\"cache2\"), @CacheEvict(value = \"cache3\", allEntries = true) })\npublic User find(Integer id) {\n\treturnnull;\n}\n```\n上面的例子通过一个Caching注解，实现了三种注解同事的配置，相当于一个大集合\n\n\n## 6、总结\n\nSpringBoot中大量使用了注解、替代了原有的配置文件。\n大大减少了冗余代码，方便地实现了注解中所设置好的功能。\n使得我们的代码简洁易懂。\n除了官方默认的注解，同时我们还可以自定义很多注解，极大方便了我们的使用。","tags":["java","redis"],"categories":["java","数据库","redis","redis"]},{"title":"Redis入门使用","url":"/2021/09/29/2021-09-29-Redis的入门使用/","content":"\n# Redis入门使用\n\n## 1、Redis简介\n1. 简介\nRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\n    - Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n    - Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n    - Redis支持数据的备份，即master-slave模式的数据备份。\n\n2. 优势\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n## 2、Redis安装\n### 2.1、window安装\n下载地址：https://github.com/tporadowski/redis/releases。\n** 根据自己电脑是32位或者64位的下载相对应得版本，就可以进行安装使用 **\n解压文件夹之后进入文件夹得目录下打开cmd\n输入以下命令，就可以运行redis\n`redis-server.exe redis.windows.conf`\n重新打开一个cmd，输入以下命令就可以进行数据库操作\n`redis-cli.exe -h 127.0.0.1 -p 6379`\n\n### 2.2、Linux安装\n下载地址：http://redis.io/download 下载最新稳定版本。\n在linux中对压缩包进行解压之后\n进入解压后的文件夹\n进行make操作\n```shell\n# wget http://download.redis.io/releases/redis-6.0.8.tar.gz\n# tar xzf redis-6.0.8.tar.gz\n# cd redis-6.0.8\n# make\n```\nmake之后，src目录下面就会出现一个`redis-server`的文件，可以用来启动Redis，如下\n```shell\n# cd src\n# ./redis-server\n```\n除此之外，Redis还给我们提供了一个配置文件，可以修改Redis的配置文件，并运行，如下\n```shell\n# cd src\n# ./redis-server ../redis.conf\n```\n### 2.3、Ubuntu apt 命令安装\nUbuntu系统不像其他的linux系统，它可以通过命令来在线安装\n在 Ubuntu 系统安装 Redis 可以使用以下命令:\n```shell\n# sudo apt update\n# sudo apt install redis-server\n```\n然后可以启动\n```shell\n# redis-server\n```\n\n## 3、Redis的数据类型\n### 3.1、String类型\n\n字符串类型，是一种我们平常最常见到的一种数据类型之一\n我们使用set和get存取数据时，一般就是String的类型，如下\n```shell\nredis 127.0.0.1:6379> SET name \"陈益财\"\nOK\nredis 127.0.0.1:6379> GET name\n\"陈益财\"\n```\n其中，name就是key，\"陈益财\"就是所对应的值\n\n### 3.2、Hash类型\n\nRedis hash 是一个键值(key=>value)对集合。\nRedis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象\n例子如下：\n```shell\nredis 127.0.0.1:6379> HMSET names name1 \"chenyicai\" name1 \"George\"\n\"OK\"\nredis 127.0.0.1:6379> HGET names name1\n\"Hello\"\nredis 127.0.0.1:6379> HGET names name1\n\"World\"\n```\n\n### 3.3、List类型\n\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n例子如下：\n```shell\nredis 127.0.0.1:6379> lpush chen redis\n(integer) 1\nredis 127.0.0.1:6379> lpush chen mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush chen rabbitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange chen 0 10\n1) \"rabbitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n其中lpush表示存数据，而lrange表示取数据\n\n### 3.4、set类型\n\nRedis 的 Set 是 string 类型的无序集合。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。\n例子如下：\n```shell\nredis 127.0.0.1:6379> sadd chen redis\n(integer) 1\nredis 127.0.0.1:6379> sadd chen mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd chen rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers chen\n\n1) \"redis\"\n2) \"rabbitmq\"\n3) \"mongodb\"\n```\n其中sadd表示添加数据，smembers表示取出数据\n**注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略**\n\n### 3.5、zset类型\n\nRedis zset 和 set 一样也是string类型元素的集合,**且不允许重复的成员**。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n例子·如下：\n```shell\nredis 127.0.0.1:6379> zadd chen 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd chen 0 rabbitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE chen 0 1000\n1) \"mongodb\"\n2) \"rabbitmq\"\n3) \"redis\"\n```\n其中zadd表示存数据，ZRANGEBYSCORE表示取数据\n且虽然存了两次相同的字符，但是也是只会保留一个\n\n## 4、在java中使用Redis\n\n使用Redis更多的情况是在java环境下面使用，所以需要掌握如何在java中对Redis进行操作\nRedis官方给我们提供了很方便的工具来进行Redis的操作：Jedis\n\n首先你需要下载驱动包 [下载 jedis.jar](https://mvnrepository.com/artifact/redis.clients/jedis)，确保下载最新驱动包。\n\n### 4.1、连接到Redis\n配置完成之后我们就可以连接到Redis了。\n例子如下：\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        // 如果 Redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth(\"123456\"); \n        System.out.println(\"连接成功\");\n        //查看服务是否运行\n        System.out.println(\"服务正在运行: \"+jedis.ping());\n    }\n}\n```\n如果是可以连接成功的，就会返回一个PONG表示回应\n\n### 4.2、String类型的存储\n\n```java\nimport redis.clients.jedis.Jedis;\n \npublic class RedisStringJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //设置 redis 字符串数据\n        jedis.set(\"name\", \"chenyicai\");\n        // 获取存储的数据并输出\n        System.out.println(\"redis 存储的字符串为: \"+ jedis.get(\"name\"));\n    }\n}\n```\n成功之后控制台就会显示name所对应的值：chenyicai\n\n### 4.3、List类型的存储\n\n```java\nimport java.util.List;\nimport redis.clients.jedis.Jedis;\n \npublic class RedisListJava {\n    public static void main(String[] args) {\n        //连接本地的 Redis 服务\n        Jedis jedis = new Jedis(\"localhost\");\n        System.out.println(\"连接成功\");\n        //存储数据到列表中\n        jedis.lpush(\"site-list\", \"Baidu\");\n        jedis.lpush(\"site-list\", \"Google\");\n        jedis.lpush(\"site-list\", \"Taobao\");\n        // 获取存储的数据并输出\n        List<String> list = jedis.lrange(\"site-list\", 0 ,2);\n        for(int i=0; i<list.size(); i++) {\n            System.out.println(\"列表项为: \"+list.get(i));\n        }\n    }\n}\n```\n成功之后控制台就会返回信息\n```\n列表项为: Taobao\n列表项为: Google\n列表项为: Baidu\n```\n\n## 5、在SpringBoot中使用Redis\n\n一般在SpringBoot中使用Redis时我们会用来做Mysql数据库的二级缓存，这样子在我们获取数据的时候就不需要每次都到数据库进行查询，如果缓存中有数据就可以直接从缓存中拿，大大提高了查询的效率。\n\n1. 首先我们需要在maven中引入我们所需要的依赖\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n2. 然后在yml配置文件中，配置Redis的相关配置文件\n```java\nspring:\n  redis:\n    database: 0\n    host: localhost\n    port: 6379\n    password:\n    timeout: 500\n    pool:\n      max-active: 8\n      max-idle: 8\n      min-idle: 0\n      max-wait: -1\n```\n3. 我们还需要一个Config类来处理数据的序列化，否则双方可能会出现乱码的情况\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    private RedisConnectionFactory redisConnectionFactory;\n\n    public RedisConfig(RedisConnectionFactory redisConnectionFactory) {\n        this.redisConnectionFactory = redisConnectionFactory;\n    }\n\n    /**\n     * redisTemplate 序列化使用的jdkSerializeable, 存储二进制字节码, 所以自定义序列化类\n     *\n     * @return\n     */\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate() {\n        RedisTemplate<Object, Object> redisTemplate = new RedisTemplate<>();\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n\n        // 使用Jackson2JsonRedisSerialize 替换默认序列化\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n\n        ObjectMapper objectMapper = new ObjectMapper();\n        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n\n        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);\n\n        // 设置value的序列化规则和 key的序列化规则\n        redisTemplate.setKeySerializer(new StringRedisSerializer());\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.setHashKeySerializer(new StringRedisSerializer());\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n\n}\n```\n\n4. 创建一个cache的实现类用于将查出来的数据添加到缓存中，并设置一些缓存的配置,里面包括了一些有关增删改的配置方法。\n```java\npublic class MybatisRedisCache implements Cache {\n    private Object key;\n    private String id;\n\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private RedisTemplate<Object, Object> redisTemplate;\n\n    private final String COMMON_CACHE_KEY = \"MYBATIS:\";\n\n    /**\n     * 默认缓存对象的缓存时间为 1 分钟\n     **/\n    private static final long EXPRIRE_TIME_IN_MINUT = 30;\n\n    public MybatisRedisCache(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"缓存对象id是不能为空的\");\n        }\n        this.id = id;\n    }\n\n    private RedisTemplate<Object, Object> getRedisTemplate() {\n        if (redisTemplate == null) {\n            redisTemplate = ApplicationContextHolder.getBean(\"redisTemplate\");\n        }\n        return redisTemplate;\n    }\n\n    @Override\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public void putObject(Object key, Object value) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            //使用redisTemplate得到值操作对象\n            ValueOperations operation = redisTemplate.opsForValue();\n            //使用值操作对象operation设置缓存对象\n            operation.set(getKey(key), value, EXPRIRE_TIME_IN_MINUT, TimeUnit.MINUTES);\n//            System.out.println(\"缓存对象保存成功\");\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象保存失败\" + t);\n        }\n    }\n\n    public Object getKey() {\n        return key;\n    }\n\n    public void setKey(Object key) {\n        this.key = key;\n    }\n\n    @Override\n    public Object getObject(Object key) {\n        try {\n            setKey(key);\n            RedisTemplate redisTemplate = getRedisTemplate();\n            ValueOperations operations = redisTemplate.opsForValue();\n            Object result = operations.get(getKey(key));\n//            System.out.println(\"获取缓存对象成功\");\n            return result;\n        } catch (Throwable t) {\n            System.err.println(\"缓存对象获取失败\" + t);\n            return null;\n        }\n    }\n\n    @Override\n    public Object removeObject(Object key) {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            redisTemplate.delete(getKey(key));\n//            System.out.println(\"删除缓存对象成功！\"+key);\n        } catch (Throwable t) {\n            System.err.println(\"删除缓存对象失败！\" + t);\n        }\n        return null;\n    }\n\n    @Override\n    public void clear() {\n        try {\n            RedisTemplate redisTemplate = getRedisTemplate();\n            Set<String> keys = redisTemplate.keys(getKeys());\n            redisTemplate.delete(keys);\n            System.out.println(\"出现新增、修改、删除操作，清空对应Mapper缓存======>\" + keys.size());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 按照一定规则标识key\n     */\n    private String getKey(Object key) {\n        String k=COMMON_CACHE_KEY + this.id + \":\" + DigestUtils.md5DigestAsHex(String.valueOf(key).getBytes());\n        return k;\n    }\n\n    /**\n     * 所有key\n     */\n    private String getKeys() {\n        return COMMON_CACHE_KEY + this.id + \":*\";\n    }\n\n    @Override\n    public int getSize() {\n        Long size = getRedisTemplate().boundHashOps(getId()).size();\n        return size == null ? 0 : size.intValue();\n    }\n\n    @Override\n    public ReadWriteLock getReadWriteLock() {\n        return readWriteLock;\n    }\n}\n```\n\n5. 然后我们在数据库查询的`mapper.xml`上添加上以下的配置，表示开启了数据库的二级缓存\n```xml\n<cache type=\"com.chen.mysqlredisdemo.cache.MybatisRedisCache\"></cache>\n```\n\n6. 然后在Controller文件中注入刚才写好的方法\n```java\n@Autowired\nStringRedisTemplate stringRedisTemplate;\n@Autowired\nRedisTemplate redisTemplate;\n```\n\n7. 最后在方法中判断Redis中是否有缓存，如果有就从Redis中取数据，否则就到数据库进行查找\n```java\n@RequestMapping(\"/selectForOne/{sId}\")\n    public Student selectStudentForOne(@PathVariable int sId){\n        String key = \"MYBATIS:\" + \"com.chen.mysqlredisdemo.StudentMapper:\"+sId;\n        ValueOperations<String, Student> operations = redisTemplate.opsForValue();\n        boolean hasKey = redisTemplate.hasKey(key);\n        if (hasKey) {\n            System.out.println(\"缓存输出\");\n            Student student = operations.get(key);\n            return student;\n        }else {\n            Student student = studentService.selectStudentForOne(sId);\n            operations.set(key, student);//把数据放入缓存\n            return student;\n        }\n    }\n```","tags":["java","redis"],"categories":["java","数据库","redis","redis"]},{"title":"算法学习_设计有序流","url":"/2021/09/26/2021-09-26-算法学习_设计有序流/","content":"\n# 设计有序流\n\n## 题目\n[lettcode-1656题](https://leetcode-cn.com/problems/design-an-ordered-stream/) \n难度：简单![]( https://i.bmp.ovh/imgs/2021/09/3e508439a8f7dbe3.png)\n\n\n## 解题思路\n既然是一个有序流，那么我们就可以将其存储到一个数组中，然后通过数组下标对所在的值进行访问。所以我们首先创建一个长度为n+1的数组，将value的值存在其中。\n将下标指针的值设置为1，然后在执行时进行循环加1\n\n接下来就是循环读取的过程：\n当我们在数组中插入一个数据的时候，就判断一个数组下标是否小于n，以及当前下标处的value值是否不为空，如果不为空我们就进入循环，将其存到一个新的集合中，并将其输出。\n如果为空的时候就不执行方法，继续往数组中添加value\n直到下标不小于n为止\n\n## 具体代码\n```java\nclass OrderedStream {\n\n    private String[] arr;\n    private int n;\n    private int ptr;\n\n    // 构造函数\n    public OrderedStream(int n) {\n    \t//因为数组的下标n从0开始，所以数组的长度为n+1\n        this.arr=new String[n+1];\n        this.n=n;\n        this.ptr=1;\n    }\n\n    public List<String> insert(int idKey, String value) {\n        //将value存到数组中\n        arr[idKey]=value;\n\n        //创建一个新的数组\n        List<String> res=new ArrayList<>();\n        //循环读取arr数组，将其中的值写到res数组中\n        //当arr[]为null时，不进入循环\n        while (ptr<=n&&arr[ptr]!=null){\n            res.add(arr[ptr]);\n            ptr++;\n        }\n        return res;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"算法学习_设计停车系统","url":"/2021/09/26/2021-09-26-算法学习_设计停车系统/","content":"\n# 设计停车系统\n\n## 题目\n[lettcode-1603题](https://leetcode-cn.com/problems/design-parking-system/) \n难度：简单![]( https://s3.bmp.ovh/imgs/2021/09/a5c6d4d87d542ba7.png )\n\n\n## 解题思路\n每种车都有每种车所对应的一个车位，而且不能停到其他车的车位上面去，所以说我们需要三个变量将每种车的车位数量存起来。\n然后在有新车进来时，判断车辆的类型，然后查找相应的停车位，如果有车位就返回一个true，相当于停车成功，然后该类型的车位减去一个，如果车位为0，则不允许停车，返回false\n\n## 具体代码\n```java\nclass ParkingSystem {\n\n    int big;\n    int medium;\n    int small;\n    // 构造函数\n    public ParkingSystem(int big, int medium, int small) {\n        this.big=big;\n        this.medium=medium;\n        this.small=small;\n    }\n\n    public boolean addCar(int carType) {\n        if (carType==1){\n            if (this.big>0){\n                this.big--;\n                return true;\n            }\n        }else if (carType==2){\n            if (this.medium>0){\n                this.medium--;\n                return true;\n            }\n        }else if (carType==3){\n            if (this.small>0){\n                this.small--;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```","tags":["算法"],"categories":["算法"]},{"title":"java栈","url":"/2021/09/25/2021-09-25-java栈/","content":"\n# java栈\n\n栈是一个先进后出的数据结构，想要自己实现一个栈，要求这个栈具有push()，pop()——返回栈顶并出栈，peek()——返回栈顶不出栈，isEmpty()等方法。\n\n## 1.1、手动实现一个栈的多种方式\n1. 采用数组来实现栈\n```java\nimport java.util.Arrays;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/25 19:59\n * @since 1.0\n */\nclass Stack1<T> {\n\n    // 实现栈的数组\n    private Object[] stack;\n    // 数组大小\n    private int size;\n\n    Stack1(){\n        stack=new Object[10];\n    }\n\n    // 判断数组是否为空\n    public boolean isEmpty(){\n        if (size==0){\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    // 返回栈顶元素\n     public T peek(){\n        T t=null;\n        if (size>0){\n            t= (T) stack[size-1];\n        }\n        return t;\n     }\n\n     // 返回栈顶并出栈\n     public T pop(){\n        T t=peek();\n        if(size>0){\n            stack[size-1]=null;\n            size--;\n        }\n        return t;\n     }\n\n     // 扩容\n    public void expandCapacity(int size){\n        int len=stack.length;\n        if (size>len){\n            size=size*3/2+1;\n            stack= Arrays.copyOf(stack,size);\n        }\n    }\n\n    public void push(T t){\n        expandCapacity(size+1);\n        stack[size]=t;\n        size++;\n    }\n}\n\npublic class ArrayStack {\n    public static void main(String[] args) {\n        Stack1<String> stringStack1=new Stack1<>();\n        System.out.println(stringStack1.peek());\n        System.out.println(stringStack1.isEmpty());\n        stringStack1.push(\"java\");\n        stringStack1.push(\"chenyc2021@qq.com\");\n        stringStack1.push(\"gogogo\");\n        System.out.println(stringStack1.pop());\n        System.out.println(stringStack1.isEmpty());\n        System.out.println(stringStack1.peek());\n    }\n}\n```\n\n2. 采用链表来实现\n```java\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 0:49\n * @since 1.0\n */\nclass Stack2<T> {\n    // 定义一个链表\n    class Node<T> {\n        private T t;\n        private Node next;\n    }\n\n    private Node<T> head;\n\n    // 构造函数\n    Stack2() {\n        head = null;\n    }\n\n    // 入栈\n    public void push(T t) {\n        if (t == null) {\n            throw new NullPointerException(\"参数不能为空\");\n        }\n        if (head == null) {\n            head = new Node<T>();\n            head.t = t;\n            head.next = null;\n        } else {\n            Node<T> temp = head;\n            head = new Node<T>();\n            head.t = t;\n            head.next = temp;\n        }\n    }\n\n    // 出栈\n    public T pop() {\n        T t = head.t;\n        head = head.next;\n        return t;\n    }\n\n    // 栈顶元素\n    public T peek() {\n        T t = head.t;\n        return t;\n    }\n\n    //判断栈是否为空\n    public boolean isEmpty() {\n        if (head == null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\npublic class LinkStack {\n    public static void main(String[] args) {\n        Stack2 stack = new Stack2();\n        System.out.println(stack.isEmpty());\n        stack.push(\"Java\");\n        stack.push(\"is\");\n        stack.push(\"beautiful\");\n        System.out.println(stack.peek());\n        System.out.println(stack.peek());\n        System.out.println(stack.pop());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n        System.out.println(stack.pop());\n        System.out.println(stack.isEmpty());\n    }\n}\n```\n\n3. 采用LinkedList实现栈\n```java\n import java.util.LinkedList;\n\n/**\n * @author George\n * @project testDemo\n * @package abc\n * @date 2021/9/26 9:39\n * @since 1.0\n */\n\nclass Stack3<T>{\n    // 构建一个linkedLIst集合\n    private LinkedList<T> ll=new LinkedList<>();\n\n    // 判断栈是否为空\n    public boolean isEmpty(){\n        return ll.isEmpty();\n    }\n\n    // 入栈\n    public void push(T t){\n        ll.addFirst(t);\n    }\n\n    //出栈\n    public T pop(){\n        return ll.removeFirst();\n    }\n\n    // 栈顶元素\n    public T peek(){\n        T t=null;\n        if (!ll.isEmpty()){\n            t=ll.getFirst();\n        }\n        return t;\n    }\n\n}\npublic class LinkedStack {\n    public static void main(String[] args) {\n        Stack3<String> stringStack3=new Stack3<>();\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n        stringStack3.push(\"java\");\n        stringStack3.push(\"is\");\n        stringStack3.push(\"beautiful\");\n        System.out.println(stringStack3.peek());\n        System.out.println(stringStack3.pop());\n        System.out.println(stringStack3.isEmpty());\n        System.out.println(stringStack3.peek());\n    }\n}\n```\n\n## 1.2、栈的应用\n\n在java中，栈是一种很重要的数据结构，如以下的很多场景都应用到了栈\n- 符号匹配\n- 中缀表达式变为后缀表达式\n- 计算后缀表达式\n- 实现函数的嵌套调用\n- HTML和XML中的标签匹配\n- 网页浏览器中以访问界面的历史记录\n\n例如：\n\n1. 符号匹配\n在编写程序的过程中，我们经常会遇到诸如圆括号“()”与花括号“{}”，这些符号都必须是左右匹配的，这就是我们所说的符合匹配类型，当然符合不仅需要个数相等，而且需要先左后右的依次出现，否则就不符合匹配规则，如“)(”，明显是错误的匹配，而“()”才是正确的匹配。有时候符合如括号还会嵌套出现，如“9-(5+(5+1))”,而嵌套的匹配原则是一个右括号与其前面最近的一个括号匹配，事实上编译器帮我检查语法错误是也是执行一样的匹配原理，而这一系列操作都需要借助栈来完成，接下来我们使用栈来实现括号”()”是否匹配的检测。\n判断原则如下（str=”((5-3)*8-2)”）：\n\na.设置str是一个表达式字符串，从左到右依次对字符串str中的每个字符char进行语法检测，如果char是，左括号则入栈，如果char是右括号则出栈(有一对匹配就可以去匹配一个左括号，因此可以出栈)，若此时出栈的字符char为左括号，则说明这一对括号匹配正常，如果此时栈为空或者出栈字符不为左括号，则表示缺少与char匹配的左括号，即目前不完整。\n\nb.重复执行a操作，直到str检测结束，如果此时栈为空，则全部括号匹配，如果栈中还有左括号，是说明缺少右括号。\n\n实现代码如下：\n```java\npublic class CheckExpression {\n\n  public static String isValid(String expstr)\n  {\n      //创建栈\n      LinkedStack<String> stack = new LinkedStack<>();\n\n      int i=0;\n      while(i<expstr.length())\n      {\n          char ch=expstr.charAt(i);\n          i++;\n          switch(ch)\n          {\n              case '(': stack.push(ch+\"\");//左括号直接入栈\n                  break;\n              case ')': if (stack.isEmpty() || !stack.pop().equals(\"(\")) //遇见右括号左括号直接出栈\n                  return \"(\";\n          }\n      }\n      //最后检测是否为空,为空则检测通过\n      if(stack.isEmpty())\n          return \"check pass!\";\n      else\n          return \"check exception!\";\n  }\n\n  public static void main(String args[])\n  {\n      String expstr=\"((5-3)*8-2)\";\n      System.out.println(expstr+\"  \"+isValid(expstr));\n  }\n}\n```\n","tags":["数据结构"],"categories":["数据结构"]},{"title":"准备阅读小米十年纪念《一往无前》","url":"/2021/08/27/2021-08-27-准备阅读小米十年纪念《一往无前》/","content":"\n# 准备阅读小米十年纪念《一往无前》\n\n作为一个不太资深的老米粉，自从小米发布新书《一往无前》以来一直想阅读一下，感受一下大厂发展的心路历程，但是一直都没有提上日程，而今天决定正式开始阅读此书，但是可能耗时会较长，现在这里做一个标记，阅读完毕务必完成一篇读后感。\n\n---\n\n2021.09.21 因为一直都在面试，所以阅读计划得往后推迟一点了。","tags":["随笔"],"categories":["随笔"]},{"title":"对SpringIOC的理解","url":"/2021/08/26/2021-08-26-对SpringIOC的理解/","content":"\n# 对SpringIOC的理解\n\n## 1、何为IOC\n​\tIOC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好IOC呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来分析一下\n\n### 1.1 谁控制谁，控制什么\n\n​\t传统Java程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建；谁控制谁？当然是IOC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）\n\n### 1.2 为何是反转，哪些方面反转了\n\n​\t有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\n\n### 1.3 图例说明\n\n传统程序设计下图，都是主动去创建相关对象然后再组合起来：\t\n\n![]( https://s3.bmp.ovh/imgs/2021/08/38929d2b7cf05cd7.jpg )\n\n当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如下图所示：\n\n![]( https://s3.bmp.ovh/imgs/2021/08/c7705f5db3bbd643.png )\n\n## 2、IOC能做什么\n\n​\tIOC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。\n　　其实IOC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IOC/DI思想中，应用程序就变成被动的了，被动的等待IOC容器来创建并注入它所需要的资源了。\n　　IOC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。\n\n## 3、IOC和DI\n\n​\tDI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来分析一下：\n\n- 谁依赖于谁：当然是应用程序依赖于IOC容器；\n- 为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源；\n- 谁注入谁：很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象；\n- 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。\n\n\tIOC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IOC而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。\n\t\n## 4、对IOC和DI的理解\n\n### 4.1、IoC(控制反转)\n　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。\n　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\n\n### 4.2、DI(依赖注入)\n　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。\n　　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。\n　　\n　　\n## 5、原文地址\nhttps://www.iteye.com/blog/jinnianshilongnian-1413846","tags":["java"],"categories":["java"]},{"title":"最近一段时间的学习总结","url":"/2021/08/20/2021-08-20-最近一段时间的学习总结/","content":"\n# 最近一段时间的学习总结\n\n## 项目部分\n\n1. 完成了学生宿舍系统的答辩\n2. 成功将学生宿舍为系统部署到了服务器上\n3. 准备进行学生宿舍系统的小程序的设计，但是实在是没有时间\n4. 完成了国医堂小程序的开发(React+Taro+Taro UI)\n5. 完成了小程序API的开发(Vue+SpringBoot+MyBatis-Plus)\n6. 国医堂小程序后台开发完毕(VUE+SpringBoot+MyBatis-Plus+Element-UI)\n7. 准备进行中医药门户或者桂林医学院报修系统开发环境的搭建\n\n## 框架部分\n\n1. 学习了SpringSecurity，并完成了Session以及Token两种情况下的应用Demo\n2. MyBatis-Plus逆向工程(代码生成器)\n3. Shiro的基本使用\n4. 入门Activiti(工作流)\n5. 准备学些RabbitMQ、\n6. MyBatis-Plus逆向工程3.5.0版本之之前是setting模式，之后是building模式\n7. 入门了React以及Vue两个有名的前端框架的使用\n8. ElementUI，LayUI，Bootstrap等UI的使用\n\n## 基础知识\n\n1. 复习了下AOP思想，并准备使用到日志中\n2. HashMap和HashTable的区别\n\n## 服务器\n\n1. 手动将web项目部署到阿里云服务器上\n2. 复习了Linux的指令\n\n## 备注\n\n看到同学面试京东所回答的问题，以及其他同学所总结的知识点，感觉自己和别人相比有很大的进步空间","tags":["学习总结"],"categories":["随笔","学习总结"]},{"title":"shiro安全框架","url":"/2021/08/01/2021-08-01-shiro安全框架/","content":"\n# shiro安全框架\n\n## 1、简述\nshiro是apache公司所出品的开源安全框架\n其可以用于：\n1. 处理身份认证\n2. 授权\n3. 企业会话管理和加密\n\n相对于Spring security来说更加简单，使用也更加灵活\n\n在使用shiro的时候可以不依赖于任何容器，既可以在javaSE下使用，同样可以在JavaEE下使用\n\n## 2、架构\n\n1. 使用用户的登录信息构建令牌\n```java\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\n\n```\ntoken可以理解为一个用户令牌，等于的过程可以理解为shiro检验用户令牌是否具有合法的身份以及相关的权限\n2. 执行登录\n\n```java\nSecurityUtils.setSecurityManager(securityManager); // 注入SecurityManager\nSubject subject = SecurityUtils.getSubject(); // 获取Subject单例对象\nsubject.login(token); // 执行登录\n```\nshiro中最核心的部分就是securityManger，它主要负责安全认证和授权。当我们在使用这个框架的时候，shiro已经将一切的操作封装成一个盒子了，我们在使用的时候可以把它当成一个黑盒来进行使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject，翻译过来就是项目的意思，他是一个需要通过shiro保护的一个抽象概念。\n通过1令牌和项目的登录关系，保证了我们的安全。\n\n3. 判断用户\n\n这一步中的内容shiro无法帮我们进行实现，我们只有通过最原始的手段来实现登录用户的判断，就是查询数据库。\n\n例如：\n```java\nif (!token.getUsername().equals(name)) {\n  //shiro底层会抛出一个异常\n    return null;\n}\n//判断密码\nreturn new SimpleAuthenticationInfo(\"\", password, \"\");\n```\n第一个if语句中首先会判断数据库中查到的name于输入的用户名2是否一致，如果不一致，则会抛出一个异常\n然后SimpleAuthenticationInfo中可以用于判断密码的正确性，同样是从数据库查出来的数据做对比。\n\n## 3、实现Realm\n\n1. 创建一个Realm\n\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息，但是Realm并不止局限于数据的存取，其中还有很多认证授权校验相关的代码  \n我们可以自定义一个MyRealm，用于我们的项目之中，但是前提是这个类必须继承于AuthorizingRealm父类，然后实现两个方法  \nAuthorizationInfo doGetAuthorizationInfo以及AuthenticationInfo doGetAuthenticationInfo  \nAuthenticationInfo代表了用户的角色信息集合，AuthorizationInfo代表了角色的权限信息集合。如此一来，当设计人员对项目中的某一个url路径设置了只允许某个角色或具有某种权限才可以访问的控制约束的时候，Shiro就可以通过以上两个对象来判断。\n\n我们也可以简单看作：  \n**doGetAuthenticationInfo()** 方法：用来验证当前登录的用户，获取认证信息。  \n**doGetAuthorizationInfo()** 方法：为当前登录成功的用户授予权限和分配角色。\n\n2. 从数据库查询数据\n\n在数据库中查询登陆人信息的时候，仅仅需要查询用户的id，这时还未涉及到密码，也就是说即使用户输入的密码不正确，照样可以查询出该用户。\n然后，将该用户的相关信息封装到authcInfo中并返回给Shiro接下来就该Shiro上场了，将封装的用户信息与用户的输入信息（用户名、密码）进行对比、校验（注意，这里对密码也要进行校验）。校验通过则允许用户登录，否则跳转到指定页面。\n\n## 4、Shiro配置\n\n1. 在ShiroConfig中配置Realm\n\n```java\n@Bean(name=\"MyRealm\")\n  public MyRealm myRealm() {\n    return new MyRealm();\n  }\n```\n2. 配置安全管理器SecurityManager\n\n```java\n@Bean(name=\"securityManager\")\n  public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"MyRealm\") MyRealm myRealm) {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n    //关联Realm\n    securityManager.setRealm(myRealm);\n    return securityManager;\n  }\n```\n当我们配置安全管理器的时候，需要将前面的Realm添加进来，这样子才可以访问到Realm\n\n3. 配置Shiro过滤器\n\nshiro中自带好了配置的过滤器，我们在使用之前需要将其进行导入\n\n```java\nShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n//设置安全管理器\nshiroFilterFactoryBean.setSecurityManager(securityManager);\n//添加Shiro内置过滤器\n/*\nShiro内置过滤器，可以实现权限相关的拦截器\n常用的有：\nanon：无需认证就能访问\nauthc：必须认证才能访问\nuser：必须拥有 “记住我” 功能才能使用\nperms：拥有对某个资源的权限才能访问\nrole： 拥有对某个角色权限才能访问\n*/\nLinkedHashMap<String, String> filterMap = new LinkedHashMap<String,String>();\n//这里我们要将不进行拦截的放在前面\nfilterMap.put(\"/login\", \"anon\");\nfilterMap.put(\"/*\", \"authc\");\n\n//最后设置验证失败的时候所跳转的界面\nshiroFilterFactoryBean.setLoginUrl(\"/toLogin\");\n```\n此时当我们未登陆的时候，点击被拦截的模块，就会跳到我们所指定的网页，而没有拦截的网页则可以正常显示。","tags":["shiro"],"categories":["java","shiro","权限管理"]},{"title":"springboot+mybatis整合支付宝支付","url":"/2021/07/22/2021-07-22-springboot+mybatis整合支付宝支付/","content":"\n# springboot+mybatis整合支付宝支付\n\n## 准备支付宝沙箱环境\n\n---\n需要三个网站来准备支付宝的沙箱环境：\n1. [支付宝开放平台](https://opendocs.alipay.com/open/54/104506)\n2. [开放平台-沙箱环境](https://openhome.alipay.com/platform/appDaily.htm?tab=info)\n3. [miniU研发工作室](https://openhome.alipay.com/platform/appDaily.htm?tab=info)\n\n具体配置过程百度即可\n---\n\n## bean类\n\n```\npackage cn.edu.guet.bean;\n\n/**\n * @author George\n * @project DormitorySystem\n * @package cn.edu.guet.bean\n * @date 2021/7/22 11:35\n * @since 1.0\n */\npublic class AlipayBean {\n    /**\n     * 商户订单号，必填\n     *\n     */\n    private String out_trade_no;\n    /**\n     * 订单名称，必填\n     */\n    private String subject;\n    /**\n     * 付款金额，必填\n     * 根据支付宝接口协议，必须使用下划线\n     */\n    private String total_amount;\n    /**\n     * 商品描述，可空\n     */\n    private String body;\n    /**\n     * 超时时间参数\n     */\n    private String timeout_express= \"10m\";\n    /**\n     * 产品编号\n     */\n    private String product_code= \"FAST_INSTANT_TRADE_PAY\";\n\n    public String getOut_trade_no() {\n        return out_trade_no;\n    }\n\n    public void setOut_trade_no(String out_trade_no) {\n        this.out_trade_no = out_trade_no;\n    }\n\n    public String getSubject() {\n        return subject;\n    }\n\n    public void setSubject(String subject) {\n        this.subject = subject;\n    }\n\n    public String getTotal_amount() {\n        return total_amount;\n    }\n\n    public void setTotal_amount(String total_amount) {\n        this.total_amount = total_amount;\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n    public void setBody(String body) {\n        this.body = body;\n    }\n\n    public String getTimeout_express() {\n        return timeout_express;\n    }\n\n    public void setTimeout_express(String timeout_express) {\n        this.timeout_express = timeout_express;\n    }\n\n    public String getProduct_code() {\n        return product_code;\n    }\n\n    public void setProduct_code(String product_code) {\n        this.product_code = product_code;\n    }\n}\n```\n\n## alipayConfig类\n\n```\npackage cn.edu.guet.config;\n\nimport java.io.FileWriter;\nimport java.io.IOException;\n/**\n * @author George\n * @project DormitorySystem\n * @package cn.edu.guet.config\n * @date 2021/7/22 13:16\n * @since 1.0\n */\n\npublic class AlipayConfig {\n\n//↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\n    // 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号\n    public static String app_id = \"2021000117643373\";\n    // 商户私钥，您的PKCS8格式RSA2私钥\n    public static String merchant_private_key = \"\";\n    // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。\n    public static String alipay_public_key = \"\";\n    // 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问\n    public static String notify_url = \"http://localhost:8082\";\n    // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问\n    public static String return_url = \"http://localhost:8082\";\n    // 签名方式\n    public static String sign_type = \"RSA2\";\n    // 字符编码格式\n    public static String charset = \"utf-8\";\n    // 支付宝网关\n    public static String gatewayUrl = \"https://openapi.alipaydev.com/gateway.do\";\n    // 支付宝网关\n    public static String log_path = \"C:\\\\\";\n\n//↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\n\n    /**\n     * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库）\n     * @param sWord 要写入日志里的文本内容\n     */\n    public static void logResult(String sWord) {\n        FileWriter writer = null;\n        try {\n            writer = new FileWriter(log_path + \"alipay_log_\" + System.currentTimeMillis()+\".txt\");\n            writer.write(sWord);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n```\n\n## controller控制器\n\n**支付**\n```\n@Controller\npublic class AlipayController {\n\n    @RequestMapping(\"/pay\")\n    @ResponseBody\n    public void payController(HttpServletRequest request, HttpServletResponse response) throws IOException, AlipayApiException {\n        // 获取初始化的AliPayClient\n        AlipayClient alipayClient = new DefaultAlipayClient(\n                AlipayConfig.gatewayUrl,\n                AlipayConfig.app_id,\n                AlipayConfig.merchant_private_key,\n                \"json\",\n                AlipayConfig.charset,\n                AlipayConfig.alipay_public_key,\n                AlipayConfig.sign_type);\n        // 设置请求参数\n        AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();\n        alipayRequest.setReturnUrl(AlipayConfig.return_url);\n        alipayRequest.setNotifyUrl(AlipayConfig.notify_url);\n        //商户订单号，商户网站订单系统中唯一订单号，必填\n        String out_trade_no = new String(request.getParameter(\"WIDout_trade_no\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //付款金额，必填\n        String total_amount = new String(request.getParameter(\"WIDtotal_amount\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //订单名称，必填\n        String subject = new String(request.getParameter(\"WIDsubject\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        //商品描述，可空\n        String body = new String(request.getParameter(\"WIDbody\").getBytes(\"ISO-8859-1\"),\"UTF-8\");\n        alipayRequest.setBizContent(\"{\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\"\n                + \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\"\n                + \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\"\n                + \"\\\"body\\\":\\\"\"+ body +\"\\\",\"\n                + \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"}\");\n        //若想给BizContent增加其他可选请求参数，以增加自定义超时时间参数timeout_express来举例说明\n        //alipayRequest.setBizContent(\"{\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\"\n        //\t\t+ \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\"\n        //\t\t+ \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\"\n        //\t\t+ \"\\\"body\\\":\\\"\"+ body +\"\\\",\"\n        //\t\t+ \"\\\"timeout_express\\\":\\\"10m\\\",\"\n        //\t\t+ \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"}\");\n        //请求参数可查阅【电脑网站支付的API文档-alipay.trade.page.pay-请求参数】章节\n\n        //请求\n        String result = alipayClient.pageExecute(alipayRequest).getBody();\n\n        //输出\n        response.setContentType(\"text/html;charset=\"+AlipayConfig.charset);\n        response.getWriter().write(result);\n        response.getWriter().flush();\n        response.getWriter().close();\n    }\n}\n```\n\n","tags":["java","SpringBoot","MyBatis"],"categories":["java","SpringBoot","MyBatis"]},{"title":"SpringBoot将图片存储到数据库","url":"/2021/07/21/2021-07-21-Springboot存储图片到数据库/","content":"\n# SpringBoot将图片存储到数据库\n\n## 存储方式\n将图片转化为blob的二进制格式，然后存储到数据库即可，从数据中取出时，将blob格式的二进制文字从数据库中取出，用Object的方式来获取，然后转化为图片的格式，即可在屏幕上显示\n\n## 上传图片\n\n**Controller层**\n\n```\n@PostMapping(\"/add/image\")\n@ResponseBody\npublic String addImage(@RequestParam(\"file\") MultipartFile file,@RequestParam(\"id\") Integer id) throws Exception{\n    if(!file.isEmpty()){\n        BASE64Encoder encoder = new BASE64Encoder();\n        String image = encoder.encode(file.getBytes());\n        TestPo testPo = new TestPo();\n        testPo.setId(id);\n        testPo.setImage(image);\n        testService.addImage(testPo);\n    }\n    return \"ok\";\n}\n```\nControoler层主要对上传的图片文件进行处理，当上传的图片不为空的时候，定义一个字符串加密算法，然后将文件的字节编码进行加密，再定义一个实体类对象，将id以及加密之后的文件发送给业务层。\n\n**Service层**\n\n```\npublic String addImage(TestPo testPo){\n    testMapper.insertImage(testPo);\n    return \"ok\";\n}\n```\n接受Controller的请求并返回对应的类型\n\n**Mapper接口**\n\n```\n@Mapper\npublic interface TestMapper {\n    void insertImage(TestPo testPo);\n}\n```\n\n**Mapper.xml**\n\n```\n<insert id = \"insertImage\" parameterType=\"cn.edu.guet.bean.TestPo\">\n    insert into image(id,image) values(#{id},#{image})\n</insert>\n```\n执行sql语句，进行文件的存储，存储为BLOB格式。\n\n**html页面**\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form action=\"http://localhost:8081/add/image\" method=\"post\" enctype=\"multipart/form-data\">\n    <input type=\"text\" name=\"id\" /><br/>\n    <input type=\"file\" name=\"file\" /><br/>\n    <input type=\"submit\" name=\"\" id=\"\" value=\"提交\" />\n</form>\n</body>\n</html>\n```\n![image](https://i.bmp.ovh/imgs/2021/07/f2e9299cb07318f4.png)\n\n## 读取图片\n\n**Controller层**\n\n```\n@GetMapping(\"/get/image\")\n@ResponseBody\npublic void getImage(@RequestParam(\"id\") Integer id, HttpServletResponse response) throws Exception{\n    testService.getImage(id,response);\n}\n```\n主要是接收url请求，根据id给servce层发送请求\n\n**Service层**\n\n```\npublic String getImage(Integer id, HttpServletResponse response){\n    try {\n        TestPo testPo = testMapper.selectImageById(id);\n        byte[] image = (byte[])testPo.getImage();\n        String value = new String(image,\"UTF-8\");\n        BASE64Decoder decoder = new BASE64Decoder();\n        byte[] bytes = decoder.decodeBuffer(value);\n        for(int i=0;i<bytes.length;i++){\n            if(bytes[i]<0){\n                bytes[i]+=256;\n            }\n        }\n        response.setContentType(\"image/jpeg\");\n        ServletOutputStream out = response.getOutputStream();\n        out.write(bytes);\n        out.flush();\n        out.close();\n    }catch (Exception e){\n        e.printStackTrace();\n    }\n\n    return \"ok\";\n}\n```\nservice层对读取出来的二进制进行处理，用byte[]数据类型存储，然后将其转码成UTF-8的格式，此时我们可以得到想要的BASe64字节码，接着将其解码成为byte[]格式，只有这样才能生成图片，setContentType用于设置生成的图片的格式，然后通过流操作，将图片发送到Controller层，最后在前端显示出来\n\n**Maoopper接口**\n\n```\n@Mapper\npublic interface TestMapper {\n    TestPo selectImageById(Integer id);\n}\n```\n\n**Mapper.xml**\n\n```\n<select id=\"selectImageById\" parameterType=\"Integer\" resultType=\"cn.edu.guet.bean.TestPo\">\n    select * from image where id = #{id}\n</select>\n```\n\n**html界面**\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<img src=\"http://localhost:8081/get/image?id=2\" alt=\"Responsive image\">\n</body>\n</html>\n```\n![image](https://i.bmp.ovh/imgs/2021/07/c01afbdf281ae7d2.png)","tags":["java","SpringBoot"],"categories":["java","SpringBoot"]},{"title":"PL/SQL编程学习笔记","url":"/2021/07/13/2021-07-13-PLSQL学习笔记/","content":"\n# PL/SQL编程学习笔记\n## 显示执行结果\n```sql\nset serveroutput on;\n```\n\n## INSERT\n```sql\nDECLARE v_dept dept%ROWTYPE; \nBEGIN v_dept.deptno:=50; \nv_dept.loc:='BEIJING'; \nv_dept.dname:='DEV'; \nINSERT INTO dept VALUES v_dept;\nEND;\n```\n\n## UPDATE\n```sql\nDECLARE v_dept dept%ROWTYPE; \nBEGIN \nv_dept.deptno:=50; \nv_dept.loc:='TIANJIN'; \nv_dept.dname:='SALES'; \nUPDATE dept SET ROW=v_dept WHERE deptno=50; \nEND;\n```\n\n## DELECT\n```sql\nDECLARE v_emp emp%ROWTYPE; \nBEGIN \nSELECT * INTO v_emp FROM emp WHERE empno=7844; \nDELETE FROM emp WHERE deptno=v_emp.deptno; \nEND;\n```\n\n## 基础语句(SELECT)\n```sql\nDECLARE --声明部分\nv_name VARCHAR2(30);\nBEGIN  --执行部分\nSELECT ENAME INTO v_name FROM emp WHERE empno=7788;\ndbms_output.put_line('员工的名字：'||v_name);\nEXCEPTION --异常处理\nWHEN NO_DATA_FOUND THEN --当找不到DATA时\ndbms_output.put_line('找不到这个员工');\nEND; --结束\n/ --执行\n```\n\n- dbms_output == System.out\n- put_line == println\n- || == +\n- := 赋值符号\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618810809843.png)\n\n## %TYPE的使用\n- 自动匹配对应行的数据类型以及长度\n```sql\nDECLARE\nv_name emp.ename%TYPE; --自动给v_name匹配ename的类型\nBEGIN\nSELECT ename INTO v_name FROM emp WHERE empno=7788;\ndbms_output.put_line('员工的名字：'||v_name);\nEXCEPTION\nWHEN NO_DATA_FOUND THEN\ndbms_output.put_line('找不到这个员工');\nEND;\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618811436871.png)\n\n## %ROWTYPE的使用\n- TYPE只能一行一行地匹配类型，当我们查找多个数据时要写很多，不是很方便，所以这里我们使用%ROWTYPE来一次性匹配表里所有的行地类型\n\n```sql\nDECLARE\nv_emp emp%ROWTYPE;\nBEGIN\nSELECT * INTO v_emp FROM emp WHERE empno=7788;\ndbms_output.put_line('员工的名字：'||v_emp.ename|| '，薪水：'||v_emp.sal);\nEND;\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618812138968.png)\n\n\n\n## 游标(类似java中的迭代器)\n1. 游标的作用：游标通常用于处理多行记录的事务\n2. 游标里面存储了查询到的结果集，相当于一个工作区域\n3. 游标的分类：显式游标、隐式游标、REF游标\n\n### 隐式游标\n在PL/SQL中执行DML SQL时会自动创建隐式游标\n### 显式游标\n显式游标可用于处理返回多行数据的查询\n### REF游标\n用于在处理运行时才能确定的动态SQL查询的结果\n\n### 使用游标的步骤\n1. 声明游标\n\t- CURSOR cur_emp IS SELECT * FROM emp;\n2. 打开游标\n\t- OPEN cur_emp;\n3. 提取游标数据\n\t- FETCH cur_emp INTO v_emp;\n4. 关闭游标\n\t- CLOSE cur_emp;\n\n## 游标（简单循环）\n- 游标的作用：可以用于处理多行事务\n```sql\nDECLARE\nCURSOR cur_emp IS SELECT * FROM emp; --声明游标\nv_emp  emp%ROWTYPE;\nBEGIN\nOPEN cur_emp; --执行游标\nLOOP -- 简单循环\nFETCH cur_emp INTO v_emp; --提取游标中的数据放到变量中\nEXIT WHEN cur_emp%NOTFOUND; --%NOTFOUND游标地属性，循环推出的条件\ndbms_output.put_line('员工名字：'||v_emp.ename||'，薪水：'||v_emp.sal);\nEND LOOP; --循环停止\nCLOSE cur_emp; --关闭游标\nEND;\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618813038599.png)\n\n\n## WHILE循环\n\n```sql\nDECLARE\nCURSOR cur_emp IS SELECT * FROM emp;\nv_emp  emp%ROWTYPE;\nBEGIN\n  OPEN cur_emp;--执行游标\n  FETCH cur_emp INTO v_emp;--WHILE循环之前，必须先FETCH一次\n  WHILE cur_emp%FOUND LOOP --进入循环\n    dbms_output.put_line('员工名字：'||v_emp.ename||'，薪水：'||v_emp.sal);\n    FETCH cur_emp INTO v_emp; --提取游标中的数据\n  END LOOP; --结束循环\n  CLOSE cur_emp; --关闭游标\nEND;\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618813402019.png)\n\n## FOR循环\n\n```sql\nDECLARE\nCURSOR cur_emp IS SELECT * FROM emp;\ncur cur_emp%ROWTYPE;\nBEGIN\nFOR cur IN cur_emp LOOP\ndbms_output.put_line('员工名字：'||cur.ename||'，薪水：'||cur.sal);\nEND LOOP;\nEND;\n/\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618814102440.png)\n\n## 函数(命名块)\n\n- 函数可以重复使用\n- 函数实际上是封装在服务器上一段PLSQL代码片段。\n- 当函数没有参数时，可以不用加函数名后面的括号。\n\n### 函数的语法\n\n```sql\nCREATE [OR REPLACE] FUNCTION function_name \n(parameter1_name [mode] datatype \n    [DEFAULT|:=value]\n[, parameter2_name [mode] datatype \n    [DEFAULT|:=value],…])\nRETURN return_datatype \nAS|IS\n     /*Declarative section is here */\nBEGIN\n    /*Executable section is here*/ \nEXCEPTION\n    /*Exception section is here*/ \nEND [function_name];\n```\n\n### 函数的定义\n\n```sql\nCREATE OR REPLACE FUNCTION f1(v_count NUMBER) --定义函数的名称以及数据类型\nRETURN NUMBER   --定义函数的返回类型\nAS \t--相当于DECLARE，后面接定义的变量\n```\n\n### 函数的使用\n\n```sql\nSELECT f1('数据') from 表名;\n```\n\n通过这种方式可以简单多次使用函数中所封装的内容\n\n\n## 异常处理\n\n### 实例\n```sql\nDECLARE\nv_name VARCHAR2(30);\nBEGIN\nSELECT ENAME INTO v_name FROM emp;\ndbms_output.put_line('员工的名字：'||v_name);\nEXCEPTION\nWHEN NO_DATA_FOUND THEN\ndbms_output.put_line('找不到这个员工');\nWHEN OTHERS THEN --出现其他错误时\ndbms_output.put_line('XXXXX');\nEND;\n```\n\n- 执行结果：![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618811108639.png)\n\n### 预定义异常(有名称有编号的异常)\n\n- oracle官方已经写好的异常，在出现异常时我们可以直接使用，如：\n  1. NO_DATA_FOUND ：没有找到数据\n  2. TOO_MANY_ROWS：一个SELECT INTO语句匹配了多行数据\n  3. ZERO_DIVIDE：除数为0\n\n### 非预定义异常(有编号没有名称的异常)\n\n- 有一些异常，官方给他们分配了编号，但是没有为他们关联处理的方法，所以这是我们就需要自己定义一个异常，并与他的编号进行关联，才可以进行异常的处理。\n\n### 用户定义异常(啥都没有的异常)\n- 用户定义异常编号范围：-20999~-20000\n- 用户定义异常是指，有些操作并不会产生Oracle错误，但是从业务规则角度考虑，认为是一 \n  种错误。例如，执行UPDATE操作没有更新任何行时，不会引发Oracle错误，也不会产生异 \n  常，但是，有时需要开发人员为此操作产生一个异常，以便进行处理，即用户定义异常。\n- 用户自定义异常要对异常进行捕捉并抛出(RAISE)\n\n## 检验字符串是否可以转换成数值型(函数+异常处理)\n\n- to_number函数：类型转换函数可以将字符串转换成数字\n\n```sql\nCREATE OR REPLACE FUNCTION f1(v_num VARCHAR2) --定义函数\nRETURN NUMBER  --定义返回类型\nAS\n\tex_char2number EXCEPTION; --声明一个非预定义异常\n\tPRAGMA EXCEPTION_INIT (ex_char2number,-6502); --连接异常与异常处理\nBEGIN\n\tIF to_number(v_num)>=0 THEN\n\t\tRETURN 1\n\tELSE\n\t\tRAISE ex_char2number; --捕捉并抛出异常\n\tEND IF;\nEXCEPTION\n\tWHEN ex_char2number THEN--处理异常\n\t\tRETURN 0;\nEND;\n```\n\n## 存储过程(命名块)\n\n- 存储过程的语法与函数类似\n- 创建存储过程可以理解为相当于函数中的FUNCTION function_name 更换成PROCEDURE procedure_name\n- 两者其他部分都差不多\n\n### 存储过程的语法\n\n- 定义：\n\n```sql\nCREATE [OR REPLACE] PROCEDURE procedure_name\n(parameter1_name [mode] datatype \n    [DEFAULT|:=value]\n[, parameter2_name [mode] datatype \n    [DEFAULT|:=value],…])\nAS|IS\n   /*Declarative section is here */\nBEGIN\n   /*Executable section is here*/ \nEXCEPTION\n   /*Exception section is here*/ \nEND[procedure_name];\n```\n\n- 调用\n\n```sql\nBEGIN \n\tprocedure_name(parameter_list); \nEND;\n```\n\n### 例子\n\n```sql\nCREATE OR REPLACE PROCEDURE proc_transfer(v_empno NUMBER)\nAS\n  v_sal emp.sal%TYPE;\nBEGIN\n  SELECT sal INTO v_sal FROM emp WHERE empno=v_empno;\n  dbms_output.put_line('工资：'||v_sal);\nEND;\n```\n\n定义一个存储过程，用于查询员工的工资\n\n使用：\n```sql\nBEGIN \n  proc_transfer(7788); \nEND;\n```\n结果：\n![](C:\\Users\\swagg\\AppData\\Roaming\\Typora\\typora-user-images\\1618969132341.png)\n\n\n## 分页查询(SQL)\n### 实例\n\n```sql\nSELECT *\nFROM (SELECT rownum rn,t.* FROM (SELECT *FROM emp ORDER BY sal) t WHERE rownum<=10) \nWHERE rn>=5;\n```\n\n## 分页存储过程\n\n```sql\nCREATE OR REPLACE PROCEDURE proc_page(\n    v_tableName IN VARCHAR2,\n    v_rowsPerPage IN NUMBER,\n    v_currentPage IN NUMBER,\n    v_totalPage OUT NUMBER,\n    v_data OUT SYS_REFCURSOR--游标变量，游标：缓冲区，存了SQL语句所查询的内容\n)\nAS\nv_endRow NUMBER;\nv_startRow NUMBER;\nv_sql VARCHAR2(300);\nv_totalRows NUMBER;\nBEGIN\nv_endRow:=v_rowsPerPage*v_currentPage;\nv_startRow:=(v_currentPage-1)*v_rowsPerPage+1;\nv_sql:='SELECT * FROM (SELECT rownum rn,t.* FROM (SELECT * FROM '||v_tableName||') t WHERE rownum<='||v_endRow||') WHERE rn>='||v_startRow;\nOPEN v_data FOR v_sql;--游标和动态SQL绑定，已经执行了\nv_sql:='SELECT COUNT(*) FROM '||v_tableName;\nEXECUTE IMMEDIATE v_sql INTO v_totalRows;\nIF MOD(v_totalRows,v_rowsPerPage)=0 THEN\n\tv_totalPage:=v_totalRows/v_rowsPerPage;\nELSE\n\tv_totalPage:=(v_totalRows/v_rowsPerPage)+1;\nEND IF;\nEND;\n/\n```\n\n","tags":["数据库"],"categories":["数据库","PL/SQL"]},{"title":"过滤器(Filter)在Web中的应用","url":"/2021/07/01/2021-07-01-过滤器(Filter)在Web中的应用/","content":"\n# Java Web之过滤器(Filter)\n\n## 1、过滤器(Filter)\n\n过滤器，从字面意思上理解，就是用于过滤作用的工具。\n在Java web中，过滤器的作用是对Web资源进行拦截，经过处理之后，再交给下一步进行处理；而下一步可以是一个新的过滤器，也可以是一个service。\n\nFilter可认为是Servlet的一种“变种”，它主要用于对用户请求(HttpServletRequest)进行预处理,也可以对服务器响应(HttpServletResponse)进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：**Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。** \n\n## 2、可以用来干嘛？\n\n- 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。\n- 根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。\n- 在HttpServletResponse到达客户端之前，拦截HttpServletResponse。\n- 根据需要检查HttpServletResponse,也可以修改HttpServletResponse头和数据。\n\n## 3、Filter的类型\n\n- 用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。\n- 日志Filter：详细记录某些特殊的用户请求。\n- 负责解码的Filter：包括对非标准编码的请求解码。\n- Filter可拦截多个请求或响应；一个请求或响应也可被多个请求拦截。\n\n## 4、Filter在Web中的应用\n\n在java中创建一个 filter 其实很简单，只需要两个步骤：\n1. 创建Filter处理类(如：MyFiletr)实现javax.servlet.Filter接口；\n2. web.xml中配置Filter\n\n### 4.1、简单的记录日志的Filter\n简单的记录日志的Filter，这个Filter负责拦截所符合条件的用户请求，并将请求的信息记录在日志中。 \n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220310124857.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220310125444.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220310124925.png)\n\n总结：上面的程序实现了doFilter()方法，实现该方法就可以实现对用户请求进行预处理，也可以实现对服务器响应进行后处理--他们的分界线为是否调用了chain.doFilter(),执行该方法之前，即对用户请求进行预处理；执行该方法之后，即对服务器响应进行后处理。\n\n在上面的请求Filter中，仅在日志中记录请求的URL，对所有的请求都执行chain.doFilter (request,reponse)方法，当Filter对请求过滤后，依然将请求发送到目的地址。如果需要检查权限，可以在Filter中根据用户请求的HttpSession，判断用户权限是否足够。如果权限不够，直接调用重定向即可，无须调用chain.doFilter(request,reponse)方法。\n\n### 4.2、简单的认证登录Filter\n\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220310125537.png)\n![](https://fastly.jsdelivr.net/gh/chenyicai0819/MyImage/Imgs/20220310125602.png)\n\n\n## 5、总结\nFilter接口中有一个doFilter方法，当开发人员编写好Filter类实现doFilter方法，并配置对哪个web资源进行拦截后，WEB服务器每次在调用web资源的service方法之前(服务器内部对资源的访问机制决定的)，都会先调用一下filter的doFilter方法。\n\nFilter的生命周期和Servlet一样，Filter的创建和销毁也是由WEB服务器负责。不过与Servlet区别的是，它是1>在应用启动的时候就进行装载Filter类(与Servlet的load-on-startup配置效果相同)。2>容器创建好Filter对象实例后，调用init()方法。接着被Web容器保存进应用级的集合容器中去了等待着，用户访问资源。3>当用户访问的资源正好被Filter的url-pattern拦截时，容器会取出Filter类调用doFilter方法，下次或多次访问被拦截的资源时，Web容器会直接取出指定Filter对象实例调用doFilter方法(Filter对象常驻留Web容器了)。4>当应用服务被停止或重新装载了，则会执行Filter的destroy方法，Filter对象销毁。注意：init方法与destroy方法只会直接一次。\n\nFilter不仅可以通过url-pattern来指定拦截哪些url匹配的资源。而且还可以通过servlet-name来指定拦截哪个指定的servlet(专门为某个servlet服务了,servlet-name对应Servlet的相关配置)。\n\n","tags":["java"],"categories":["java"]},{"title":"算法学习_罗马数字转整数","url":"/2021/06/28/2021-06-28-算法学习_罗马数字转整数/","content":"\n# 罗马数字转整数\n\n## 题目\n[lettcode-13题](https://leetcode-cn.com/problems/roman-to-integer/) \n难度：简单\n![]( https://i.bmp.ovh/imgs/2021/06/ed551dd42d8355cf.png )\n\n## 解题思路\n对于每个罗马符号所对应的数值，我们可以将其用一个HashMap存起来，将其字符作为key，以及数值为相应的value\n\n在方法中对输入的字符串的所有字符进行遍历，get到所对应的值，并拿到它的后一位数的值，如果当前符号的值大于后一位符号的值，则进行＋运算，否则-运算。\n\n## 具体代码\n```java\n//leetcode项目\nclass Solution {\n    Map<Character,Integer> map=new HashMap<Character,Integer>();\n    public int romanToInt(String s) {\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int ans = 0;\n        int n = s.length();\n        for (int i = 0; i < n; ++i) {\n            int value = map.get(s.charAt(i));\n            if (i < n - 1 && value < map.get(s.charAt(i + 1))) {\n                ans -= value;\n            } else {\n                ans += value;\n            }\n        }\n        return ans;\n    }\n}\n```","tags":["算法","HashMap"],"categories":["算法","HashMap"]},{"title":"记录博客主页的搭建(二)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(二)/","content":"\n# 记录博客主页的搭建(二)\n\n## 完成上篇文章的所有步骤\n主题是个性化个人博客的很重要的一个模块，当然hexo默认也有一个主题，但是我们可以到[hexo的主题商城](https://hexo.io/themes/)中下载更多我们喜欢的主题。\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/e2ca448dcc957f2e.jpg )\n\n## 选择想要的主题\n\n点击大图可以进行预览，点击名称就可以进入主题的GitHub仓库，就可以进行clone了\n\n然后在本地clone主题的仓库，放到hexo目录的themes文件夹中，再去修改_config.yml文件，就可以应用这个主题了\n\n将theme后面的名称改为刚才clone的文件夹名称，就可以应用主题了\n```\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: hexo-theme-aircloud\n```\n\n## 创建标签以及存档\n\n默认的主题是不带有标签和介绍的，这时候需要在博客根目录的source文件夹下建立tags文件夹和about文件夹。\n\n*注：建议不要直接新建文件，而是采用 hexo 的 hexo new page tags 和 hexo new page about 的方式新建文件，这样可以被 hexo 索引到。*\n\n创建好之后在两个文件夹的index.md中分别输入以下内容\n```\n---\nlayout: \"tags\"\ntitle: \"Tags\"\n---\n```\n```\n---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ncomments: true\n---\n```\n再次打开主页就会看到生成了两个新的列表\n\n## 更换头像以及网站logo\n\n在博客根目录的 source 文件夹下建立 img 文件夹\n*采用 hexo 的 hexo new page img *\n\n然后并将头像文件命名为avatar.jpg，logo文件命名为favicon.ico\n\n然后修改_config.yml文件，增加以下内容\n```\nsidebar-avatar: img/avatar.jpg\n```\n就可以了\n\n## 网站标题\n在 _config.yml 文件中，增加以下内容\n```\nSEOTitle: George'blog\n```\n冒号后面修改成你想要的名字就可以了\n\n## 签名\n比如最顶端的签名，我们同样可以自定义\n\n![]( https://ftp.bmp.ovh/imgs/2021/06/89d7894724475826.jpg )\n\n只要在_config.yml文件，修改以下内容即可\n```\nsubtitle: 你想要的签名\n```\n\n## 搜索功能\n\n搜索功能同样是不自带的，我们在安装搜索功能之前，首先要安装一个插件\n在git中输入以下命令进行安装\n```\nnpm i hexo-generator-search --save\n```\n\n然后在_config.yml文件中增加以下内容即可\n```\nsearch:\n  path: search.json\n  field: post\n```\n\n## 社交网络\n底部的社交网络我们可以自行修改，但是只能在官方限制的范围内进行修改\n编辑根目录的 _config.yml 文件，增加：\n```\n# SNS settings\n# 一些社交平台地址，支持以下几种：\nweibo_username:     5676314204\nzhihu_username:     swaggy-chen\ngithub_username:    chenyicai0819\ntwitter_username:   George chan\n```\n*还有一些其他的社交网络可以参考官方文档*\n\n## 赞赏功能\n\n我们同样可以在我们的博客中添加一个赞赏功能\n只要在img文件夹中增加收款码图片，并命名为donate.jpg\n然后在 _config.yml 文件中增加以下内容，即可在在每篇文章下面增加一个赞赏功能\n```\ndonate:\n  img: img/donate.jpg\n  content: 感谢鼓励\n```\n\n## 修改用户名\n只需修改 _config.yml 文件，中以下内容，即可修改用户名\n```\nauthor: 你的用户名\n```\n\n## 完成主题更换\n\n至此，基本的冤死就已经设置完毕了，基本上只要修改 _config.yml 文件，就可以控制网站中所有的元素了，而官方的帮助文档也写的很清楚如何对各个模块进行设置\n\n我的这篇文章只是针对我的设置进行了一个记录，所以需要更多资料的可以去参考官方的文档，基本上是写的非常明白了\n\n## 部署到GitHub\n\n跟之前一样，完成修改之后要部署到github，只需要以下几行命令\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n\n部署完成之后稍等一会，就可以看到修改之后的内容了\n\n## 相关链接\n\n[官方文档](https://hexo.io/zh-cn/docs/)\n\n[主题商城](https://hexo.io/themes/)\n\n","tags":["Hexo","记录"],"categories":["博客","Hexo"]},{"title":"记录博客主页的搭建(一)","url":"/2021/06/24/2021-06-24-记录博客主页的搭建(一)/","content":"\n# 记录博客主页的搭建(一)\n\n## 1.心血来潮\n有一个自己的网站，是我心中一直存在的一个想法，因最近学业压力不是很大，碰巧看到阿里云的域名首年特惠只要一元，就顺便买了一个域名，准备着手搭建个人网站，在此之前，我对博客网站几乎是没有过了解，所以在查阅了一些资料之后，以Hexo+Github Page的方式进行我的网站的搭建，以下就是具体的过程。\n\n## 2.搭建过程\n\n**相关的搭建过程网上随便一找就有很多，我这里只是对我建站的过程进行记录，具有一定参考价值。**\n\n### 2.1 下载node.js以及git并安装\n在使用[Hexo](https://hexo.io/zh-cn/)框架进行搭建网站之前，首先要下载安装[node.js](https://nodejs.org/zh-cn/)和[git](https://git-scm.com/)，以便于安装Hexo以及代码的管理。\n\n*具体的安装注意事项*\n1. Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本\n2. 使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）\n3. 对于中国大陆地区用户，可以前往官网或者淘宝Git for Windows镜像下载 git 安装包（仅针对Windows）\n4. 安装完毕以上两个软件之后就可以进行Hexo的安装了\n### 2.2 安装Hexo\n在想要安装Hexo的位置右键打开**Git Bash Here**通过命令行来进行安装，输入以下命令\n```\nnpm install -g hexo-cli\n```\n点击回车即可进行安装，然后安装完成之后进行一下初始化\n```\nhexo init\nnpm install\n```\n分别输入以上两句并回车，就会生成初始的菜单，大概的目录是这样子的\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n下面是各个目录的具体功能：\n\n**config.yml**\n网站的配置信息，可以在此配置大部分的参数。后面发布到github上面时，有用到这个文件；\n**package.json**\n应用程序的信息\n**source**\n是网站中一下资源的文件夹，博客内容也都放在这里\n**themes**\n网站主题的放置的位置\n\n*其他更具体的介绍可以参考[官方文档](https://hexo.io/zh-cn/docs/)*\n\n### 2.3 预览Hexo博客\n此时就可以预览自己搭建的博客了，但是所有东西都是初始的，输入以下的命令即可\n```\nnpm install hexo-server --save\nhexo server\n```\n*以上命令同样是在Git Bash Here中输入*\n然后在浏览器网址栏输入**localhost:4000**\n如果以上项目能启动就说明成功了，接下来将项目搭建到GitHub上面\n\n### 2.4 将项目部署到GitHub\n1. 在GitHub中新建一个仓库，然后命名为**用户名.github.io**，只有这样子GitHub才会将其设置为用户的博客![]( https://ftp.bmp.ovh/imgs/2021/06/bd90f51e057bd717.jpg )\n\n*因为我已经有一个库了，所以显示错误*\n\n2. **将本地搭建好的hexo发布到github上**\n\n首先输入以下代码安装一个插件\n```\nnpm install hexo-deployer-git --save\n```\n\n修改网站配置文件_config.yml,添加deploy信息\n\n```\ndeploy:\n  type: git \n  repo: git@github.com:用户名/用户名.github.io.git \n  branch: master(也就是想要上传的分支)\n```\n\n3. **生成SSH key**\n\n在git中输入以下命令\n```\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n然后会提示输入passphrase（本步骤可以跳过），相当于设置一个密码，之后跟github进行操作时都会要求输入密码，避免误操作\n然后将新生成的key添加到ssh-agent中\n```\nssh-add ~/.ssh/id_rsa\n```\n就可以在上面的路径下找到ssh的文件了![]( https://ftp.bmp.ovh/imgs/2021/06/1536b7e2cd20e1b1.jpg )\n\n4. **将ssh添加到GitHub中**\n\n打开id_rsa.pub文件将一整串公钥拷贝下来\n打开GitHub的个人设置界面，按照以下图片的步骤进行添加ssh\n![]( https://ftp.bmp.ovh/imgs/2021/06/f27d25e0e14f55ce.jpg )\n\ntitle随意，key填id_rsa.pub文件中内容，然后保存即可。\n至此，就成功将ssh添加到github中了\n\n5. **测试是否连接成功**\n\n输入以下命令\n```\nssh -T git@github.com\n```\n如果出现以下文字就说明连接成功了\n```\nHi wispyoureyes! You've successfully authenticated, but GitHub does not provide shell access.\n```\n\n6. 上传静态文件\n\n成功与GitHub建立连接之后，就可以生成静态文件上传到github中了\n\n```\nhexo clean  //清除缓存文件db.json和已生成的静态文件public\nhexo g   //生成网站静态文件到默认设置的public文件夹\nhexo d   //部署网站到设定的仓库\n```\n然后再网址栏输入GitHub仓库的名称就可以访问了\n\n## 3.绑定域名\n\n1. 首先到阿里云或者其他的云服务商购买一个域名\n2. 然后进行域名解析\n3. 登陆阿里云控制台，选择域名选项，添加两条CNAME解析\n4. 然后在GitHub的仓库设置中，下滑找到Github Pages ，点击进去，在Custom domain里填入你的域名，然后点击Save，稍等一会就好了。\n5. 然后就可以通过你的域名来进入博客了\n\n*关于备案，如果要部署到国内的服务器上面需要进行备案，从哪里买的域名就从哪里备案GitHub属于国外的服务器，是不用进行备案的*\n\n\n\n## 4.相关链接\n\n[生成ssh](https://www.jianshu.com/p/31cbbbc5f9fa/)\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\n[阿里云](https://www.aliyun.com/?spm=5176.12901015.0.i12901015.ba0e525c2qLtLM)\n\n[淘宝git for windows 镜像](https://npm.taobao.org/mirrors/git-for-windows/)\n\n[淘宝node.js镜像](https://npm.taobao.org/mirrors/node)","tags":["Hexo","记录"],"categories":["博客","Hexo"]},{"title":"基于Swing的简易点餐系统","url":"/2021/06/21/2021-06-21-基于Swing的简易点餐系统/","content":"\n# 基于Swing的建议点餐系统\n\n## 1. 应用技术\n```\nSwing、JDBC、Oracle数据库、Java基础\n```\n## 2.项目功能\n```\n工作人员：菜品的增删改查、工作人员点餐、为顾客进行排号叫号、利润查询、结账。\n顾客：顾客点餐、查看积分、查看菜单、自助结账。\n```\n## 3.项目历程\n### 3.1 项目准备\n\n总所周知，Swing对于Java来说已经是一个不再使用的技术了，相对于微软的C#语言，Java的优势更在于Web端的应用，但是应教学的要求，主要是为了练习JDBC以及PL/SQL的使用，我们使用了Swing技术配合数据库使用，制作了一个简易的点餐系统，旨在熟悉一个项目的制作流程，从项目需求分析到项目开发到最后的维护发布，我作为小组长，带领了团队一共7位队员在老师的指导之下，完成了项目的开发。\n\n### 3.2 项目开发背景\n\n据了解，学校周围部分餐馆仍处于人工点餐、手工记账的阶段，这样子不仅容易在点餐时出现错记误记的情况，在最后记录时大量的数据也会十分繁琐，计算机软件统一的处理方式可以将以上的过程全都自动化一站式地完成，大大提高了效率；除此之外，使用计算机系统还大大减少了成本。\n发展点餐系统，是一种必然趋势，可以说点餐系统的出现，只是用现在较为成熟的计算机技术去改造传统行业的一个小小例子。这样的系统，将会不断地出现，而且会有力地推动传统行业的不断发展。\n\n### 3.3 项目开发\n\n在开始项目的开发之后，由于队员基础的参差不齐，所以在任务分配时对队员的能力分配了不同的任务，并针对队员能力进行了不同知识点的针对，由于是首次进行团队项目开发，并没有使用到GitHub进行协作开发，所以在最后整合代码时，碰到了较大的问题，jdk版本不统一，代码不能兼容等等问题，最后整合的代码也还有着大量的冗余，开发过程总体来说比较顺利，但是还是有很大的改进，在开发前进行数据库设计时，虽然说没有太多的表，但是对于项目小白的我们还是花费了一点时间。\n\n\n### 3.4 项目源码\n```\nhttps://github.com/chenyicai0819/2020_java_study/tree/main/OrderSystemToSix\n```","tags":["Swing"],"categories":["java","Swing"]},{"title":"我的第一条博客","url":"/2021/06/21/2021-06-21-我的第一条博客/","content":"\n# 这是我的第一条博客\n\n**1.初次接触**\n\n今天是2021年6月21日。我搭建了我的第一个个人博客网站，并发布了我的第一条个人博客，今后我会在上面发布一些自己的学习经历，个人感想等内容。\n","tags":["随笔"],"categories":["随笔"]}]